#!/usr/bin/env bash
#
#########################
#
# Copyright (C) 2013 Vittorio Cagnetta
# Copyright (C) 2013 Davide Depau
#
# Author: Vittorio Cagnetta <vaisarger@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along with this program, 
# called, in this distribution, "bashkaraoke-LICENSE"; if not, write to the 
# Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.
#
#########################
#
# Let's start...
#easybashgui_path="/usr/local/bin/easybashgui" #Set it if your system doesn't know where is EasyBashGUI...
#
##
#
export dir_Karaoke="${HOME}/.bashkaraoke"
if [ ! -d "${dir_Karaoke}" ]
	then
	if [ -d "${HOME}/.bash!karaoke" ]
		then
		mv -f "${HOME}/.bash!karaoke" "${dir_Karaoke}"
	else
		mkdir "${dir_Karaoke}" && chmod 777 "${dir_Karaoke}"
	fi
fi
#
export log_file=".bashkaraoke.log"
export timidity_log_file=".timidity.log"
export version_file=".version"
export pid_file=".pid"
export go_file=".go"
export HTML_karaoke_scriptname="hyperkar"
export xterm_karaoke_scriptname="xtermkar"
#
rc_file=".bashkaraoke.rc"
if [ -f "${dir_Karaoke}/.bash!karaoke.rc" ]
	then
	mv "${dir_Karaoke}/.bash!karaoke.rc" "${dir_Karaoke}/${rc_file}"
fi
if [ -f "${dir_Karaoke}/${rc_file}" ]
	then
	if [ $(wc -c 0< "${dir_Karaoke}/${rc_file}" ) -gt 0 ]
		then
		crea_rc_file="NO"
	else
		crea_rc_file="SI"
	fi
else
	crea_rc_file="SI"
fi
# =>
[ -f "${dir_Karaoke}/${rc_file}" ] && \
source "${dir_Karaoke}/${rc_file}"
#
##
#
source easybashgui
# easybashgui redundant check:
if [ ${#LIB_NAME} -eq 0 -o ${#LIB_VERSION} -eq 0 -o ${#LIB_URL} -eq 0 -o ${#LIB_AUTHOR} -eq 0 ]
	then
	if [ -f "${easybashgui_path}" ]
		then
		source "${easybashgui_path}"
	fi
fi
if [ ${#LIB_NAME} -eq 0 -o ${#LIB_VERSION} -eq 0 -o ${#LIB_URL} -eq 0 -o ${#LIB_AUTHOR} -eq 0 ]
	then
	echo -e "\n\nErr.: EasyBashGUI sourcing failed !\n\n"
	xterm -e "echo EasyBashGUI_sourcing_failed ; sleep 3"
	exit 1
fi
#
####################################
# Sezione iniziale: linguaggio...
lang="$(set | gsed -n s\#'LANG=\(.*\)'#'\1'#p )"
if [ ${#lang} -gt 0 ]
	then
	l="$(if [ $(echo -n "${lang}" | grep -i "it" | wc -c ) -gt 0 ]
			then
			echo "IT"
		else
			echo "EN"
		fi )"
else
	l="EN"
fi
export l
#
: l
#
####################################
#
BK_VERSION_NUMBER="8.0.5"
#
: version_file
echo "${BK_VERSION_NUMBER}" 1> "${dir_Karaoke}/${version_file}"
#
##
#
export MIN_LIB_VERSION_REQUIRED="4.0.3" # This is related to *EasyBashGUI* version...
# 
[ ${#LIB_URL} -eq 0 ] && export LIB_URL="https://sites.google.com/site/easybashgui"
#
##
#
export EMBEDDED_BROWSER_VERSION="0.2"
#
####################################
#
##
#
gtkrc_file=".bashkaraoke_gtkrc" # This is used by Xdialog
if [ -f "${dir_Karaoke}/${gtkrc_file}" ]
	then
	crea_gtkrc_file="NO"
else
	crea_gtkrc_file="SI"
fi
#
##
#
lista_karaoke="karaoke_list.txt"
#
##
#
export database="${dir_Karaoke}/database.txt"
#
##
#
timidity_extensions_var=".mid .rmi .rcp .r36 .g18 .g36 .mfi .kar .mod .wrd"
OTHER_karaoke_type_extensions_var=""
OTHER_AGAIN_karaoke_type_extensions_var=""
# ...
# ...
# =>
export extensions_var="${timidity_extensions_var} ${OTHER_karaoke_type_extensions_var} ${OTHER_AGAIN_karaoke_type_extensions_var}" 
#
##
#
default_background="black"
default_foreground_1="yellow"
default_foreground_2="red"
#
##
#
default_font_family="Ubuntu 50"
#
##
#
min_Volume="0"
default_Volume="100"
max_Volume="800"
#
min_Pitch="-24"
default_Pitch="0"
max_Pitch="24"
#
min_Tempo="10"
default_Tempo="100"
max_Tempo="400"
#
##
#
bashkaraoke_gtk="NO"
bk_gtk_binary="bashkaraoke-gtk"
esistenza_bashkaraoke_gtk="$(type "${bk_gtk_binary}" 2> /dev/null )"
if [ ${#esistenza_bashkaraoke_gtk} -gt 0 ]
	then
	bashkaraoke_gtk="SI"
fi #if [ ${#esistenza_bashkaraoke_gtk} -gt 0 ]
#
##
#
gtkdialog="NO"
esistenza_gtkdialog="$(type "gtkdialog" 2> /dev/null )"
if [ ${#esistenza_gtkdialog} -gt 0 ]
	then
	vers_gtkdialog="$(gtkdialog --version | cut -d ' ' -f 3 )"
	if [ $(echo -n "${vers_gtkdialog}" | tr -dc '[[:digit:]]' | wc -c ) -gt 0 ]
		then
		vers_gtkdialog_primo_campo=$(echo "${vers_gtkdialog}" | cut -d '.' -f 1 )
		vers_gtkdialog_secondo_campo=$(echo "${vers_gtkdialog}" | cut -d '.' -f 2 )
		vers_gtkdialog_terzo_campo=$(echo "${vers_gtkdialog}" | cut -d '.' -f 3 )
		# versione minima => 0.7.20 ...
		if [ ${vers_gtkdialog_primo_campo} -ge 0 -a ${vers_gtkdialog_secondo_campo} -ge 7 -a ${vers_gtkdialog_terzo_campo} -ge 20 ]
			then
			#
			gtkdialog="SI"
			#
		fi #if [ ${vers_gtkdialog_primo_campo} -ge 0 -a ${vers_gtkdialog_secondo_campo} -ge 7 -a ${vers_gtkdialog_terzo_campo} -ge 20 ]
		#
	fi #if [ $(echo -n "${vers_gtkdialog}" | tr -dc '[[:digit:]]' | wc -c) -gt 0 ]
	#
fi #if [ ${#esistenza_gtkdialog} -gt 0 ]
#
##
#
if [ "${gtkdialog}" = "SI" ]
	then
	default_mode="gtkdialog"
elif [ "${gtkdialog}" = "NO" ]
	then
	default_mode="auto"
	#
	esistenza_Xdialog="$(type "Xdialog" 2> /dev/null )"
	if [ ${#esistenza_Xdialog} -gt 0 ]
		then
		Xdialog_presente_e_funzionante="$(Xdialog --version 2>&1 )"
		if [ $(echo -n "${Xdialog_presente_e_funzionante}" | grep "Do you run under X11 with GTK.*installed ?" | wc -c ) -eq 0 ]
			then
			default_mode="Xdialog"
			#
		fi
		#
	fi
	#
fi
#
##
#
#default_font="-b&h-luxi sans-bold-r-normal-*-*-400-*-*-p-*-iso8859-1"
if [ "${mascotte}" = "Beastie" ]
	then
	default_font="-b&h-lucidatypewriter-medium-r-normal-sans-70-*-*-*-*-*-iso8859-1"
elif [ "${mascotte}" = "Tux" ]
	then
	default_font="-misc-fixed-medium-r-normal--100-*-*-*-*-*-iso8859-1"
fi
#
##
#
default_soundfont="$(if [ -f "/usr/local/share/timidity/PC51f.sf2" ]
				then
				echo -n "/usr/local/share/timidity/PC51f.sf2"
			else
				:
			fi )"
#
##
#
default_columns="24"
default_width="500"
default_height="500"
#
##
#
##################################
#
##
#
width="${default_width}"
height="${default_height}"
if [ "${mode}" = "kdialog" ]
	then
	if [ ${#x_root} -gt 0 -a ${#y_root} -gt 0 ]
		then
		x="+$(( $(( ${x_root} / 2 )) - $(( ${width} / 2 )) ))"
		y="+$(( $(( ${y_root} / 2 )) - $(( ${height} / 2 )) ))"
	fi
	dimensione_finestra="--geometry=${width}x${height}${x}${y}"
	dimensione_finestra_1="--geometry=${width}x${height}${x}${y}"
	dialogo="kdialog ${dimensione_finestra}"
elif [ "${mode}" = "zenity" ]
	then
	dimensione_finestra="--width=${width} --height=${height}"
	dimensione_finestra_1="--width=${width} --height=${height}"
elif [ "${mode}" = "Xdialog" ]
	then
	dimensione_finestra="${width}x${height}"
	dimensione_finestra_1="${width}x${height}"
fi
#
##
#
export big_BK_icon="$(pwd)/bashkaraoke_FILES/bashkaraoke_BIG.xpm"
export small_BK_icon="$(pwd)/bashkaraoke_FILES/bashkaraoke_SMALL.xpm"
export buc_BK_icon="$(pwd)/bashkaraoke_FILES/bashkaraoke_BUC.xpm"
export gsw_BK_icon="$(pwd)/bashkaraoke_FILES/bashkaraoke_GSW.xpm"
export gsw_BK_DOUBLE_icon="$(pwd)/bashkaraoke_FILES/bashkaraoke_DOUBLE.xpm"
export window_BK_icon="$(pwd)/bashkaraoke_FILES/bashkaraoke_icon.png"
export black_icon="$(pwd)/bashkaraoke_FILES/black.png"
export red_icon="$(pwd)/bashkaraoke_FILES/red.png"
export green_icon="$(pwd)/bashkaraoke_FILES/green.png"
export yellow_icon="$(pwd)/bashkaraoke_FILES/yellow.png"
export blue_icon="$(pwd)/bashkaraoke_FILES/blue.png"
export magenta_icon="$(pwd)/bashkaraoke_FILES/magenta.png"
export cyan_icon="$(pwd)/bashkaraoke_FILES/cyan.png"
export white_icon="$(pwd)/bashkaraoke_FILES/white.png"
export gsw_sing_BK_icon="$(pwd)/bashkaraoke_FILES/bashkaraoke_icon.png"
#
##
#
export embedded_browser_dir="$(pwd)/realtime_dialog_${EMBEDDED_BROWSER_VERSION}"
export embedded_browser="${embedded_browser_dir}/realtime_dialog.py"
#
##
#
if [ "${mode}" = "gtkdialog" ]
	then
	:
	#
elif [ "${mode}" = "kdialog" ]
	then
	kdialog()
		{
		num_param=${#}
		IFS=$'\t'
		exec	kdialog	--icon	${window_BK_icon}	$(for (( index=1 ; index <= ${num_param} ; index++ ))
									do
									echo -en "${1}\t"
									shift
								done )
		#
		}
	#
elif [ "${mode}" = "zenity" ]
	then
	:
	zenity()
		{
		num_param=${#}
		IFS=$'\t'
		exec	zenity	--window-icon	${window_BK_icon}	$(for (( index=1 ; index <= ${num_param} ; index++ ))
										do
										echo -en "${1}\t"
										shift
									done )
		#
		}
	#
elif [ "${mode}" = "Xdialog" ]
	then
	Xdialog()
		{
		num_param=${#}
		if [ "${FUNCT_NAME}" = "menu" ]
			then
			#
			IFS=$'\t'
			exec	Xdialog	--rc-file	${dir_Karaoke}/${gtkrc_file}	--icon	${small_BK_icon}	$(for (( index=1 ; index <= ${num_param} ; index++ ))
										do
										[[ ${1} = Select* ]] && echo -en " \t" && shift && continue
										#
										echo -en "${1}\t"
										shift
									done )
			#
		elif [ "${FUNCT_NAME}" = "input" ]
			then
			#
			IFS=$'\t'
			exec	Xdialog	--rc-file	${dir_Karaoke}/${gtkrc_file}	--icon	${big_BK_icon}	$(for (( index=1 ; index <= ${num_param} ; index++ ))
										do
										[[ ${1} = Please* ]] && echo -en " \t" && shift && continue
										#
										echo -en "${1}\t"
										shift
									done )
			#
		elif [ "${FUNCT_NAME}" = "list" ]
			then
			#
			IFS=$'\t'
			exec	Xdialog	--rc-file	${dir_Karaoke}/${gtkrc_file}	--icon	${small_BK_icon}	$(for (( index=1 ; index <= ${num_param} ; index++ ))
										do
										[[ ${1} = Select* ]] && echo -en " \t" && shift && continue
										[[ ${1} = --icon ]] && shift && continue
										[[ ${1} = *.xpm ]] && shift && continue
										#
										echo -en "${1}\t"
										shift
									done )
		else
			#
			IFS=$'\t'
			exec	Xdialog	--rc-file	${dir_Karaoke}/${gtkrc_file}	--icon	${big_BK_icon}	$(for (( index=1 ; index <= ${num_param} ; index++ ))
										do
										[[ ${1} = --icon ]] && shift && continue
										[[ ${1} = *.xpm ]] && shift && continue
										#
										echo -en "${1}\t"
										shift
									done )
			#
		fi
		}
	#
fi
#
##
#
: # arrotonda()
percentualizza()
	{
	start_value_percent=0
	end_value_percent=100
	#
	start_value="${1}"
	init_value="${2}"
	end_value="${3}"
	#
	num_tot_elementi=$(( ${end_value} - ${start_value} ))
	diff_values_percent=$(( ${end_value_percent} - ${start_value_percent} ))
	step=$(echo "scale=2; ${num_tot_elementi} / ${diff_values_percent}" | bc -l )
	# =>
	init_value_percent_float=$(echo "scale=2; $(( ${init_value} - ${start_value} )) / ${step}" | bc -l )
	init_value_percent=$(arrotonda "${init_value_percent_float}" )
	#
	echo "${start_value_percent} ${init_value_percent} ${end_value_percent}"
	}
#
##
#
###############################################
###############################################
#
##
#
####################################
# Sezione "dipendenze"...
#
# 1) bash vers. >= 3.X.X :
if [ $(echo -n "${BASH_VERSION}" | tr -dc '[[:digit:]]' | wc -c ) -eq 0 ]
	then
	[ "${l}" = "IT" ] && alert_message "Errore: \n non ho potuto \n determinare \n la versione di bash..."
	[ "${l}" = "EN" ] && alert_message "Error: \n I couldn't \n get bash version..."
	clean_temp
	exit 1
else
	# Ok, ${BASH_VERSION} exists and is correct...
	if [ $(echo "${BASH_VERSION}" | cut -d '.' -f 1) -lt 3 ]
		then
		[ "${l}" = "IT" ] && alert_message "Sembra\nche hai\nuna versione\ndi\"bash\"\nnel tuo sistema\ninferiore\nalla 3.X.X\n...\n\n\n\n\nPer favore,\ninstalla\nuna versione\nrecente\ndi bash\nprima\ndi lanciare\nil programma"
		[ "${l}" = "EN" ] && alert_message "It seems\nyou have\na \"bash\"\nversion\nin your system\nprior\nto 3.X.X\n...\n\n\n\n\nPlease,\ninstall\na recent\nbash\nversion\nfirst"
		clean_temp
		exit 1
	fi
fi
# 2) gsed :
if [ $(echo -n "$(type "gsed" 2>/dev/null)" | wc -c) -eq 0 ]
	then
	[ "${l}" = "IT" ] && alert_message "Sembra\nche non hai\n\"gsed\"\n( = GNU sed )\nnel tuo sistema\noppure\nil binario \"gsed\" \nnon si trova\nnel path\n...\n\n\nX l'utente FreeBSD:\nper favore,\ninstalla il port\n\"gsed\" prima..."
	[ "${l}" = "EN" ] && alert_message "It seems\nyou don't have\n\"gsed\"\n( = GNU sed )\nin your system\nor\n\"gsed\" binary\nisn't in your path\n...\n\n\n@ FreeBSD user:\nplease,\ninstall \"gsed\"\nport first..."
	clean_temp
	exit 1
fi
# 3) xterm :
if [ $(echo -n "$(type "xterm" 2>/dev/null)" | wc -c) -eq 0 ]
	then
	[ "${l}" = "IT" ] && alert_message "Sembra\nche non hai\n\"xterm\"\nnel tuo sistema\noppure\nil binario \"xterm\" \nnon si trova\nnel path\n...\n\n$(basename "${0}" )\ne' testato\nsolo\ncon quel tipo\ndi terminale\n...\n\n\nPer favore,\ninstallalo prima\ndi lanciare\nil programma."
	[ "${l}" = "EN" ] && alert_message "It seems\nyou don't have\n\"xterm\"\nin your system\nor\n\"xterm\" binary\nisn't in your path\n...\n\n$(basename "${0}" )\nis tested\nonly\nwith that\nterminal\n type...\n\n\nPlease,\ninstall it first."
	clean_temp
	exit 1
fi
# 4) timidity :
if [ $(echo -n "$(type "timidity" 2>/dev/null)" | wc -c) -eq 0 ]
	then
	[ "${l}" = "IT" ] && alert_message "Sembra\nche non hai\n\"timidity\"\nnel tuo sistema\noppure\nil binario \"timidity\" \nnon si trova\nnel path\n...\n\n$(basename "${0}" )\ne' niente\nsenza di esso... :-)\n\n\nPer favore,\ninstallalo prima\ndi lanciare\nil programma."
	[ "${l}" = "EN" ] && alert_message "It seems\nyou don't have\n\"timidity\"\nin your system\nor\n\"timidity\" binary\nisn't in your path\n...\n\n$(basename "${0}" )\nis nothing\nwithout it... :-)\n\n\nPlease,\ninstall it first."
	clean_temp
	exit 1
fi
# 5) mktemp :
if [ $(echo -n "$(type "mktemp" 2>/dev/null)" | wc -c) -eq 0 ]
	then
	[ "${l}" = "IT" ] && alert_message "Sembra\nche non hai\n\"mktemp\"\nnel tuo sistema\noppure\nil binario \"mktemp\"\nnon si trova\nnnel path\n...\n\nNe ho bisogno\nper gestire\ni files\ntemporanei\nin modo sicuro...\n;-)\n\n\nPer favore,\ninstallalo prima\ndi lanciare\nil programma."
	[ "${l}" = "EN" ] && alert_message "It seems\nyou don't have\n\"mktemp\"\nin your system\nor\n\"mktemp\" binary\nisn't in your path\n...\n\nI need it\nto handle temp files\nin a secure way...\n;-)\n\n\nPlease,\ninstall it first."
	clean_temp
	exit 1
fi
# 6) easybashgui :
if [ $(echo -n "$(type "easybashgui" 2>/dev/null)" | wc -c) -eq 0 ]
	then
	[ "${l}" = "IT" ] && echo -e "Sembra che non hai \"easybashgui\" nel tuo sistema \n oppure la libreria \"easybashgui\" non si trova nel path...\n\n\n Per favore, scaricala da ${LIB_URL}, copiala nel tuo path ( p.es.: in /usr/local/bin/ ), e linkala in questo modo: \"ln -s /usr/local/bin/easybashgui_?.?.? /usr/local/bin/easybashgui\" ." 1>&2
	[ "${l}" = "EN" ] && echo -e "It seems you don't have \"easybashgui\" in your system \n or \"easybashgui\" library isn't in your path ...\n\n\n Please, download it from ${LIB_URL}, copy it in your path (e.g.: in /usr/local/bin/ ), and link it in this way: \"ln -s /usr/local/bin/easybashgui_?.?.? /usr/local/bin/easybashgui\" ." 1>&2
	#clean_temp
	exit 1
else
	# Ok, easybashgui exists... let's check min required version...
	: LIB_VERSION
	: MIN_LIB_VERSION_REQUIRED
	IFS=$'. \t\n'
	array_LIB_VERSION=( $(echo -n "${LIB_VERSION}" ) )
	array_MIN_LIB_VERSION_REQUIRED=( $(echo -n "${MIN_LIB_VERSION_REQUIRED}" ) )
	IFS=$' \t\n'
	#
	if [ ${array_LIB_VERSION[0]} -gt ${array_MIN_LIB_VERSION_REQUIRED[0]} ]
		then
		obsolete_lib="NO"
	elif [ ${array_LIB_VERSION[0]} -lt ${array_MIN_LIB_VERSION_REQUIRED[0]} ]
		then
		obsolete_lib="YES"
	elif [ ${array_LIB_VERSION[0]} -eq ${array_MIN_LIB_VERSION_REQUIRED[0]} ]
		then
		if [ ${array_LIB_VERSION[1]} -gt ${array_MIN_LIB_VERSION_REQUIRED[1]} ]
			then
			obsolete_lib="NO"
		elif [ ${array_LIB_VERSION[1]} -lt ${array_MIN_LIB_VERSION_REQUIRED[1]} ]
			then
			obsolete_lib="YES"
		elif [ ${array_LIB_VERSION[1]} -eq ${array_MIN_LIB_VERSION_REQUIRED[1]} ]
			then
			if [ ${array_LIB_VERSION[2]} -gt ${array_MIN_LIB_VERSION_REQUIRED[2]} ]
				then
				obsolete_lib="NO"
			elif [ ${array_LIB_VERSION[2]} -lt ${array_MIN_LIB_VERSION_REQUIRED[2]} ]
				then
				obsolete_lib="YES"
			elif [ ${array_LIB_VERSION[2]} -eq ${array_MIN_LIB_VERSION_REQUIRED[2]} ]
				then
				obsolete_lib="NO"
				# perche' le due versioni sono ESATTAMENTE identiche...
			fi
			#
		fi #if [ ${array_LIB_VERSION[1]} -gt ${array_MIN_LIB_VERSION_REQUIRED[1]} ]
		#
	fi #if [ ${array_LIB_VERSION[0]} -gt ${array_MIN_LIB_VERSION_REQUIRED[0]} ]
	#
	if [ "${obsolete_lib}" = "YES" ]
		then
		[ "${l}" = "IT" ] && alert_message "Sembra \n che hai \n una versione \n di \"easybashgui\" \n nel tuo sistema \n inferiore \n alla ${MIN_LIB_VERSION_REQUIRED}\n...\n\n\n\n\n Per favore, \n scarica da \n ${LIB_URL} \n una versione \n recente \n di \"easybashgui\" \n e installala \n prima \n di lanciare \n il programma... :("
		[ "${l}" = "EN" ] && alert_message "It seems \n you have \n an \"easybashgui\" \n version \n in your system \n prior \n to ${MIN_LIB_VERSION_REQUIRED}\n...\n\n\n\n\n Please, \n download from \n ${LIB_URL} \n a recent \n \"easybashgui\" \n version \n and install it \n first... :("
		clean_temp
		exit 1
	fi
fi
# Fine sezione "dipendenze"...
####################################
#
#
#
####
#(foreground colors)
export black='\E[30m'
export red='\E[31m'
export green='\E[32m'
export yellow='\E[33m'
export blue='\E[34m'
export magenta='\E[35m'
export cyan='\E[36m'
export white='\E[37m'
####
#
#
#
ciao()
	{
	[ "${l}" = "IT" ] && ok_message "A presto !"
	[ "${l}" = "EN" ] && ok_message "See you !"
	clean_temp
	exit 0
	}
#
#
#
crea_gtkrc_default()
	{
	cat <<-BLOCCO_CONFIGURAZIONE_GTKRC
	#File di configurazione gtkrc di _Xdialog_ di bashkaraoke
	style 'bashkaraoke'
		{
		#fontset = ""
		bg[NORMAL] = { 0.0, 0.0, 0.0 }
		#
		fg[NORMAL] = { 0.52, 0.52, 0.52 }	#grigio
		}
	#
	widget '*' style 'bashkaraoke'
BLOCCO_CONFIGURAZIONE_GTKRC
	}
if [ "${mode}" = "Xdialog" ]
	then
	if [ "${crea_gtkrc_file}" = "SI" ]
		then
		crea_gtkrc_default 1> "${dir_Karaoke}/${gtkrc_file}"
	fi
fi
#
#
#
crea_rc_default()
	{
	#
	bashkaraoke_gtk="NO"
	#
	cat <<-EOB1
	export bkbrowser="embedded"
	export use_gtk="false"
	export use_gsw="$(
			if [ "${bashkaraoke_gtk}" = "NO" -a "${gtkdialog}" = "SI" ]
				then
				echo -n "true"
			else
				echo -n "false"
			fi 
			)"
	export use_buc="false"
	export supermode="${default_mode}"
	export karaoke_window="true"
	export levels_window="$(
				if [ "${mode}" = "dialog" ]
					then
					echo -n "false"
				else
					echo -n "true"
				fi
				)"
	export channels_window="false"
	export spectrogram_window="false"
	export rows=2
	export columns=${default_columns}
	export font="${default_font}"
	export background="${default_background}"
	export foreground_1="${default_foreground_1}"
	export foreground_2="${default_foreground_2}"
	export soundfont="${default_soundfont}"
	export extract_way="internal"
	export error_correction_chars=0
	export LANG="en_GB.UTF-8"
	export char_encoding="ISO-8859-1"
	export delimiter="______________________________________"
	export predefvolume=${default_Volume}
	export predefpitch=${default_Pitch}
	export predefspeed=${default_Tempo}
	export font_family="${default_font_family}"
	export show_debug=0
	export show_tabs=0
EOB1
	#
	#
	#
	if [ ${#soundfont} -gt 0 ]
		then
		export soundfont_string="-x\"soundfont ${soundfont}\""
	else
		export soundfont_string=""
	fi
	}
#
#
#
	if [ "${crea_rc_file}" = "SI" ]
		then
		#
		crea_rc_default 1> "${dir_Karaoke}/${rc_file}"
		source "${dir_Karaoke}/${rc_file}"
		#
	fi
#
#
#
modifica_rc()
	{
	#
	scrivi="NO"
	#
	####
	#
	# bashkaraoke configuration: BEGIN 
	#
	# Main configuration menu...
	while :
		do
		[ "${l}" = "IT" ] && menu \
					"Finestre..." \
					"Estetica..." \
					"Suono..." \
					"Avanzato..." \
					"Varie..." \
					"TORNA alla configurazione di default..." \
					"${delimiter}" \
					"<-FATTO" 
		[ "${l}" = "EN" ] && menu \
					"Windows..." \
					"Apparence..." \
					"Sound..." \
					"Advanced..." \
					"Misc..." \
					"GO BACK to default configuration..." \
					"${delimiter}" \
					"<-DONE"
		scelta="$(0< "${dir_tmp}/${file_tmp}" )" ; [ ${#scelta} -eq 0 ] && break 1
		#
		if [ "${scelta}" = "Finestre..." -o "${scelta}" = "Windows..." ]
			then
			while :
				do
				[ "${l}" = "IT" ] && menu \
							"Modo..." \
							"Tipo..." \
							"${delimiter}" \
							"<-TORNA INDIETRO" 
				[ "${l}" = "EN" ] && menu \
							"Mode..." \
							"Type..." \
							"${delimiter}" \
							"<-BACK" 
				scelta_Finestre="$(0< "${dir_tmp}/${file_tmp}" )" ; [ ${#scelta_Finestre} -eq 0 ] && break 2
				#
				if [ "${scelta_Finestre}" = "Modo..." -o "${scelta_Finestre}" = "Mode..." ]
					then
					# 00) supermode
					if [ "${l}" = "IT" ]
						then
						if [ "${use_gsw}" = "true" ]
							then
							question "Modo \n attuale: \n\n \"GSW\" + \"${supermode}\" \n\n\n Vuoi \n cambiarlo?"
							risposta=${?}
						else
							question "Modo \n attuale: \n\n \"${supermode}\" \n\n\n Vuoi \n cambiarlo?"
							risposta=${?}
						fi
					elif [ "${l}" = "EN" ]
						then
						if [ "${use_gsw}" = "true" ]
							then
							question "Current \n \"mode\" : \n\n \"GSW\" + \"${supermode}\" \n\n\n Do you want \n change it?"
							risposta=${?}
						else
							question "Current \n \"mode\" : \n\n \"${supermode}\" \n\n\n Do you want \n change it?"
							risposta=${?}
						fi
					fi
					if [ ${risposta} -eq 0 ]
						then
						while :
							do
							[ "${l}" = "IT" ] && menu \
										"GSW (Gtkdialog Single Window, finestra singola)..." \
										"BUC (Basta Un Click, finestra singola)..." \
										"auto (finestra multipla)..." \
										"gtkdialog (finestra multipla)..." \
										"Xdialog (finestra multipla)..." \
										"kdialog (finestra multipla)..." \
										"zenity (finestra multipla)..." \
										"dialog (finestra multipla)..." \
										"${delimiter}" \
										"<-TORNA INDIETRO" 
							[ "${l}" = "EN" ] && menu \
										"GSW (Gtkdialog Single Window, single window)..." \
										"BUC (Basta Un Click, single window)..." \
										"auto (multiple window)..." \
										"gtkdialog (multiple window)..." \
										"Xdialog (multiple window)..." \
										"kdialog (multiple window)..." \
										"zenity (multiple window)..." \
										"dialog (multiple window)..." \
										"${delimiter}" \
										"<-BACK" 
							scelta_Modo="$(0< "${dir_tmp}/${file_tmp}" )"
							[ ${#scelta_Modo} -eq 0 ] && break 2
							[ "${scelta_Modo}" = "Modo..." -o "${scelta_Modo}" = "Mode..." ] && break 2
							#
							#wait_for "Please wait..."
							#
							if [ "${scelta_Modo}" != "${delimiter}" -a "${scelta_Modo}" != "<-TORNA INDIETRO" -a "${scelta_Modo}" != "<-BACK" ]
								then
								#
								scelta_Modo="$(echo "${scelta_Modo}" | cut -d ' ' -f 1 )"
								[ "${scelta_Modo}" = "GTK" ] && scelta_Modo="gtk"
								[ "${scelta_Modo}" = "GSW" ] && scelta_Modo="gsw"
								[ "${scelta_Modo}" = "BUC" ] && scelta_Modo="buc"
								: scelta_Modo
								#
								###################
								# "auto"...
								if [ "${scelta_Modo}" = "auto" ]
									then
									#sleep 1
									#terminate_wait_for
									#
									use_gtk="false"
									use_gsw="false"
									use_buc="false"
									#
								else
									#
									###################
									# Begin check "binario"...
									if [ "${scelta_Modo}" = "gtk" ] 
										then
										binario="bashkaraoke-gtk"
										#
									elif [ "${scelta_Modo}" = "gsw" ] 
										then
										binario="gtkdialog"
										#
									else
										binario="$(echo "${scelta_Modo}" )"
										#
									fi
									esistenza_binario="$(type "${binario}" 2> /dev/null )"
									if [ ${#esistenza_binario} -eq 0 ]
										then
										#sleep 1
										#terminate_wait_for
										#
										[ "${l}" = "IT" ] && alert_message "Per usare \n il modo \"${scelta_Modo}\", \n devi avere \"${binario}\" \n installato \n nel tuo sistema... "
										[ "${l}" = "EN" ] && alert_message "To use \n \"${scelta_Modo}\" mode, \n you must have \"${binario}\" \n in your system... "
										#
										continue 1
									fi
									# End check "binario"...
									#
									###################
									#
									# "You have to restart"...
									if [ "${use_gtk}" = "true" -o "${use_gsw}" = "true" -o "${use_buc}" = "true" ]
										then
										if [ "${scelta_Modo}" != "gtk" -a "${scelta_Modo}" != "gsw" -a "${scelta_Modo}" != "buc" ]
											then
											#
											#sleep 1
											#terminate_wait_for
											#
											[ "${l}" = "IT" ] && alert_message "Per usare \n il modo \"${scelta_Modo}\", \n devi riavviare \n il programma..."
											[ "${l}" = "EN" ] && alert_message "To use \n \"${scelta_Modo}\" mode, \n you have to \n restart program..."
											#
											#wait_for "Please wait..."
											#
										fi
										#
									else
										#
										:
										#sleep 1
										#terminate_wait_for
										#
									fi
									#
									###################
									#
									# Begin GTK, GSW and BUC settings...
									if [ "${scelta_Modo}" = "gtk" ]
										then
										use_gtk="true"
										#
										#sleep 1
										#terminate_wait_for
										#
										[ "${l}" = "IT" ] && alert_message "Per usare \n il modo \"GTK\", \n devi riavviare \n il programma..."
										[ "${l}" = "EN" ] && alert_message "To use \n \"GTK\" mode, \n you have to \n restart program..."
										#
										#wait_for "Please wait..."
										#
										scelta_Modo="${supermode}"
										: scelta_Modo
									else
										use_gtk="false"
										#
										: scelta_Modo
									fi
									#
									if [ "${scelta_Modo}" = "gsw" ]
										then
										use_gsw="true"
										#
										#sleep 1
										#terminate_wait_for
										#
										[ "${l}" = "IT" ] && alert_message "Per usare \n il modo \"GSW\", \n devi riavviare \n il programma..."
										[ "${l}" = "EN" ] && alert_message "To use \n \"GSW\" mode, \n you have to \n restart program..."
										#
										#wait_for "Please wait..."
										#
										scelta_Modo="gtkdialog" # gtkdialog -it's _sure_ - is in the system...
										: scelta_Modo
									else
										use_gsw="false"
										#
										: scelta_Modo
									fi
									#
									if [ "${scelta_Modo}" = "buc" ]
										then
										use_buc="true"
										#
										#sleep 1
										#terminate_wait_for
										#
										esistenza_kdialog="$(type "kdialog" 2> /dev/null )"
										if [ ${#esistenza_kdialog} -gt 0 ]
											then
											if [ "${l}" = "IT" ]
												then
												question "Preferisci kdialog \n nelle finestre?"
												risp="${?}"
											elif [ "${l}" = "EN" ]
												then
												question "Do you prefere kdialog \n in windows?"
												risp="${?}"
											fi
											if [ ${risp} -eq 0 ]
												then
												scelta_Modo="kdialog"
											elif [ ${risp} -eq 1 ]
												then
												scelta_Modo="${supermode}"
											else
												exit 0
											fi
											#
										fi
										: scelta_Modo
									else
										use_buc="false"
										#
										: scelta_Modo
									fi
									# End GSW and BUC settings...
									#
									##############################
									#
									if [ "${scelta_Modo}" = "dialog" ]
										then
										for fd in 0 1
											do
											if [ ! -t ${fd} ]
												then
												#terminate_wait_for
												[ "${l}" = "IT" ] && alert_message "Per usare \n il modo \"dialog\", \n devi lanciare \n $(basename "${0}" ) \n da un terminale... "
												[ "${l}" = "EN" ] && alert_message "To use \n \"dialog\" mode, \n you must launch \n  $(basename "${0}" ) \n from a terminal... "
												continue 2
											fi
										done
									fi
									#
								fi #if [ "${scelta_Modo}" = "auto" ]
								#
								supermode="$(echo "${scelta_Modo}" )"
								# =>
								source easybashgui
								#
								##
								#
								export width="${default_width}"
								export height="${default_height}"
								if [ "${mode}" = "gtkdialog" ]
									then
									:
								elif [ "${mode}" = "kdialog" ]
									then
									if [ ${#x_root} -gt 0 -a ${#y_root} -gt 0 ]
										then
										x="+$(( $(( ${x_root} / 2 )) - $(( ${width} / 2 )) ))"
										y="+$(( $(( ${y_root} / 2 )) - $(( ${height} / 2 )) ))"
									fi
									dimensione_finestra="--geometry=${width}x${height}${x}${y}"
									dimensione_finestra_1="--geometry=${width}x${height}${x}${y}"
									dialogo="kdialog ${dimensione_finestra}"
								elif [ "${mode}" = "zenity" ]
									then
									dimensione_finestra="--width=${width} --height=${height}"
									dimensione_finestra_1="--width=${width} --height=${height}"
								elif [ "${mode}" = "Xdialog" ]
									then
									dimensione_finestra="${width}x${height}"
									dimensione_finestra_1="${width}x${height}"
								fi
								#
								if [ "${mode}" = "gtkdialog" ]
									then
									:
								elif [ "${mode}" = "kdialog" ]
									then
									kdialog()
										{
										num_param=${#}
										IFS=$'\t'
										exec	kdialog	--icon	${window_BK_icon}	$(for (( index=1 ; index <= ${num_param} ; index++ ))
																	do
																	echo -en "${1}\t"
																	shift
																done )
										#
										}
									#
								elif [ "${mode}" = "zenity" ]
									then
									:
									zenity()
										{
										num_param=${#}
										IFS=$'\t'
										exec	zenity	--window-icon	${window_BK_icon}	$(for (( index=1 ; index <= ${num_param} ; index++ ))
																		do
																		echo -en "${1}\t"
																		shift
																	done )
										#
										}
									#
								elif [ "${mode}" = "Xdialog" ]
									then
									Xdialog()
										{
										num_param=${#}
										if [ "${FUNCT_NAME}" = "menu" ]
											then
											#
											IFS=$'\t'
											exec	Xdialog	--rc-file	${dir_Karaoke}/${gtkrc_file}	--icon	${small_BK_icon}	$(for (( index=1 ; index <= ${num_param} ; index++ ))
																		do
																		[[ ${1} = Select* ]] && echo -en " \t" && shift && continue
																		#
																		echo -en "${1}\t"
																		shift
																	done )
											#
										elif [ "${FUNCT_NAME}" = "input" ]
											then
											#
											IFS=$'\t'
											exec	Xdialog	--rc-file	${dir_Karaoke}/${gtkrc_file}	--icon	${big_BK_icon}	$(for (( index=1 ; index <= ${num_param} ; index++ ))
																		do
																		[[ ${1} = Please* ]] && echo -en " \t" && shift && continue
																		#
																		echo -en "${1}\t"
																		shift
																	done )
											#
										elif [ "${FUNCT_NAME}" = "list" ]
											then
											#
											IFS=$'\t'
											exec	Xdialog	--rc-file	${dir_Karaoke}/${gtkrc_file}	--icon	${small_BK_icon}	$(for (( index=1 ; index <= ${num_param} ; index++ ))
																		do
																		[[ ${1} = Select* ]] && echo -en " \t" && shift && continue
																		[[ ${1} = --icon ]] && shift && continue
																		[[ ${1} = *.xpm ]] && shift && continue
																		#
																		echo -en "${1}\t"
																		shift
																	done )
										else
											#
											IFS=$'\t'
											exec	Xdialog	--rc-file	${dir_Karaoke}/${gtkrc_file}	--icon	${big_BK_icon}	$(for (( index=1 ; index <= ${num_param} ; index++ ))
																		do
																		[[ ${1} = --icon ]] && shift && continue
																		[[ ${1} = *.xpm ]] && shift && continue
																		#
																		echo -en "${1}\t"
																		shift
																	done )
											#
										fi
										}
									#
								fi
								#
								##
								#
								#sleep 1
								#terminate_wait_for
								#
								break 1
								#
							else
								#
								:
								#terminate_wait_for
								#
							fi # if [ "${scelta_Modo}" != "${delimiter}" -a "${scelta_Modo}" != "<-TORNA INDIETRO" -a "${scelta_Modo}" != "<-BACK" ]
							if [ "${scelta_Modo}" = "${delimiter}" ]
								then
								#
								continue 1
								#
							elif [ "${scelta_Modo}" = "<-TORNA INDIETRO" -o "${scelta_Modo}" = "<-BACK" ]
								then
								#
								break 1
								#
							else
								ciao
							fi
						done
						#
					elif [ ${risposta} -eq 1 ]
						then
						:
					else
						ciao
					fi
					#
					continue 1
					#
				elif [ "${scelta_Finestre}" = "Tipo..." -o "${scelta_Finestre}" = "Type..." ]
					then
					# 0) karaoke_window
					: karaoke_window
					#
					# 1) levels_window
					: levels_window
					#
					# 2) channels_window
					: channels_window
					#
					# 3) spectrogram_window
					: spectrogram_window
					#
					[ "${l}" = "IT" ] && list \
								"$( [ "${karaoke_window}" = "true" ] && echo "+" || echo "-" )Karaoke (clicca per abilitare)..." \
								"$( [ "${levels_window}" = "true" ] && echo "+" || echo "-" )Livelli (clicca per abilitare)..." \
								"$( [ "${channels_window}" = "true" ] && echo "+" || echo "-" )Canali (clicca per abilitare)..." \
								"$( [ "${spectrogram_window}" = "true" ] && echo "+" || echo "-" )Spettrogramma (clicca per abilitare)..."
					[ "${l}" = "EN" ] && list \
								"$( [ "${karaoke_window}" = "true" ] && echo "+" || echo "-" )Karaoke (check to enable)..." \
								"$( [ "${levels_window}" = "true" ] && echo "+" || echo "-" )Levels (check to enable)..." \
								"$( [ "${channels_window}" = "true" ] && echo "+" || echo "-" )Channels (check to enable)..." \
								"$( [ "${spectrogram_window}" = "true" ] && echo "+" || echo "-" )Spectrogram (check to enable)..."
					IFS=$'\n' ; array_scelta_Finestre=( $(0< "${dir_tmp}/${file_tmp}" ) ) ; IFS=$' \t\n' ; [ ${#array_scelta_Finestre[@]} -eq 0 ] && continue 2
					#
					karaoke_window="false"
					levels_window="false"
					channels_window="false"
					spectrogram_window="false"
					for (( index=0 ; index < ${#array_scelta_Finestre[@]} ; index++ ))
						do
						scelta_Finestra="${array_scelta_Finestre[${index}]}"
						if [ "${scelta_Finestra}" = "Karaoke (clicca per abilitare)..." -o "${scelta_Finestra}" = "Karaoke (check to enable)..." ]
							then
							karaoke_window="true"
							continue
						elif [ "${scelta_Finestra}" = "Livelli (clicca per abilitare)..." -o "${scelta_Finestra}" = "Levels (check to enable)..." ]
							then
							levels_window="true"
							continue
						elif [ "${scelta_Finestra}" = "Canali (clicca per abilitare)..." -o "${scelta_Finestra}" = "Channels (check to enable)..." ]
							then
							channels_window="true"
							continue
						elif [ "${scelta_Finestra}" = "Spettrogramma (clicca per abilitare)..." -o "${scelta_Finestra}" = "Spectrogram (check to enable)..." ]
							then
							spectrogram_window="true"
							continue
						fi
					done
					#
					wait_seconds 2
					break 1
					#
				elif [ "${scelta_Finestre}" = "${delimiter}" ]
					then
					#
					continue 1
					#
				elif [ "${scelta_Finestre}" = "<-TORNA INDIETRO" -o "${scelta_Finestre}" = "<-BACK" ]
					then
					#
					break 1
					#
				else
					ciao
				fi
				#
			done
			#
			continue 1
			#
		elif [ "${scelta}" = "Estetica..." -o "${scelta}" = "Apparence..." ]
			then
			while :
				do
				[ "${l}" = "IT" ] && menu \
							"Colonne..." \
							"Tipo carattere..." \
							"Colore sfondo..." \
							"Colore testo gia' cantato..." \
							"Colore testo da cantare..." \
							"${delimiter}" \
							"<-TORNA INDIETRO" 
				[ "${l}" = "EN" ] && menu \
							"Columns..." \
							"Font..." \
							"Background color..." \
							"Lyric color (already sung)..." \
							"Lyric color (to sing)..." \
							"${delimiter}" \
							"<-BACK" 
				scelta_Estetica="$(0< "${dir_tmp}/${file_tmp}" )" ; [ ${#scelta_Estetica} -eq 0 ] && break 2
				if [ "${scelta_Estetica}" = "Righe..." -o "${scelta_Estetica}" = "Rows..." ]
					then
					# 4) rows
					if [ "${l}" = "IT" ]
						then
						question "Numero \n di righe \n attuale: \n\n \"${rows}\" \n\n\n Vuoi \n cambiarlo?"
						risposta=${?}
					elif [ "${l}" = "EN" ]
						then
						question "Current \n \"rows\" \n value: \n\n \"${rows}\" \n\n\n Do you want \n change it?"
						risposta=${?}
					fi
					if [ ${risposta} -eq 0 ]
						then
						[ "${l}" = "IT" ] && menu "2 (consigliato)" "3"
						[ "${l}" = "EN" ] && menu "2 (suggested)" "3"
						rows="$(cat "${dir_tmp}/${file_tmp}" | cut -d '(' -f 1 | cut -d ' ' -f 1 )" ; [ ${#rows} -eq 0 ] && continue 2
						wait_seconds 2
						break 1
						#
					elif [ ${risposta} -eq 1 ]
						then
						:
					else
						ciao
					fi
					#
					continue 1
					#
				elif [ "${scelta_Estetica}" = "Colonne..." -o "${scelta_Estetica}" = "Columns..." ]
					then
					# 5) columns
					if [ "${l}" = "IT" ]
						then
						question "Numero \n di columns \n attuale: \n\n \"${columns}\" \n\n\n Vuoi \n cambiarlo?"
						risposta=${?}
					elif [ "${l}" = "EN" ]
						then
						question "Current \n \"columns\" \nvalue: \n\n \"${columns}\" \n\n\n Do you want \n change it?"
						risposta=${?}
					fi
					if [ ${risposta} -eq 0 ]
						then
						input 1 "${columns}"
						columns="$(0< "${dir_tmp}/${file_tmp}" )" ; [ ${#columns} -eq 0 ] && continue 2
						wait_seconds 2
						break 1
						#
					elif [ ${risposta} -eq 1 ]
						then
						:
					else
						ciao
					fi
					#
					continue 1
					#
				elif [ "${scelta_Estetica}" = "Tipo carattere..." -o "${scelta_Estetica}" = "Font..." ]
					then
					# 6) font
					font_to_confirm="$(echo "${font}" | gsed s\#'^-'#''# )"
					if [ "${l}" = "IT" ]
						then
						question "Font \n attuale: \n\n \"$(echo "${font_to_confirm}" | tr '[[:punct:]]' '?' | tr -s '?' | tr '?' '\n' )\" \n\n\n Vuoi \n cambiarlo?"
						risposta=${?}
					elif [ "${l}" = "EN" ]
						then
						question "Current \n font: \n\n \"$(echo "${font_to_confirm}" | tr '[[:punct:]]' '?' | tr -s '?' | tr '?' '\n' )\" \n\n\n Do you want \n change it?"
						risposta=${?}
					fi
					if [ ${risposta} -eq 0 ]
						then
						if [ ${#columns} -eq 0 ]
							then
							verify_columns="${default_columns}"
						else
							verify_columns="${columns}"
						fi
						verify_font()
							{
							font_to_verify="-${1}"
							#
							[ "${l}" = "IT" ] && xterm -cr "${background}" -xrm 'xterm*cursorUnderLine: true' -xrm "xterm*allowWindowOps: true" -title "$(basename "${0}"): font check" -bg "${background}" -fg "${foreground_1}" -fn "${font_to_verify}" -geometry ${verify_columns}x2+20+400 -e "echo -en \"\n\n\n$(for ((i=1 ; i <= ${verify_columns} ; i++ )) ; do echo -en "${i:(-1)}" ; done)\n (premi un tasto...)\r\" ; read dummy_var"
							#
							[ "${l}" = "EN" ] && xterm -cr "${background}" -xrm 'xterm*cursorUnderLine: true' -xrm "xterm*allowWindowOps: true" -title "$(basename "${0}"): font check" -bg "${background}" -fg "${foreground_1}" -fn "${font_to_verify}" -geometry ${verify_columns}x2+20+400 -e "echo -en \"\n\n\n$(for ((i=1 ; i <= ${verify_columns} ; i++ )) ; do echo -en "${i:(-1)}" ; done)\n ( hit a key... )\r\" ; read dummy_var"
							}
						######################################
						if [ ${#esistenza_Xdialog} -gt 0 ]
							then
							Xdialog_presente_e_funzionante="$(command Xdialog --version 2>&1 )"
							if [ $(echo -n "${Xdialog_presente_e_funzionante}" | grep "Do you run under X11 with GTK.*installed ?" | wc -c ) -eq 0 ]
								then
								font_selector="Xdialog"
								#font_selector="self-made"
							else
								font_selector="self-made"
							fi
						else
							font_selector="self-made"
						fi
						: font_selector
						######################################
						#
						: font
						#
						if [ "${font_selector}" = "self-made" ]
							then
							[ "${l}" = "IT" ] && wait_for "Sto' cercando i tuoi fonts..."
							[ "${l}" = "EN" ] && wait_for "Retrieving your fonts..."
							lista__dirs="$(find /usr -maxdepth 4 -type d -path "*X11*" 2> /dev/null )"
							#lista__fonts_dir="$(find ${lista__dirs} -type f -name "fonts.dir" 2> /dev/null )"
							IFS=$'\n' ; array__fonts_dir=( $(find ${lista__dirs} -type f -name "fonts.dir" 2> /dev/null ) ) ; IFS=$' \t\n'
							#
							font_char_encoding="${char_encoding#*-}"
							#
							#lista_fonts="$(cat ${lista__fonts_dir} | grep "${font_char_encoding}$" | cut -d ' ' -f 2,3,4,5,6,7,8 | gsed s\#'^-'#''# )"
							if [ ${#array__fonts_dir[@]} -gt 0 ]
								then
								#lista__fonts_dir="$(for (( index=0 ; index < ${#array__fonts_dir[@]} ; index++ ))
								#			do
								#			fonts_dir="${array__fonts_dir[${index}]}"
								#			echo "${fonts_dir}"
								#		done )"
								lista__fonts_dir="$(for (( index=0 ; index < ${#array__fonts_dir[@]} ; index++ ))
											do
											fonts_dir="${array__fonts_dir[${index}]}"
											echo -en "\"${fonts_dir}\" "
										done )"
								lista_fonts="$(eval cat ${lista__fonts_dir} | grep "${font_char_encoding}$" | cut -d ' ' -f 2,3,4,5,6,7,8 | gsed s\#'^-'#''# )"
								#
							else
								lista_fonts=""
								#
							fi
							: lista_fonts
							#
							terminate_wait_for
							#
						fi
						: lista_fonts
						#
						old_font="${font_to_confirm}"
						prima_volta="SI"
						while :
							do
							#
							[ "${l}" = "IT" ] && menu \
										"Scegli un nuovo font..." \
										"Salva il font..." \
										"${delimiter}" \
										"Torna al font precedente..." \
										"Torna al font di default..." \
										"${delimiter}" \
										"<-TORNA INDIETRO" 
							[ "${l}" = "EN" ] && menu \
										"Choose a new font..." \
										"Save font..." \
										"${delimiter}" \
										"Back to prior font..." \
										"Back to default font..." \
										"${delimiter}" \
										"<-BACK" 
							scelta_fnt="$(0< "${dir_tmp}/${file_tmp}" )" ; [ ${#scelta_fnt} -eq 0 ] && break 1
							if [ "${scelta_fnt}" = "Scegli un nuovo font..." -o "${scelta_fnt}" = "Choose a new font..." ]
								then
								# Scelta font...
								if [ "${font_selector}" = "Xdialog" ]
									then
									command Xdialog --stdout --rc-file ${dir_Karaoke}/${gtkrc_file} --fontsel " " ${dimensione_finestra} 1> "${dir_tmp}/${file_tmp}"
									scelta_font="$(0< "${dir_tmp}/${file_tmp}" )" ; [ ${#scelta_font} -eq 0 ] && continue 3
									#
									font_to_confirm="$(echo "${scelta_font}" | gsed s\#'^-'#''# )"
									#
									[ "${prima_volta}" = "SI" ] && [ "${l}" = "IT" ] && message "Font \n attuale: \n\n \"$(echo "${font_to_confirm}" | tr '[[:punct:]]' '?' | tr -s '?' | tr '?' '\n' )\" \n ... \n\n Nella finestra \n successiva, \n se ${verify_columns} numeri \n sono sulla \n stessa riga, \n il font e' OK \n ..." ; prima_volta="NO"
									[ "${prima_volta}" = "SI" ] && [ "${l}" = "EN" ] && message "Current \n font: \n\n \"$(echo "${font_to_confirm}" | tr '[[:punct:]]' '?' | tr -s '?' | tr '?' '\n' )\" \n ...\n\n In next window, \n if ${verify_columns} numbers \n are on the same row, \n font is OK \n ..." ; prima_volta="NO"
									#
									#Verifica font...
									verify_font "${font_to_confirm}"
									#
								elif [ "${font_selector}" = "self-made" ]
									then
									if [ ${#lista_fonts} -eq 0 ]
										then
										[ "${l}" = "IT" ] && message "Per favore, \n scrivi il nome del font \n per esteso..."
										[ "${l}" = "EN" ] && message "Please, \n write complete \n font name..."
										#
										[ "${l}" = "IT" ] && input 1 "${font_to_confirm}"
										[ "${l}" = "EN" ] && input 1 "${font_to_confirm}"
										#
										font_to_confirm="$(0< "${dir_tmp}/${file_tmp}" )"
										#
										if [ ${#font_to_confirm} -gt 0 ]
											then
											[ "${l}" = "IT" ] && ok_message "Per favore, \n seleziona \n \"salva il font\" \n ..."
											[ "${l}" = "EN" ] && ok_message "Please, \n select \n \"save font\" \n ..."
										fi
										#
									else
										#
										IFS=$'\n'
										menu $(echo "${lista_fonts}" | grep -- '-' | cut -d '-' -f 1,2,3,4,5,6,7,8,9,10 | sort | uniq )
										IFS=$' \t\n'
										prefix="$(0< "${dir_tmp}/${file_tmp}" )" ; [ ${#prefix} -eq 0 ] && continue 3
										#
										IFS=$'\n' ; array_lista_finale=( $(echo "${lista_fonts}" | fgrep "${prefix}" | sort | uniq ) ) ; IFS=$' \t\n'
										#
										if [ ${#array_lista_finale[@]} -eq 0 ]
											then
											[ "${l}" = "IT" ] && alert_message "Nessun font \n usabile \n con quel nome \n ..."
											[ "${l}" = "EN" ] && alert_message "No usable font \n with that name \n ..."
											continue 1
										elif [ ${#array_lista_finale[@]} -eq 1 ]
											then
											font_to_confirm="${array_lista_finale[0]}"
											#
										elif [ ${#array_lista_finale[@]} -ge 2 ]
											then
											eval menu $(for (( index=0 ; index < ${#array_lista_finale[@]} ; index++ ))
														do
														#
														font_progressivo="${array_lista_finale[${index}]}"
														echo -en "\"${font_progressivo}\" "
														#
													done )
											font_to_confirm="$(0< "${dir_tmp}/${file_tmp}" )" ; [ ${#font_to_confirm} -eq 0 ] && continue 3
											#
										fi #if [ ${#array_lista_finale[@]} -eq 0 ]
										: font_to_confirm
										#
									fi #if [ ${#lista_fonts} -eq 0 ]
									: font_to_confirm
									#
									#[ "${prima_volta}" = "SI" ] && [ "${l}" = "IT" ] && message "Ora seleziona \n la dimensione \n del font \n ..." ; prima_volta="NO"
									#[ "${prima_volta}" = "SI" ] && [ "${l}" = "EN" ] && message "Now select \n font size \n ..." ; prima_volta="NO"
									#
									while :
										do
										[ "${l}" = "IT" ] && menu \
													"Scegli la dimensione..." \
													"${delimiter}" \
													"<-FATTO"
										[ "${l}" = "EN" ] && menu \
													"Choose size..." \
													"${delimiter}" \
													"<-DONE"
										scelta_dimensione_font="$(0< "${dir_tmp}/${file_tmp}" )" ; [ ${#scelta_dimensione_font} -eq 0 ] && continue 4
										#
										if [ "${scelta_dimensione_font}" = "Scegli la dimensione..." -o "${scelta_dimensione_font}" = "Choose size..." ]
											then
											[ ${#font_size} -gt 0 ] && init_value="${font_size}" || init_value="70"
											[ "${l}" = "IT" ] && adjust "Per favore, \n setta la dimensione \n del font" "20" "${init_value}" "120"
											[ "${l}" = "EN" ] && adjust "Please, \n adjust font size" "20" "${init_value}" "120"
											font_size="$(0< "${dir_tmp}/${file_tmp}" )" ; [ ${#font_size} -eq 0 ] && continue 4
											#
											font_to_confirm="$(echo "${font_to_confirm}" | gsed -n s\#"^\(.*\)-.*-.*-.*-.*-.*-.*-\(.*-.*\)$"#"\1-${font_size}-\*-\*-\*-\*-\*-\2"#p )"
											#
											[ "${prima_volta}" = "SI" ] && [ "${l}" = "IT" ] && message "Font \n attuale: \n\n \"$(echo "${font_to_confirm}" | tr '[[:punct:]]' '?' | tr -s '?' | tr '?' '\n' )\" \n ... \n\n Nella finestra \n successiva, \n se tutti i numeri \n sono sulla \n stessa riga, \n il font e' OK \n ..." ; prima_volta="NO"
											[ "${prima_volta}" = "SI" ] && [ "${l}" = "EN" ] && message "Current \n font: \n\n \"$(echo "${font_to_confirm}" | tr '[[:punct:]]' '?' | tr -s '?' | tr '?' '\n' )\" \n ...\n\n In next window, \n if all numbers \n are on the same row, \n font is OK \n ..." ; prima_volta="NO"
											#
											#Verifica font...
											verify_font "${font_to_confirm}"
											#
										elif [ "${scelta_dimensione_font}" = "${delimiter}" ]
											then
											continue 1
											#
										elif [ "${scelta_dimensione_font}" = "<-FATTO" -o "${scelta_dimensione_font}" = "<-DONE" ]
											then
											[ "${l}" = "IT" ] && ok_message "Per favore, \n seleziona \n \"salva il font\" \n ..."
											[ "${l}" = "EN" ] && ok_message "Please, \n select \n \"save font\" \n ..."
											break 1
											#
										fi #if [ "${scelta_dimensione_font}" = "Scegli la dimensione..." -o "${scelta_dimensione_font}" = "Choose size..." ]
										#
									done
									#
								fi #if [ "${font_selector}" = "Xdialog" ]
								#
							elif [ "${scelta_fnt}" = "Salva il font..." -o "${scelta_fnt}" = "Save font..." -o "${scelta_fnt}" = "Salva il font \"${font_to_confirm}\"..." -o "${scelta_fnt}" = "Save font \"${font_to_confirm}\"..." ]
								then
								font="-${font_to_confirm}"
								wait_seconds 2
								break 1
								#
							elif [ "${scelta_fnt}" = "Torna al font precedente..." -o "${scelta_fnt}" = "Back to prior font..." ]
								then
								font_to_confirm="${old_font}"
								[ "${l}" = "IT" ] && message "Font \n attuale: \n\n \"$(echo "${font_to_confirm}" | tr '[[:punct:]]' '?' | tr -s '?' | tr '?' '\n' )\" \n ... \n\n Nella finestra \n successiva, \n se tutti i numeri \n sono sulla \n stessa riga, \n il font e' OK \n ..."
								[ "${l}" = "EN" ] && message "Current \n font: \n\n \"$(echo "${font_to_confirm}" | tr '[[:punct:]]' '?' | tr -s '?' | tr '?' '\n' )\" \n ...\n\n In next window, \n if all numbers \n are on the same row, \n font is OK \n ..."
								#
								#Verifica font...
								verify_font "${font_to_confirm}"
								#
								continue 1
								#
							elif [ "${scelta_fnt}" = "Torna al font di default..." -o "${scelta_fnt}" = "Back to default font..." ]
								then
								font_to_confirm="$(echo "${default_font}" | gsed s\#'^-'#''# )"
								[ "${l}" = "IT" ] && message "Font \n attuale: \n\n \"$(echo "${font_to_confirm}" | tr '[[:punct:]]' '?' | tr -s '?' | tr '?' '\n' )\" \n ... \n\n Nella finestra \n successiva, \n se tutti i numeri \n sono sulla \n stessa riga, \n il font e' OK \n ..."
								[ "${l}" = "EN" ] && message "Current \n font: \n\n \"$(echo "${font_to_confirm}" | tr '[[:punct:]]' '?' | tr -s '?' | tr '?' '\n' )\" \n ...\n\n In next window, \n if all numbers \n are on the same row, \n font is OK \n ..."
								#
								#Verifica font...
								verify_font "${font_to_confirm}"
								#
								continue 1
								#
							elif [ "${scelta_fnt}" = "${delimiter}" ]
								then
								continue 1
								#
							elif [ "${scelta_fnt}" = "<-TORNA INDIETRO" -o "${scelta_fnt}" = "<-BACK" ]
								then
								#
								break 1
								#
							else
								ciao
							fi #if [ "${scelta_fnt}" = "Seleziona un nuovo font..." -o "${scelta_fnt}" = "Select a new font..." ]
						done
						#
					elif [ ${risposta} -eq 1 ]
						then
						:
					else
						ciao
					fi
					#
					continue 1
					#
				elif [ "${scelta_Estetica}" = "Colore sfondo..." -o "${scelta_Estetica}" = "Background color..." ]
					then
					# 7) background
					if [ "${l}" = "IT" ]
						then
						question "Colore \n di sfondo \n attuale: \n\n \"${background}\" \n\n\n Vuoi \n cambiarlo?"
						risposta=${?}
					elif [ "${l}" = "EN" ]
						then
						question "Current \n background \n color: \n\n \"${background}\" \n\n\n Do you want \n change it?"
						risposta=${?}
					fi
					if [ ${risposta} -eq 0 ]
						then
						converti()
							{
							echo -n '#'
							for arg in ${@}
								do
								exa=$(echo "obase=16; ${arg}" | bc )
								if [ ${#exa} -eq 1 ]
									then
									exa="0${exa}"
								fi
								echo -n "${exa}"
							done
							echo 
							}
						#
						######################################
						color_selector="self-made"
						if [ ${#esistenza_Xdialog} -gt 0 ]
							then
							Xdialog_presente_e_funzionante="$(Xdialog --version 2>&1 )"
							if [ $(echo -n "${Xdialog_presente_e_funzionante}" | grep "Do you run under X11 with GTK.*installed ?" | wc -c ) -eq 0 ]
								then
								color_selector="Xdialog"
							fi
						fi
						[ "${mode}" = "kdialog" ] && color_selector="kdialog"
						#
						: color_selector
						########################################
						#
						if [ "${color_selector}" = "Xdialog" ]
							then
							converti $(command Xdialog --stdout --rc-file "${dir_Karaoke}/${gtkrc_file}" --colorsel "Select color..." ${dimensione_finestra} ) \
							1> "${dir_tmp}/${file_tmp}"
							#
						elif [ "${color_selector}" = "kdialog" ]
							then
							command kdialog ${dimensione_finestra} --getcolor | \
							tr '[[:lower:]]' '[[:upper:]]' 1> "${dir_tmp}/${file_tmp}"
							#
						else
							menu "black" "red" "green" "yellow" "blue" "magenta" "cyan" "white"
							#
						fi
						background="$(0< "${dir_tmp}/${file_tmp}" )" ; [ ${#background} -eq 0 ] && continue 2
						wait_seconds 2
						break 1
						#
					elif [ ${risposta} -eq 1 ]
						then
						:
					else
						ciao
					fi
					#
					continue 1
					#
				elif [ "${scelta_Estetica}" = "Colore testo gia' cantato..." -o "${scelta_Estetica}" = "Lyric color (already sung)..." ]
					then
					# 8) foreground_1
					if [ "${l}" = "IT" ]
						then
						question "Colore \n del testo \n attuale \n (gia' cantato): \n\n \"${foreground_1}\" \n\n\n Vuoi \n cambiarlo?"
						risposta=${?}
					elif [ "${l}" = "EN" ]
						then
						question "Current \n lyric color \n (already sung): \n\n \"${foreground_1}\" \n\n\n Do you want \n change it?"
						risposta=${?}
					fi
					#
					if [ ${risposta} -eq 0 ]
						then
						menu "black" "red" "green" "yellow" "blue" "magenta" "cyan" "white"
						foreground_1="$(0< "${dir_tmp}/${file_tmp}" )" ; [ ${#foreground_1} -eq 0 ] && continue 2
						wait_seconds 2
						break 1
						#
					elif [ ${risposta} -eq 1 ]
						then
						:
					else
						ciao
					fi
					#
					continue 1
					#
				elif [ "${scelta_Estetica}" = "Colore testo da cantare..." -o "${scelta_Estetica}" = "Lyric color (to sing)..." ]
					then
					# 9) foreground_2
					if [ "${l}" = "IT" ]
						then
						question "Colore \n del testo \n attuale \n (da cantare): \n\n \"${foreground_2}\" \n\n\n Vuoi \n cambiarlo?"
						risposta=${?}
					elif [ "${l}" = "EN" ]
						then
						question "Current \n lyric color \n (to sing): \n\n \"${foreground_2}\" \n\n\n Do you want \n change it?"
						risposta=${?}
					fi
					#
					if [ ${risposta} -eq 0 ]
						then
						eval $(echo "menu black red green yellow blue magenta cyan white" | gsed s\#"${foreground_1}"#''# )
						foreground_2="$(0< "${dir_tmp}/${file_tmp}" )" ; [ ${#foreground_2} -eq 0 ] && continue 2
						wait_seconds 2
						break 1
						#
					elif [ ${risposta} -eq 1 ]
						then
						:
					else
						ciao
					fi
					#
					continue 1
					#
				elif [ "${scelta_Estetica}" = "${delimiter}" ]
					then
					#
					continue 1
					#
				elif [ "${scelta_Estetica}" = "<-TORNA INDIETRO" -o "${scelta_Estetica}" = "<-BACK" ]
					then
					#
					break 1
					#
				else
					ciao
				fi
				#
			done
			#
			continue 1
			#
		elif [ "${scelta}" = "Suono..." -o "${scelta}" = "Sound..." ]
			then
			while :
				do
				[ "${l}" = "IT" ] && menu \
							"Font sonoro..." \
							"${delimiter}" \
							"<-TORNA INDIETRO" 
				[ "${l}" = "EN" ] && menu \
							"Soundfont..." \
							"${delimiter}" \
							"<-BACK" 
				scelta_Suono="$(0< "${dir_tmp}/${file_tmp}" )" ; [ ${#scelta_Suono} -eq 0 ] && break 2
				#
				if [ "${scelta_Suono}" = "Font sonoro..." -o "${scelta_Suono}" = "Soundfont..." ]
					then
					# 10) soundfont
					if [ "${l}" = "IT" ]
						then
						question "Font sonoro \n attuale: \n\n \"$(basename "${soundfont}" )\" \n\n\n Vuoi \n cambiarlo? \n ( P.es. \n i soundfonts \n hanno \n l'estensione \".sf2\" )"
						risposta=${?}
					elif [ "${l}" = "EN" ]
						then
						question "Current \n soundfont: \n\n \"$(basename "${soundfont}" )\" \n\n\n Do you want \n change it? \n ( E.g. \n soundfonts \n have \".sf2\" \n extension )"
						risposta=${?}
					fi
					if [ ${risposta} -eq 0 ]
						then
						while :
							do
							fselect
							soundfont="$(0< "${dir_tmp}/${file_tmp}" )" ; [ ${#soundfont} -eq 0 ] && continue 3
							#
							if [ ! -f "${soundfont}" ]
								then
								[ "${l}" = "IT" ] && alert_message "$(basename "${soundfont}" ) \n non e' \n un file..."
								[ "${l}" = "EN" ] && alert_message "$(basename "${soundfont}" ) \n it's not \n a file..."
								#
								continue 1
								#
							else
								#
								wait_seconds 2
								break 1
								#
							fi
							#
						done
					elif [ ${risposta} -eq 1 ]
						then
						:
					else
						ciao
					fi
					#
					continue 1
					#
				elif [ "${scelta_Suono}" = "${delimiter}" ]
					then
					#
					continue 1
					#
				elif [ "${scelta_Suono}" = "<-TORNA INDIETRO" -o "${scelta_Suono}" = "<-BACK" ]
					then
					#
					break 1
					#
				else
					ciao
				fi
				#
			done
			#
			continue 1
			#
		elif [ "${scelta}" = "Avanzato..." -o "${scelta}" = "Advanced..." ]
			then
			while :
				do
				[ "${l}" = "IT" ] && menu \
							"Estrazione testo canzone..." \
							"Rapporto tolleranza agli errori/precisione..." \
							"${delimiter}" \
							"<-TORNA INDIETRO" 
				[ "${l}" = "EN" ] && menu \
							"Lyric extraction..." \
							"Error tolerance/precision ratio..." \
							"${delimiter}" \
							"<-BACK" 
				scelta_Avanzato="$(0< "${dir_tmp}/${file_tmp}" )" ; [ ${#scelta_Avanzato} -eq 0 ] && break 2
				#
				if [ "${scelta_Avanzato}" = "Estrazione testo canzone..." -o "${scelta_Avanzato}" = "Lyric extraction..." ]
					then
					# 11) extract_way
					if [ "${l}" = "IT" ]
						then
						question "Attuale \n valore \n \"extract_way\": \n\n \"${extract_way}\" \n\n\n Vuoi \n cambiare \n il modo \n con cui \n e' estratto \n\n il testo \n dal midi?"
						risposta=${?}
					elif [ "${l}" = "EN" ]
						then
						question "Current \n \"extract_way\" \n value: \n\n \"${extract_way}\" \n\n\n Do you want \n change method \n lyric is extracted \n from midi?"
						risposta=${?}
					fi
					if [ ${risposta} -eq 0 ]
						then
						[ "${l}" = "IT" ] && menu "internal" "through__midi_text24_pl (serve midi_text24.pl)" "through__pykar (serve pykar)"
						[ "${l}" = "EN" ] && menu "internal" "through__midi_text24_pl (you need midi_text24.pl)" "through__pykar (you need pykar)"
						extract_way="$(cat "${dir_tmp}/${file_tmp}" | cut -d '(' -f 1 | cut -d ' ' -f 1 )" ; [ ${#extract_way} -eq 0 ] && break 2
						wait_seconds 2
						break 1
						#
					elif [ ${risposta} -eq 1 ]
						then
						:
					else
						ciao
					fi
					#
					continue 1
					#
				elif [ "${scelta_Avanzato}" = "Rapporto tolleranza agli errori/precisione..." -o "${scelta_Avanzato}" = "Error tolerance/precision ratio..." ]
					then
					# 12) error_correction_chars
					if [ "${l}" = "IT" ]
						then
						question "Attuale \n valore \n \"error_correction_chars\": \n\n \"${error_correction_chars}\" \n\n\n Vuoi \n cambiare \n il rapporto \n tra: \n tolleranza agli errori \n /precisione?"
						risposta=${?}
					elif [ "${l}" = "EN" ]
						then
						question "Current \n \"error_correction_chars\" \n value: \n\n \"${error_correction_chars}\" \n\n\n Do you want \n change \n error tolerance/precision \n ratio?"
						risposta=${?}
					fi
					if [ ${risposta} -eq 0 ]
						then
						[ "${l}" = "IT" ] && menu "0 (nessuna tolleranza/precisione perfetta)" "1 (tolleranza media/precisione media)" "2 (tolleranza alta/precisione bassa)"
						[ "${l}" = "EN" ] && menu "0 (no tolerance/perfect precision)" "1 (average tolerance/average precision)" "2 (high tolerance/low precision)"
						error_correction_chars="$(cat "${dir_tmp}/${file_tmp}" | cut -d '(' -f 1 | tr -dc '[[:digit:]]' )" ; [ ${#error_correction_chars} -eq 0 ] && continue 2
						wait_seconds 2
						break 1
						#
					elif [ ${risposta} -eq 1 ]
						then
						:
					else
						ciao
					fi
					#
					continue 1
					#
				elif [ "${scelta_Avanzato}" = "${delimiter}" ]
					then
					#
					continue 1
					#
				elif [ "${scelta_Avanzato}" = "<-TORNA INDIETRO" -o "${scelta_Avanzato}" = "<-BACK" ]
					then
					#
					break 1
					#
				else
					ciao
				fi
				#
			done
			#
			continue 1
			#
		elif [ "${scelta}" = "Varie..." -o "${scelta}" = "Misc..." ]
			then
			while :
				do
				[ "${l}" = "IT" ] && menu \
							"Browser per il fullscreen..." \
							"Lingua delle canzoni..." \
							"Codifica dei caratteri..." \
							"Delimitatore dei campi menu..." \
							"${delimiter}" \
							"<-TORNA INDIETRO" 
				[ "${l}" = "EN" ] && menu \
							"Fullscreen browser..." \
							"Song language..." \
							"Character encoding..." \
							"Menu field delimiter..."
							"${delimiter}" \
							"<-BACK" 
				scelta_Varie="$(0< "${dir_tmp}/${file_tmp}" )" ; [ ${#scelta_Varie} -eq 0 ] && break 2
				#
				if [ "${scelta_Varie}" = "Browser per il fullscreen..." -o "${scelta_Varie}" = "Fullscreen browser..." ]
					then
					# 13) bkbrowser
					if [ "${l}" = "IT" ]
						then
						question "Attuale \n valore \n \"bkbrowser\": \n\n \"${bkbrowser}\" \n\n\n Vuoi \n cambiarlo?"
						risposta=${?}
					elif [ "${l}" = "EN" ]
						then
						question "Current \n \"bkbrowser\" \n value: \n\n \"${bkbrowser}\" \n\n\n Do you want \n change it?"
						risposta=${?}
					fi
					if [ ${risposta} -eq 0 ]
						then
						if [ ${#BROWSER} -gt 0 ]
							then
							menu "embedded" "${BROWSER}" "[CUSTOM]"
						else
							menu "embedded" "[CUSTOM]"
						fi
						browser_choice="$(cat "${dir_tmp}/${file_tmp}" )" ; [ ${browser_choice} -eq 0 ] && continue 2
						if [ "${browser_choice}" = "[CUSTOM]" ]
							then
							message "Please, select a browser \n\n (Tip: download and select \"Midori\"... )"
							fselect "/usr/bin"
							browser_choice="$(cat "${dir_tmp}/${file_tmp}" )" ; [ ${#browser_choice} -eq 0 ] && continue 2
						fi
						#
						##
						#
						if [ "${browser_choice}" = "embedded" ]
							then
							#
							[ "${l}" = "IT" ] && alert_message "Per favore, nota che \n il browser \"embedded\" \n ha bisogno di Python e Webkit \n per funzionare..."
							[ "${l}" = "EN" ] && alert_message "Please, note that \n \"embedded\" browser \n needs Python and Webkit \n to work..."
							#
							bkbrowser="${browser_choice}"
							#
						else
							if [ -x "${browser_choice}" ]
								then
								bkbrowser="${browser_choice}"
								#
							else
								browser_to_check="$(type -P "${browser_choice}" )"
								if [ -x "${browser_to_check}" ]
									then
									bkbrowser="${browser_to_check}"
								else
									[ "${l}" = "IT" ] && alert_message "Il file selezionato non e' eseguibile"
									[ "${l}" = "EN" ] && alert_message "Selected file is not executable"
								fi #if [ -x "${browser_to_check}" ]
								#
							fi #if [ -x "${browser_choice}" ]
							#
						fi #if [ "${browser_choice}" = "embedded" ]
						#
						##
						#						
						wait_seconds 2
						break 1
						#
					elif [ ${risposta} -eq 1 ]
						then
						:
					else
						ciao
					fi
					#
					continue 1
					#
				elif [ "${scelta_Varie}" = "Lingua delle canzoni..." -o "${scelta_Varie}" = "Song language..." ]
					then
					# 14) LANG
					if [ "${l}" = "IT" ]
						then
						question "Attuale \n valore \n \"LANG\": \n\n \"${LANG}\" \n\n\n Vuoi \n cambiarlo?"
						risposta=${?}
					elif [ "${l}" = "EN" ]
						then
						question "Current \n \"LANG\" \n value: \n\n \"${LANG}\" \n\n\n Do you want \n change it?"
						risposta=${?}
					fi
					if [ ${risposta} -eq 0 ]
						then
						menu $(locale -a | grep -i "\.UTF.\?8" )
						LANG_pre="$(0< "${dir_tmp}/${file_tmp}" )" ; [ ${#LANG_pre} -eq 0 ] && continue 2
						#
						LANG="$(echo -n "${LANG_pre}" | gsed -n s\#'\(.*\)\..*'#'\1'#p ).UTF-8"
						wait_seconds 2
						break 1
						#
					elif [ ${risposta} -eq 1 ]
						then
						:
					else
						ciao
					fi
					#
					continue 1
					#
				elif [ "${scelta_Varie}" = "Codifica dei caratteri..." -o "${scelta_Varie}" = "Character encoding..." ]
					then
					# 15) char_encoding
					if [ "${l}" = "IT" ]
						then
						question "Attuale \n valore \n \"char_encoding\": \n\n \"${char_encoding}\" \n\n\n Vuoi \n cambiarlo?"
						risposta=${?}
					elif [ "${l}" = "EN" ]
						then
						question "Current \n \"char_encoding\" \n value: \n\n \"${char_encoding}\" \n\n\n Do you want \n change it?"
						risposta=${?}
					fi
					if [ ${risposta} -eq 0 ]
						then
						menu $(iconv -l | gsed s\#'//'#''# )
						char_encoding_array=( $(0< "${dir_tmp}/${file_tmp}" ) )
						char_encoding="${char_encoding_array[0]}" ; [ ${#char_encoding} -eq 0 ] && continue 2
						wait_seconds 2
						break 1
						#
					elif [ ${risposta} -eq 1 ]
						then
						:
					else
						ciao
					fi
					#
					continue 1
					#
				elif [ "${scelta_Varie}" = "Delimitatore dei campi menu..." -o "${scelta_Varie}" = "Menu field delimiter..." ]
					then
					# 16) delimiter
					if [ "${l}" = "IT" ]
						then
						question "Attuale \n valore \n \"delimiter\": \n\n \"${delimiter}\" \n\n\n Vuoi \n cambiarlo?"
						risposta=${?}
					elif [ "${l}" = "EN" ]
						then
						question "Current \n \"delimiter\" \n value: \n\n \"${delimiter}\" \n\n\n Do you want \n change it?"
						risposta=${?}
					fi
					if [ ${risposta} -eq 0 ]
						then
						menu "______________________________________" " -------------------------------------" " " "..." "[CUSTOM]"
						delimiter="$(cat "${dir_tmp}/${file_tmp}" )" ; [ ${delimiter} -eq 0 ] && continue 2
						if [ "${delimiter}" = "[CUSTOM]" ]
							then
							input 1 "______________________________________"
							delimiter="$(cat "${dir_tmp}/${file_tmp}" )" ; [ ${delimiter} -eq 0 ] && continue 2
						fi
						wait_seconds 2
						break 1
						#
					elif [ ${risposta} -eq 1 ]
						then
						:
					else
						ciao
					fi
					#
					continue 1
					#
				elif [ "${scelta_Varie}" = "${delimiter}" ]
					then
					#
					continue 1
					#
				elif [ "${scelta_Varie}" = "<-TORNA INDIETRO" -o "${scelta_Varie}" = "<-BACK" ]
					then
					#
					break 1
					#
				else
					ciao
				fi
				#
			done
			#
			continue 1
			#
		elif [ "${scelta}" = "${delimiter}" ]
			then
			#
			continue 1
			#
		elif [ "${scelta}" = "TORNA alla configurazione di default..." -o "${scelta}" = "GO BACK to default configuration..." ]
			then
			if [ "${l}" = "IT" ]
				then
				question "Vuoi \n davvero \n tornare \n alla configurazione \n di default ?"
				risposta=${?}
			elif [ "${l}" = "EN" ]
				then
				question "Really \n do you want \n come back \n to default \n configuration ?"
				risposta=${?}
			fi
			if [ ${risposta} -eq 0 ]
				then
				crea_rc_default 1> "${dir_Karaoke}/${rc_file}"
				source "${dir_Karaoke}/${rc_file}"
				#
				: soundfont_string
				#
				break 1
				#
			elif [ ${risposta} -eq 1 ]
				then
				#
				continue 1
				#
			else
				ciao
			fi
		elif [ "${scelta}" = "<-FATTO" -o "${scelta}" = "<-DONE" ]
			then
			#
			scrivi="SI"
			break 1
			#
		else
			ciao
		fi
		#
	done
	#
	# configuration: END 
	#
	####
	#
	[ "${scrivi}" = "SI" ] && \
	cat <<-EOB2 1> "${dir_tmp}/${file_tmp}"
	export bkbrowser="${bkbrowser}"
	export use_gtk="${use_gtk}"
	export use_gsw="${use_gsw}"
	export use_buc="${use_buc}"
	export supermode="${supermode}"
	export karaoke_window="${karaoke_window}"
	export levels_window="${levels_window}"
	export channels_window="${channels_window}"
	export spectrogram_window="${spectrogram_window}"
	export rows=${rows}
	export columns=${columns}
	export font="${font}"
	export background="${background}"
	export foreground_1="${foreground_1}"
	export foreground_2="${foreground_2}"
	export soundfont="${soundfont}"
	export extract_way="${extract_way}"
	export error_correction_chars=${error_correction_chars}
	export LANG="${LANG}"
	export char_encoding="${char_encoding}"
	export delimiter="${delimiter}"
	export predefvolume=${default_Volume}
	export predefpitch=${default_Pitch}
	export predefspeed=${default_Tempo}
	export font_family="${font_family}"
	export show_debug=0
	export show_tabs=0
EOB2
	#
	#
	#
	IFS=$'\n' ; array_voci_configurazione=( $(0< "${dir_tmp}/${file_tmp}" ) ) ; IFS=$' \t\n'
	if [ ${#array_voci_configurazione[@]} -lt 19 ]
		then
		:
	else
		cp -f "${dir_tmp}/${file_tmp}" "${dir_Karaoke}/${rc_file}"
		source "${dir_Karaoke}/${rc_file}"
	fi
	#
	if [ ${#soundfont} -gt 0 ]
		then
		export soundfont_string="-x\"soundfont ${soundfont}\""
	else
		export soundfont_string=""
	fi
	}
#
#
#
display_levels_pre()
	{
	#
	: min_Volume
	: default_Volume
	array_valori_Volume__percent=( $(percentualizza ${min_Volume} ${default_Volume} ${max_Volume} ) )
	default_Volume__percent="${array_valori_Volume__percent[1]}"
	: default_Volume__percent
	: max_Volume
	: volume
	#
	: min_Pitch
	: default_Pitch
	array_valori_Pitch__percent=( $(percentualizza ${min_Pitch} ${default_Pitch} ${max_Pitch} ) )
	default_Pitch__percent="${array_valori_Pitch__percent[1]}"
	: default_Pitch__percent
	: max_Pitch
	: pitch
	#
	: min_Tempo
	: default_Tempo
	array_valori_Tempo__percent=( $(percentualizza ${min_Tempo} ${default_Tempo} ${max_Tempo} ) )
	default_Tempo__percent="${array_valori_Tempo__percent[1]}"
	: default_Tempo__percent
	: max_Tempo
	: tempo
	#
	funct_volume="${volume}"
	funct_pitch="${pitch}" 
	funct_tempo="${tempo}"
	#
	while :
		do
		#
		array_valori_Volume__percent=( $(percentualizza ${min_Volume} ${funct_volume} ${max_Volume} ) )
		array_valori_Tono__percent=( $(percentualizza ${min_Pitch} ${funct_pitch} ${max_Pitch} ) )
		array_valori_Tempo__percent=( $(percentualizza ${min_Tempo} ${funct_tempo} ${max_Tempo} ) )
		[ "${l}" = "IT" ] && menu \
				"AVVIA LA CANZONE->" \
				"<-(DEFAULT: ${default_Volume__percent}%,${default_Pitch__percent}%,${default_Tempo__percent}%)" \
				"${delimiter}" \
				"( ${array_valori_Volume__percent[1]}% ) : Volume ..." \
				"( ${array_valori_Tono__percent[1]}% ) : Tono (${funct_pitch}) ..." \
				"( ${array_valori_Tempo__percent[1]}% ) : Tempo ..." \
				"${delimiter}" \
				"<-TORNA INDIETRO"
		#
		[ "${l}" = "EN" ] && menu \
				"START SONG->" \
				"<-(DEFAULT: ${default_Volume__percent}%,${default_Pitch__percent}%,${default_Tempo__percent}%)" \
				"${delimiter}" \
				"( ${array_valori_Volume__percent[1]}% ) : Volume ..." \
				"( ${array_valori_Tono__percent[1]}% ) : Pitch (${funct_pitch}) ..." \
				"( ${array_valori_Tempo__percent[1]}% ) : Tempo ..." \
				"${delimiter}" \
				"<-BACK"
		#
		scelta_levels="$(0< "${dir_tmp}/${file_tmp}" )" ; [ ${#scelta_levels} -eq 0 ] && break
		if [ "${scelta_levels}" = "AVVIA LA CANZONE->" -o "${scelta_levels}" = "START SONG->" ]
			then
			echo "${funct_volume} ${funct_pitch} ${funct_tempo}"
			echo "unchecked"
			break
			#
		elif [ "${scelta_levels}" = "<-(DEFAULT: ${default_Volume__percent}%,${default_Pitch__percent}%,${default_Tempo__percent}%)" ]
			then
			#echo "${funct_volume} ${funct_pitch} ${funct_tempo}"
			echo "checked"
			break
			#
		elif [ "${scelta_levels}" = "( ${array_valori_Volume__percent[1]}% ) : Volume ..." ]
			then
			#
			[ "${l}" = "IT" ] && adjust $([ "${mode}" = "Xdialog" ] && echo -en "-h 550 " ) "Per favore, \n setta il \"Volume\" \n ( predef.: ${default_Volume__percent}% ) \n ..." ${min_Volume} ${funct_volume} ${max_Volume}
			[ "${l}" = "EN" ] && adjust $([ "${mode}" = "Xdialog" ] && echo -en "-h 550 " ) "Please, \n adjust \"Volume\" \n ( default.: ${default_Volume__percent}% ) \n ..." ${min_Volume} ${funct_volume} ${max_Volume}
			funct_volume="$(0< "${dir_tmp}/${file_tmp}" )"
			continue
			#
		elif [ "${scelta_levels}" = "( ${array_valori_Tono__percent[1]}% ) : Tono (${funct_pitch}) ..." -o "${scelta_levels}" = "( ${array_valori_Tono__percent[1]}% ) : Pitch (${funct_pitch}) ..." ]
			then
			[ "${l}" = "IT" ] && adjust $([ "${mode}" = "Xdialog" ] && echo -en "-h 550 " ) "Per favore, \n setta il \"Tono\" \n ( predef.: ${default_Pitch__percent}% ) \n ..." ${min_Pitch} ${funct_pitch} ${max_Pitch}
			[ "${l}" = "EN" ] && adjust $([ "${mode}" = "Xdialog" ] && echo -en "-h 550 " ) "Please, \n adjust \"Pitch\" \n ( default.: ${default_Pitch__percent}% ) \n ..." ${min_Pitch} ${funct_pitch} ${max_Pitch}
			funct_pitch="$(0< "${dir_tmp}/${file_tmp}" )"
			continue
			#
		elif [ "${scelta_levels}" = "( ${array_valori_Tempo__percent[1]}% ) : Tempo ..." ]
			then
			[ "${l}" = "IT" ] && adjust $([ "${mode}" = "Xdialog" ] && echo -en "-h 550 " ) "Per favore, \n setta il \"Tempo\" \n ( predef.: ${default_Tempo__percent}% ) \n ..." ${min_Tempo} ${funct_tempo} ${max_Tempo}
			[ "${l}" = "EN" ] && adjust $([ "${mode}" = "Xdialog" ] && echo -en "-h 550 " ) "Please, \n adjust \"Tempo\" \n ( default.: ${default_Tempo__percent}% ) \n ..." ${min_Tempo} ${funct_tempo} ${max_Tempo}
			funct_tempo="$(0< "${dir_tmp}/${file_tmp}" )"
			continue
			#
		elif [ "${scelta_levels}" = "${delimiter}" ]
			then
			continue
			#
		elif [ "${scelta_levels}" = "<-TORNA INDIETRO" -o "${scelta_levels}" = "<-BACK" ]
			then
			break
			#
		fi
		#
	done
	#
	}
#
#
#
display_levels()
	{
	#
	: min_Volume
	: default_Volume
	array_valori_Volume__percent=( $(percentualizza ${min_Volume} ${default_Volume} ${max_Volume} ) )
	default_Volume__percent="${array_valori_Volume__percent[1]}"
	: default_Volume__percent
	: max_Volume
	: volume
	#
	: min_Pitch
	: default_Pitch
	array_valori_Pitch__percent=( $(percentualizza ${min_Pitch} ${default_Pitch} ${max_Pitch} ) )
	default_Pitch__percent="${array_valori_Pitch__percent[1]}"
	: default_Pitch__percent
	: max_Pitch
	: pitch
	#
	: min_Tempo
	: default_Tempo
	array_valori_Tempo__percent=( $(percentualizza ${min_Tempo} ${default_Tempo} ${max_Tempo} ) )
	default_Tempo__percent="${array_valori_Tempo__percent[1]}"
	: default_Tempo__percent
	: max_Tempo
	: tempo
	#
	funct_volume="${volume}"
	funct_pitch="${pitch}" 
	funct_tempo="${tempo}"
	#
	while :
		do
		#
		array_valori_Volume__percent=( $(percentualizza ${min_Volume} ${funct_volume} ${max_Volume} ) )
		array_valori_Tono__percent=( $(percentualizza ${min_Pitch} ${funct_pitch} ${max_Pitch} ) )
		array_valori_Tempo__percent=( $(percentualizza ${min_Tempo} ${funct_tempo} ${max_Tempo} ) )
		[ "${l}" = "IT" ] && menu \
				"RIAVVIA LA CANZONE->" \
				"RIAVVIA LA CANZONE<-(DEFAULT: ${default_Volume__percent}%,${default_Pitch__percent}%,${default_Tempo__percent}%)" \
				"${delimiter}" \
				"( ${array_valori_Volume__percent[1]}% ) : Volume ..." \
				"( ${array_valori_Tono__percent[1]}% ) : Tono (${funct_pitch}) ..." \
				"( ${array_valori_Tempo__percent[1]}% ) : Tempo ..." \
				"${delimiter}" \
				"<-TORNA INDIETRO"
		#
		[ "${l}" = "EN" ] && menu \
				"RESTART SONG->" \
				"RESTART SONG<-(DEFAULT: ${default_Volume__percent}%,${default_Pitch__percent}%,${default_Tempo__percent}%)" \
				"${delimiter}" \
				"( ${array_valori_Volume__percent[1]}% ) : Volume ..." \
				"( ${array_valori_Tono__percent[1]}% ) : Pitch (${funct_pitch}) ..." \
				"( ${array_valori_Tempo__percent[1]}% ) : Tempo ..." \
				"${delimiter}" \
				"<-BACK"
		#
		scelta_levels="$(0< "${dir_tmp}/${file_tmp}" )" ; [ ${#scelta_levels} -eq 0 ] && break
		if [ "${scelta_levels}" = "RIAVVIA LA CANZONE->" -o "${scelta_levels}" = "RESTART SONG->" ]
			then
			echo "${funct_volume} ${funct_pitch} ${funct_tempo}"
			echo "unchecked"
			break
			#
		elif [ "${scelta_levels}" = "RIAVVIA LA CANZONE<-(DEFAULT: ${default_Volume__percent}%,${default_Pitch__percent}%,${default_Tempo__percent}%)" -o "${scelta_levels}" = "RESTART SONG<-(DEFAULT: ${default_Volume__percent}%,${default_Pitch__percent}%,${default_Tempo__percent}%)" ]
			then
			#echo "${funct_volume} ${funct_pitch} ${funct_tempo}"
			echo "checked"
			break
			#
		elif [ "${scelta_levels}" = "( ${array_valori_Volume__percent[1]}% ) : Volume ..." ]
			then
			#
			[ "${l}" = "IT" ] && adjust $([ "${mode}" = "Xdialog" ] && echo -en "-h 550 " ) "Per favore, \n setta il \"Volume\" \n ( predef.: ${default_Volume__percent}% ) \n ..." ${min_Volume} ${funct_volume} ${max_Volume}
			[ "${l}" = "EN" ] && adjust $([ "${mode}" = "Xdialog" ] && echo -en "-h 550 " ) "Please, \n adjust \"Volume\" \n ( default.: ${default_Volume__percent}% ) \n ..." ${min_Volume} ${funct_volume} ${max_Volume}
			funct_volume="$(0< "${dir_tmp}/${file_tmp}" )"
			continue
			#
		elif [ "${scelta_levels}" = "( ${array_valori_Tono__percent[1]}% ) : Tono (${funct_pitch}) ..." -o "${scelta_levels}" = "( ${array_valori_Tono__percent[1]}% ) : Pitch (${funct_pitch}) ..." ]
			then
			[ "${l}" = "IT" ] && adjust $([ "${mode}" = "Xdialog" ] && echo -en "-h 550 " ) "Per favore, \n setta il \"Tono\" \n ( predef.: ${default_Pitch__percent}% ) \n ..." ${min_Pitch} ${funct_pitch} ${max_Pitch}
			[ "${l}" = "EN" ] && adjust $([ "${mode}" = "Xdialog" ] && echo -en "-h 550 " ) "Please, \n adjust \"Pitch\" \n ( default.: ${default_Pitch__percent}% ) \n ..." ${min_Pitch} ${funct_pitch} ${max_Pitch}
			funct_pitch="$(0< "${dir_tmp}/${file_tmp}" )"
			continue
			#
		elif [ "${scelta_levels}" = "( ${array_valori_Tempo__percent[1]}% ) : Tempo ..." ]
			then
			[ "${l}" = "IT" ] && adjust $([ "${mode}" = "Xdialog" ] && echo -en "-h 550 " ) "Per favore, \n setta il \"Tempo\" \n ( predef.: ${default_Tempo__percent}% ) \n ..." ${min_Tempo} ${funct_tempo} ${max_Tempo}
			[ "${l}" = "EN" ] && adjust $([ "${mode}" = "Xdialog" ] && echo -en "-h 550 " ) "Please, \n adjust \"Tempo\" \n ( default.: ${default_Tempo__percent}% ) \n ..." ${min_Tempo} ${funct_tempo} ${max_Tempo}
			funct_tempo="$(0< "${dir_tmp}/${file_tmp}" )"
			continue
			#
		elif [ "${scelta_levels}" = "${delimiter}" ]
			then
			continue
			#
		elif [ "${scelta_levels}" = "<-TORNA INDIETRO" -o "${scelta_levels}" = "<-BACK" ]
			then
			break
			#
		fi
		#
	done
	#
	}
#
#
#
display_channels()
	{
	: muted_channels
	if [ "${muted_channels}" = "NONE" ]
		then
		init_channels=( $(for (( i=1 ; i<=32 ; i++ )) 
					do
					echo "off"
				done ) )
	elif [ "${muted_channels}" = "ALL" ]
		then
		init_channels=( $(for (( i=1 ; i<=32 ; i++ )) 
					do
					echo "on"
				done ) )
	else
		init_channels=( $(for (( i=1 ; i<=32 ; i++ )) 
					do
					echo "off"
				done ) )
		muted_channels_list="$(echo "${muted_channels}" | tr ',' '\n' )"
		for channel_to_mute in ${muted_channels_list}
			do
			c=$(( ${channel_to_mute} - 1 ))
			eval init_channels[${c}]=on
		done
	fi
	#
	eval list -w 415 -h 795 $(if [ "${muted_channels}" = "ALL" ]
					then
					echo -n "-\"Tutti i canali : clicca per TOGLIERE il silenzio\" "
				else
					echo -n "-\"Tutti i canali : clicca per silenziarli tutti\" "
				fi ) $(for (( i=0,index=1 ; index <= 32 ; i++,index++ ))
						do
						echo -n "$(if [ "${init_channels[${i}]}" = "on" ]
								then
								echo -n "+"
							elif [ "${init_channels[${i}]}" = "off" ]
								then
								echo -n "-"
							fi )"
						echo -n "$(if [ "${l}" = "IT" ]
								then
								echo "\"Canale ${index}: clicca per silenziare\" "
							elif [ "${l}" = "EN" ]
								then
								echo "\"Channel ${index}: check to mute\" "
							fi )"
					done )
	#
	}
#
#
#
go_bk__levels()
	{
	#
	: default_Volume
	: default_Pitch
	: default_Tempo
	#
	continua="SI"
	while [ "${continua}" = "SI" ]
		do
		#
		go_bk & 
		pid__go_bk=${!}
		#
		levels_pre="$(display_levels )" ; [ ${#levels_pre} -eq 0 ] && continua="NO" || continua="SI"
		clean_temp
		#
		[ "${karaoke_window}" = "true" ] && kill ${pid__go_bk} || killall timidity ; wait
		#
		#############################################
		# Ma con quali livelli? ...
		if [ ${#levels_pre} -eq 0 ]
			then
			export volume="${default_Volume}"
			export pitch="${default_Pitch}"
			export tempo="${default_Tempo}"
		else
			# _c'e'_ effettivam. qualcosa in "${levels_pre}" ...
			if [ $(echo "${levels_pre}" | grep "unchecked" | wc -c ) -gt 0 ]
				then
				# NON vuole tornare ai valori di default...
				levels=( $(echo "${levels_pre}" | head -n 1 ) ) #prendo solo la prima riga...
				if [ ${#levels} -eq 0 ]
					then
					# se non c'e' nulla, torno ai valori di default...
					export volume="${default_Volume}"
					export pitch="${default_Pitch}"
					export tempo="${default_Tempo}"
				else
					# altrimenti...
					export volume=${levels[0]}
					export pitch=${levels[1]}
					export tempo=${levels[2]}
				fi
			elif [ $(echo "${levels_pre}" | grep "checked" | wc -c ) -gt 0 ]
				then
				# VUOLE ritornare ai valori di default...
				export volume="${default_Volume}"
				export pitch="${default_Pitch}"
				export tempo="${default_Tempo}"
			fi
		fi
		#############################################
		#
	done
	}
#
#
#
go_bk__channels()
	{
	#
	continua="SI"
	while [ "${continua}" = "SI" ]
		do
		#
		go_bk &
		pid__go_bk=${!}
		#
		channels_pre="$(display_channels 
				click=${?}
				scelte="$(0< "${dir_tmp}/${file_tmp}" )"
				scelte_con_checked_unchecked="$(echo -e "${scelte}" ; \
							if [ $(echo -n "${scelte}" | grep "Tutti i canali" | wc -c ) -gt 0 ]
								then
								echo "checked"
							else
								echo "unchecked"
							fi )"
				echo "${scelte_con_checked_unchecked}" | cut -d ':' -f 1
				echo -e "\n\n\n${click}" 
				)"
		#
		#message "Questo e' il contenuto di \${channels_pre}:\n\"$(echo "${channels_pre}" )\"\n ..."
		#
		# "Channel 1
		#  Channel 2
		#  Channel 3
		#  ...
		#  ..."
		click="$(echo "${channels_pre}" | tail -n 1 )"
		if [ ${#click} -eq 0 ]
			then
			continua="NO"
		else
			if [ ${click} -eq 0 ]
				then
				#
				continua="SI"
				#
			elif [ ${click} -eq 1 ]
				then
				#
				continua="NO"
				#
			else
				#
				continua="NO"
				#
			fi
		fi
		clean_temp
		[ "${karaoke_window}" = "true" ] && kill ${pid__go_bk} || killall timidity
		wait
		#
		if [ ${#channels_pre} -eq 0 ]
			then
			export muted_channels="NONE"
		else
			if [ $(echo "${channels_pre}" | grep "unchecked" | wc -c ) -gt 0 ]
				then
				channels="$(echo "${channels_pre}" | grep -E "(Canale|Channel)" | cut -d ' ' -f 2 | tr '\n' ',' | gsed s\#',$'#'\n'# )"
				if [ ${#channels} -eq 0 ]
					then
					export muted_channels="NONE"
				else
					export muted_channels="${channels}"
				fi
			elif [ $(echo "${channels_pre}" | grep "checked" | wc -c ) -gt 0 ]
				then
				if [ "${muted_channels}" = "ALL" ]
					then
					export muted_channels="NONE"
				else
					export muted_channels="ALL"
				fi
			fi
		fi
		#
	done
	}
#
#
#
go_bk__levels_channels()
	{
	#
	continua="SI"
	prima_volta="SI"
	while [ "${continua}" = "SI" ]
		do
		#
		if [ "${prima_volta}" = "SI" ]
			then
			[ "${l}" = "IT" ] && message "Per favore, \n setta i livelli..."
			[ "${l}" = "EN" ] && message "Please, \n set levels..."
			#
			prima_volta="NO"
		fi
		#
		levels_pre="$(display_levels_pre )"
		#
		if [ ${#levels_pre} -eq 0 ]
			then
			clean_temp
			break 1
		else
			if [ $(echo "${levels_pre}" | grep "unchecked" | wc -c ) -gt 0 ]
				then
				levels=( $(echo "${levels_pre}" | head -n 1 ) )
				if [ $(echo -n "${levels}" | wc -c ) -eq 0 ]
					then
					export volume="${default_Volume}"
					export pitch="${default_Pitch}"
					export tempo="${default_Tempo}"
				else
					export volume=${levels[0]}
					export pitch=${levels[1]}
					export tempo=${levels[2]}
				fi
			elif [ $(echo "${levels_pre}" | grep "checked" | wc -c ) -gt 0 ]
				then
				export volume="${default_Volume}"
				export pitch="${default_Pitch}"
				export tempo="${default_Tempo}"
				continue 1
			fi
		fi
		#
		go_bk & 
		pid__go_bk=${!}
		#
		channels_pre="$(display_channels
				click=${?}
				scelte="$(0< "${dir_tmp}/${file_tmp}" )"
				scelte_con_checked_unchecked="$(echo -e "${scelte}" ; \
							if [ $(echo -n "${scelte}" | grep "Tutti i canali" | wc -c ) -gt 0 ]
								then
								echo "checked"
							else
								echo "unchecked"
							fi )"
				echo "${scelte_con_checked_unchecked}" | cut -d ':' -f 1
				echo -e "\n\n\n${click}" 
				)"
		click="$(echo "${channels_pre}" | tail -n 1 )"
		if [ ${#click} -eq 0 ]
			then
			continua="NO"
		else
			if [ ${click} -eq 0 ]
				then
				#
				continua="SI"
				#
			elif [ ${click} -eq 1 ]
				then
				#
				continua="NO"
				#
			else
				#
				continua="NO"
				#
			fi
		fi
		clean_temp
		[ "${karaoke_window}" = "true" ] && kill ${pid__go_bk} || killall timidity
		wait
		#
		if [ ${#channels_pre} -eq 0 ]
			then
			export muted_channels="NONE"
		else
			if [ $(echo "${channels_pre}" | grep "unchecked" | wc -c ) -gt 0 ]
				then
				channels="$(echo "${channels_pre}" | grep -E "(Canale|Channel)" | cut -d ' ' -f 2 | tr '\n' ',' | gsed s\#',$'#'\n'# )"
				if [ ${#channels} -eq 0 ]
					then
					export muted_channels="NONE"
				else
					export muted_channels="${channels}"
				fi
			elif [ $(echo "${channels_pre}" | grep "checked" | wc -c ) -gt 0 ]
				then
				if [ "${muted_channels}" = "ALL" ]
					then
					export muted_channels="NONE"
				else
					export muted_channels="ALL"
				fi
			fi
		fi
		#
	done
	}
#
#
#
ouputta_css()
	{
	cat <<'CSS_BLOCK'
@charset "UTF-8";
/* CSS Document */
	body{
                margin: 0px;
                padding: 0px;
                width: 100%;
                height: 100%;
		background-color:#333;
            	}
	.textBox{
                width: 100%;
                height: 100%;
			
                margin: 0 auto;
				
                text-align: center;
	
                /* background-color: red; */
                display: box;
                box-pack:center;
                box-align: center;
               
                /* display: -moz-box;
                -moz-box-pack:center;
                -moz-box-align: center; */
               
                display: -webkit-box;
                -webkit-box-pack:center;
                -webkit-box-align: center;
            	}	
	.color_old{
		color: #CCC;
		}
	.color_sing{
		color: #FF0;
		}	
	.color_next{
		color: #F30;
		}		
CSS_BLOCK
	}
#
#
#
ouputta_configjs()
	{
	cat <<'configjs_BLOCK'
// JavaScript Document
			$(document).ready( function(){
					   var H =$(window).height();
					   var W =$(window).width();
					  if (H > 771) { H = 770;}
					  
					   $('.textBox').textfill({explicitWidth: W, explicitHeight : H, maxFontPixels: -5});
					
				})		
configjs_BLOCK
	}
#
#
#
ouputta_jqueryminjs()
	{
	cat <<'jqueryminjs_BLOCK'
/*! jQuery v1.9.1 | (c) 2005, 2012 jQuery Foundation, Inc. | jquery.org/license
//@ sourceMappingURL=jquery.min.map
*/(function(e,t){var n,r,i=typeof t,o=e.document,a=e.location,s=e.jQuery,u=e.$,l={},c=[],p="1.9.1",f=c.concat,d=c.push,h=c.slice,g=c.indexOf,m=l.toString,y=l.hasOwnProperty,v=p.trim,b=function(e,t){return new b.fn.init(e,t,r)},x=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,w=/\S+/g,T=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,N=/^(?:(<[\w\W]+>)[^>]*|#([\w-]*))$/,C=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,k=/^[\],:{}\s]*$/,E=/(?:^|:|,)(?:\s*\[)+/g,S=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,A=/"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,j=/^-ms-/,D=/-([\da-z])/gi,L=function(e,t){return t.toUpperCase()},H=function(e){(o.addEventListener||"load"===e.type||"complete"===o.readyState)&&(q(),b.ready())},q=function(){o.addEventListener?(o.removeEventListener("DOMContentLoaded",H,!1),e.removeEventListener("load",H,!1)):(o.detachEvent("onreadystatechange",H),e.detachEvent("onload",H))};b.fn=b.prototype={jquery:p,constructor:b,init:function(e,n,r){var i,a;if(!e)return this;if("string"==typeof e){if(i="<"===e.charAt(0)&&">"===e.charAt(e.length-1)&&e.length>=3?[null,e,null]:N.exec(e),!i||!i[1]&&n)return!n||n.jquery?(n||r).find(e):this.constructor(n).find(e);if(i[1]){if(n=n instanceof b?n[0]:n,b.merge(this,b.parseHTML(i[1],n&&n.nodeType?n.ownerDocument||n:o,!0)),C.test(i[1])&&b.isPlainObject(n))for(i in n)b.isFunction(this[i])?this[i](n[i]):this.attr(i,n[i]);return this}if(a=o.getElementById(i[2]),a&&a.parentNode){if(a.id!==i[2])return r.find(e);this.length=1,this[0]=a}return this.context=o,this.selector=e,this}return e.nodeType?(this.context=this[0]=e,this.length=1,this):b.isFunction(e)?r.ready(e):(e.selector!==t&&(this.selector=e.selector,this.context=e.context),b.makeArray(e,this))},selector:"",length:0,size:function(){return this.length},toArray:function(){return h.call(this)},get:function(e){return null==e?this.toArray():0>e?this[this.length+e]:this[e]},pushStack:function(e){var t=b.merge(this.constructor(),e);return t.prevObject=this,t.context=this.context,t},each:function(e,t){return b.each(this,e,t)},ready:function(e){return b.ready.promise().done(e),this},slice:function(){return this.pushStack(h.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(e){var t=this.length,n=+e+(0>e?t:0);return this.pushStack(n>=0&&t>n?[this[n]]:[])},map:function(e){return this.pushStack(b.map(this,function(t,n){return e.call(t,n,t)}))},end:function(){return this.prevObject||this.constructor(null)},push:d,sort:[].sort,splice:[].splice},b.fn.init.prototype=b.fn,b.extend=b.fn.extend=function(){var e,n,r,i,o,a,s=arguments[0]||{},u=1,l=arguments.length,c=!1;for("boolean"==typeof s&&(c=s,s=arguments[1]||{},u=2),"object"==typeof s||b.isFunction(s)||(s={}),l===u&&(s=this,--u);l>u;u++)if(null!=(o=arguments[u]))for(i in o)e=s[i],r=o[i],s!==r&&(c&&r&&(b.isPlainObject(r)||(n=b.isArray(r)))?(n?(n=!1,a=e&&b.isArray(e)?e:[]):a=e&&b.isPlainObject(e)?e:{},s[i]=b.extend(c,a,r)):r!==t&&(s[i]=r));return s},b.extend({noConflict:function(t){return e.$===b&&(e.$=u),t&&e.jQuery===b&&(e.jQuery=s),b},isReady:!1,readyWait:1,holdReady:function(e){e?b.readyWait++:b.ready(!0)},ready:function(e){if(e===!0?!--b.readyWait:!b.isReady){if(!o.body)return setTimeout(b.ready);b.isReady=!0,e!==!0&&--b.readyWait>0||(n.resolveWith(o,[b]),b.fn.trigger&&b(o).trigger("ready").off("ready"))}},isFunction:function(e){return"function"===b.type(e)},isArray:Array.isArray||function(e){return"array"===b.type(e)},isWindow:function(e){return null!=e&&e==e.window},isNumeric:function(e){return!isNaN(parseFloat(e))&&isFinite(e)},type:function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?l[m.call(e)]||"object":typeof e},isPlainObject:function(e){if(!e||"object"!==b.type(e)||e.nodeType||b.isWindow(e))return!1;try{if(e.constructor&&!y.call(e,"constructor")&&!y.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(n){return!1}var r;for(r in e);return r===t||y.call(e,r)},isEmptyObject:function(e){var t;for(t in e)return!1;return!0},error:function(e){throw Error(e)},parseHTML:function(e,t,n){if(!e||"string"!=typeof e)return null;"boolean"==typeof t&&(n=t,t=!1),t=t||o;var r=C.exec(e),i=!n&&[];return r?[t.createElement(r[1])]:(r=b.buildFragment([e],t,i),i&&b(i).remove(),b.merge([],r.childNodes))},parseJSON:function(n){return e.JSON&&e.JSON.parse?e.JSON.parse(n):null===n?n:"string"==typeof n&&(n=b.trim(n),n&&k.test(n.replace(S,"@").replace(A,"]").replace(E,"")))?Function("return "+n)():(b.error("Invalid JSON: "+n),t)},parseXML:function(n){var r,i;if(!n||"string"!=typeof n)return null;try{e.DOMParser?(i=new DOMParser,r=i.parseFromString(n,"text/xml")):(r=new ActiveXObject("Microsoft.XMLDOM"),r.async="false",r.loadXML(n))}catch(o){r=t}return r&&r.documentElement&&!r.getElementsByTagName("parsererror").length||b.error("Invalid XML: "+n),r},noop:function(){},globalEval:function(t){t&&b.trim(t)&&(e.execScript||function(t){e.eval.call(e,t)})(t)},camelCase:function(e){return e.replace(j,"ms-").replace(D,L)},nodeName:function(e,t){return e.nodeName&&e.nodeName.toLowerCase()===t.toLowerCase()},each:function(e,t,n){var r,i=0,o=e.length,a=M(e);if(n){if(a){for(;o>i;i++)if(r=t.apply(e[i],n),r===!1)break}else for(i in e)if(r=t.apply(e[i],n),r===!1)break}else if(a){for(;o>i;i++)if(r=t.call(e[i],i,e[i]),r===!1)break}else for(i in e)if(r=t.call(e[i],i,e[i]),r===!1)break;return e},trim:v&&!v.call("\ufeff\u00a0")?function(e){return null==e?"":v.call(e)}:function(e){return null==e?"":(e+"").replace(T,"")},makeArray:function(e,t){var n=t||[];return null!=e&&(M(Object(e))?b.merge(n,"string"==typeof e?[e]:e):d.call(n,e)),n},inArray:function(e,t,n){var r;if(t){if(g)return g.call(t,e,n);for(r=t.length,n=n?0>n?Math.max(0,r+n):n:0;r>n;n++)if(n in t&&t[n]===e)return n}return-1},merge:function(e,n){var r=n.length,i=e.length,o=0;if("number"==typeof r)for(;r>o;o++)e[i++]=n[o];else while(n[o]!==t)e[i++]=n[o++];return e.length=i,e},grep:function(e,t,n){var r,i=[],o=0,a=e.length;for(n=!!n;a>o;o++)r=!!t(e[o],o),n!==r&&i.push(e[o]);return i},map:function(e,t,n){var r,i=0,o=e.length,a=M(e),s=[];if(a)for(;o>i;i++)r=t(e[i],i,n),null!=r&&(s[s.length]=r);else for(i in e)r=t(e[i],i,n),null!=r&&(s[s.length]=r);return f.apply([],s)},guid:1,proxy:function(e,n){var r,i,o;return"string"==typeof n&&(o=e[n],n=e,e=o),b.isFunction(e)?(r=h.call(arguments,2),i=function(){return e.apply(n||this,r.concat(h.call(arguments)))},i.guid=e.guid=e.guid||b.guid++,i):t},access:function(e,n,r,i,o,a,s){var u=0,l=e.length,c=null==r;if("object"===b.type(r)){o=!0;for(u in r)b.access(e,n,u,r[u],!0,a,s)}else if(i!==t&&(o=!0,b.isFunction(i)||(s=!0),c&&(s?(n.call(e,i),n=null):(c=n,n=function(e,t,n){return c.call(b(e),n)})),n))for(;l>u;u++)n(e[u],r,s?i:i.call(e[u],u,n(e[u],r)));return o?e:c?n.call(e):l?n(e[0],r):a},now:function(){return(new Date).getTime()}}),b.ready.promise=function(t){if(!n)if(n=b.Deferred(),"complete"===o.readyState)setTimeout(b.ready);else if(o.addEventListener)o.addEventListener("DOMContentLoaded",H,!1),e.addEventListener("load",H,!1);else{o.attachEvent("onreadystatechange",H),e.attachEvent("onload",H);var r=!1;try{r=null==e.frameElement&&o.documentElement}catch(i){}r&&r.doScroll&&function a(){if(!b.isReady){try{r.doScroll("left")}catch(e){return setTimeout(a,50)}q(),b.ready()}}()}return n.promise(t)},b.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(e,t){l["[object "+t+"]"]=t.toLowerCase()});function M(e){var t=e.length,n=b.type(e);return b.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===n||"function"!==n&&(0===t||"number"==typeof t&&t>0&&t-1 in e)}r=b(o);var _={};function F(e){var t=_[e]={};return b.each(e.match(w)||[],function(e,n){t[n]=!0}),t}b.Callbacks=function(e){e="string"==typeof e?_[e]||F(e):b.extend({},e);var n,r,i,o,a,s,u=[],l=!e.once&&[],c=function(t){for(r=e.memory&&t,i=!0,a=s||0,s=0,o=u.length,n=!0;u&&o>a;a++)if(u[a].apply(t[0],t[1])===!1&&e.stopOnFalse){r=!1;break}n=!1,u&&(l?l.length&&c(l.shift()):r?u=[]:p.disable())},p={add:function(){if(u){var t=u.length;(function i(t){b.each(t,function(t,n){var r=b.type(n);"function"===r?e.unique&&p.has(n)||u.push(n):n&&n.length&&"string"!==r&&i(n)})})(arguments),n?o=u.length:r&&(s=t,c(r))}return this},remove:function(){return u&&b.each(arguments,function(e,t){var r;while((r=b.inArray(t,u,r))>-1)u.splice(r,1),n&&(o>=r&&o--,a>=r&&a--)}),this},has:function(e){return e?b.inArray(e,u)>-1:!(!u||!u.length)},empty:function(){return u=[],this},disable:function(){return u=l=r=t,this},disabled:function(){return!u},lock:function(){return l=t,r||p.disable(),this},locked:function(){return!l},fireWith:function(e,t){return t=t||[],t=[e,t.slice?t.slice():t],!u||i&&!l||(n?l.push(t):c(t)),this},fire:function(){return p.fireWith(this,arguments),this},fired:function(){return!!i}};return p},b.extend({Deferred:function(e){var t=[["resolve","done",b.Callbacks("once memory"),"resolved"],["reject","fail",b.Callbacks("once memory"),"rejected"],["notify","progress",b.Callbacks("memory")]],n="pending",r={state:function(){return n},always:function(){return i.done(arguments).fail(arguments),this},then:function(){var e=arguments;return b.Deferred(function(n){b.each(t,function(t,o){var a=o[0],s=b.isFunction(e[t])&&e[t];i[o[1]](function(){var e=s&&s.apply(this,arguments);e&&b.isFunction(e.promise)?e.promise().done(n.resolve).fail(n.reject).progress(n.notify):n[a+"With"](this===r?n.promise():this,s?[e]:arguments)})}),e=null}).promise()},promise:function(e){return null!=e?b.extend(e,r):r}},i={};return r.pipe=r.then,b.each(t,function(e,o){var a=o[2],s=o[3];r[o[1]]=a.add,s&&a.add(function(){n=s},t[1^e][2].disable,t[2][2].lock),i[o[0]]=function(){return i[o[0]+"With"](this===i?r:this,arguments),this},i[o[0]+"With"]=a.fireWith}),r.promise(i),e&&e.call(i,i),i},when:function(e){var t=0,n=h.call(arguments),r=n.length,i=1!==r||e&&b.isFunction(e.promise)?r:0,o=1===i?e:b.Deferred(),a=function(e,t,n){return function(r){t[e]=this,n[e]=arguments.length>1?h.call(arguments):r,n===s?o.notifyWith(t,n):--i||o.resolveWith(t,n)}},s,u,l;if(r>1)for(s=Array(r),u=Array(r),l=Array(r);r>t;t++)n[t]&&b.isFunction(n[t].promise)?n[t].promise().done(a(t,l,n)).fail(o.reject).progress(a(t,u,s)):--i;return i||o.resolveWith(l,n),o.promise()}}),b.support=function(){var t,n,r,a,s,u,l,c,p,f,d=o.createElement("div");if(d.setAttribute("className","t"),d.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>",n=d.getElementsByTagName("*"),r=d.getElementsByTagName("a")[0],!n||!r||!n.length)return{};s=o.createElement("select"),l=s.appendChild(o.createElement("option")),a=d.getElementsByTagName("input")[0],r.style.cssText="top:1px;float:left;opacity:.5",t={getSetAttribute:"t"!==d.className,leadingWhitespace:3===d.firstChild.nodeType,tbody:!d.getElementsByTagName("tbody").length,htmlSerialize:!!d.getElementsByTagName("link").length,style:/top/.test(r.getAttribute("style")),hrefNormalized:"/a"===r.getAttribute("href"),opacity:/^0.5/.test(r.style.opacity),cssFloat:!!r.style.cssFloat,checkOn:!!a.value,optSelected:l.selected,enctype:!!o.createElement("form").enctype,html5Clone:"<:nav></:nav>"!==o.createElement("nav").cloneNode(!0).outerHTML,boxModel:"CSS1Compat"===o.compatMode,deleteExpando:!0,noCloneEvent:!0,inlineBlockNeedsLayout:!1,shrinkWrapBlocks:!1,reliableMarginRight:!0,boxSizingReliable:!0,pixelPosition:!1},a.checked=!0,t.noCloneChecked=a.cloneNode(!0).checked,s.disabled=!0,t.optDisabled=!l.disabled;try{delete d.test}catch(h){t.deleteExpando=!1}a=o.createElement("input"),a.setAttribute("value",""),t.input=""===a.getAttribute("value"),a.value="t",a.setAttribute("type","radio"),t.radioValue="t"===a.value,a.setAttribute("checked","t"),a.setAttribute("name","t"),u=o.createDocumentFragment(),u.appendChild(a),t.appendChecked=a.checked,t.checkClone=u.cloneNode(!0).cloneNode(!0).lastChild.checked,d.attachEvent&&(d.attachEvent("onclick",function(){t.noCloneEvent=!1}),d.cloneNode(!0).click());for(f in{submit:!0,change:!0,focusin:!0})d.setAttribute(c="on"+f,"t"),t[f+"Bubbles"]=c in e||d.attributes[c].expando===!1;return d.style.backgroundClip="content-box",d.cloneNode(!0).style.backgroundClip="",t.clearCloneStyle="content-box"===d.style.backgroundClip,b(function(){var n,r,a,s="padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;",u=o.getElementsByTagName("body")[0];u&&(n=o.createElement("div"),n.style.cssText="border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px",u.appendChild(n).appendChild(d),d.innerHTML="<table><tr><td></td><td>t</td></tr></table>",a=d.getElementsByTagName("td"),a[0].style.cssText="padding:0;margin:0;border:0;display:none",p=0===a[0].offsetHeight,a[0].style.display="",a[1].style.display="none",t.reliableHiddenOffsets=p&&0===a[0].offsetHeight,d.innerHTML="",d.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;",t.boxSizing=4===d.offsetWidth,t.doesNotIncludeMarginInBodyOffset=1!==u.offsetTop,e.getComputedStyle&&(t.pixelPosition="1%"!==(e.getComputedStyle(d,null)||{}).top,t.boxSizingReliable="4px"===(e.getComputedStyle(d,null)||{width:"4px"}).width,r=d.appendChild(o.createElement("div")),r.style.cssText=d.style.cssText=s,r.style.marginRight=r.style.width="0",d.style.width="1px",t.reliableMarginRight=!parseFloat((e.getComputedStyle(r,null)||{}).marginRight)),typeof d.style.zoom!==i&&(d.innerHTML="",d.style.cssText=s+"width:1px;padding:1px;display:inline;zoom:1",t.inlineBlockNeedsLayout=3===d.offsetWidth,d.style.display="block",d.innerHTML="<div></div>",d.firstChild.style.width="5px",t.shrinkWrapBlocks=3!==d.offsetWidth,t.inlineBlockNeedsLayout&&(u.style.zoom=1)),u.removeChild(n),n=d=a=r=null)}),n=s=u=l=r=a=null,t}();var O=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,B=/([A-Z])/g;function P(e,n,r,i){if(b.acceptData(e)){var o,a,s=b.expando,u="string"==typeof n,l=e.nodeType,p=l?b.cache:e,f=l?e[s]:e[s]&&s;if(f&&p[f]&&(i||p[f].data)||!u||r!==t)return f||(l?e[s]=f=c.pop()||b.guid++:f=s),p[f]||(p[f]={},l||(p[f].toJSON=b.noop)),("object"==typeof n||"function"==typeof n)&&(i?p[f]=b.extend(p[f],n):p[f].data=b.extend(p[f].data,n)),o=p[f],i||(o.data||(o.data={}),o=o.data),r!==t&&(o[b.camelCase(n)]=r),u?(a=o[n],null==a&&(a=o[b.camelCase(n)])):a=o,a}}function R(e,t,n){if(b.acceptData(e)){var r,i,o,a=e.nodeType,s=a?b.cache:e,u=a?e[b.expando]:b.expando;if(s[u]){if(t&&(o=n?s[u]:s[u].data)){b.isArray(t)?t=t.concat(b.map(t,b.camelCase)):t in o?t=[t]:(t=b.camelCase(t),t=t in o?[t]:t.split(" "));for(r=0,i=t.length;i>r;r++)delete o[t[r]];if(!(n?$:b.isEmptyObject)(o))return}(n||(delete s[u].data,$(s[u])))&&(a?b.cleanData([e],!0):b.support.deleteExpando||s!=s.window?delete s[u]:s[u]=null)}}}b.extend({cache:{},expando:"jQuery"+(p+Math.random()).replace(/\D/g,""),noData:{embed:!0,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:!0},hasData:function(e){return e=e.nodeType?b.cache[e[b.expando]]:e[b.expando],!!e&&!$(e)},data:function(e,t,n){return P(e,t,n)},removeData:function(e,t){return R(e,t)},_data:function(e,t,n){return P(e,t,n,!0)},_removeData:function(e,t){return R(e,t,!0)},acceptData:function(e){if(e.nodeType&&1!==e.nodeType&&9!==e.nodeType)return!1;var t=e.nodeName&&b.noData[e.nodeName.toLowerCase()];return!t||t!==!0&&e.getAttribute("classid")===t}}),b.fn.extend({data:function(e,n){var r,i,o=this[0],a=0,s=null;if(e===t){if(this.length&&(s=b.data(o),1===o.nodeType&&!b._data(o,"parsedAttrs"))){for(r=o.attributes;r.length>a;a++)i=r[a].name,i.indexOf("data-")||(i=b.camelCase(i.slice(5)),W(o,i,s[i]));b._data(o,"parsedAttrs",!0)}return s}return"object"==typeof e?this.each(function(){b.data(this,e)}):b.access(this,function(n){return n===t?o?W(o,e,b.data(o,e)):null:(this.each(function(){b.data(this,e,n)}),t)},null,n,arguments.length>1,null,!0)},removeData:function(e){return this.each(function(){b.removeData(this,e)})}});function W(e,n,r){if(r===t&&1===e.nodeType){var i="data-"+n.replace(B,"-$1").toLowerCase();if(r=e.getAttribute(i),"string"==typeof r){try{r="true"===r?!0:"false"===r?!1:"null"===r?null:+r+""===r?+r:O.test(r)?b.parseJSON(r):r}catch(o){}b.data(e,n,r)}else r=t}return r}function $(e){var t;for(t in e)if(("data"!==t||!b.isEmptyObject(e[t]))&&"toJSON"!==t)return!1;return!0}b.extend({queue:function(e,n,r){var i;return e?(n=(n||"fx")+"queue",i=b._data(e,n),r&&(!i||b.isArray(r)?i=b._data(e,n,b.makeArray(r)):i.push(r)),i||[]):t},dequeue:function(e,t){t=t||"fx";var n=b.queue(e,t),r=n.length,i=n.shift(),o=b._queueHooks(e,t),a=function(){b.dequeue(e,t)};"inprogress"===i&&(i=n.shift(),r--),o.cur=i,i&&("fx"===t&&n.unshift("inprogress"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+"queueHooks";return b._data(e,n)||b._data(e,n,{empty:b.Callbacks("once memory").add(function(){b._removeData(e,t+"queue"),b._removeData(e,n)})})}}),b.fn.extend({queue:function(e,n){var r=2;return"string"!=typeof e&&(n=e,e="fx",r--),r>arguments.length?b.queue(this[0],e):n===t?this:this.each(function(){var t=b.queue(this,e,n);b._queueHooks(this,e),"fx"===e&&"inprogress"!==t[0]&&b.dequeue(this,e)})},dequeue:function(e){return this.each(function(){b.dequeue(this,e)})},delay:function(e,t){return e=b.fx?b.fx.speeds[e]||e:e,t=t||"fx",this.queue(t,function(t,n){var r=setTimeout(t,e);n.stop=function(){clearTimeout(r)}})},clearQueue:function(e){return this.queue(e||"fx",[])},promise:function(e,n){var r,i=1,o=b.Deferred(),a=this,s=this.length,u=function(){--i||o.resolveWith(a,[a])};"string"!=typeof e&&(n=e,e=t),e=e||"fx";while(s--)r=b._data(a[s],e+"queueHooks"),r&&r.empty&&(i++,r.empty.add(u));return u(),o.promise(n)}});var I,z,X=/[\t\r\n]/g,U=/\r/g,V=/^(?:input|select|textarea|button|object)$/i,Y=/^(?:a|area)$/i,J=/^(?:checked|selected|autofocus|autoplay|async|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped)$/i,G=/^(?:checked|selected)$/i,Q=b.support.getSetAttribute,K=b.support.input;b.fn.extend({attr:function(e,t){return b.access(this,b.attr,e,t,arguments.length>1)},removeAttr:function(e){return this.each(function(){b.removeAttr(this,e)})},prop:function(e,t){return b.access(this,b.prop,e,t,arguments.length>1)},removeProp:function(e){return e=b.propFix[e]||e,this.each(function(){try{this[e]=t,delete this[e]}catch(n){}})},addClass:function(e){var t,n,r,i,o,a=0,s=this.length,u="string"==typeof e&&e;if(b.isFunction(e))return this.each(function(t){b(this).addClass(e.call(this,t,this.className))});if(u)for(t=(e||"").match(w)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(X," "):" ")){o=0;while(i=t[o++])0>r.indexOf(" "+i+" ")&&(r+=i+" ");n.className=b.trim(r)}return this},removeClass:function(e){var t,n,r,i,o,a=0,s=this.length,u=0===arguments.length||"string"==typeof e&&e;if(b.isFunction(e))return this.each(function(t){b(this).removeClass(e.call(this,t,this.className))});if(u)for(t=(e||"").match(w)||[];s>a;a++)if(n=this[a],r=1===n.nodeType&&(n.className?(" "+n.className+" ").replace(X," "):"")){o=0;while(i=t[o++])while(r.indexOf(" "+i+" ")>=0)r=r.replace(" "+i+" "," ");n.className=e?b.trim(r):""}return this},toggleClass:function(e,t){var n=typeof e,r="boolean"==typeof t;return b.isFunction(e)?this.each(function(n){b(this).toggleClass(e.call(this,n,this.className,t),t)}):this.each(function(){if("string"===n){var o,a=0,s=b(this),u=t,l=e.match(w)||[];while(o=l[a++])u=r?u:!s.hasClass(o),s[u?"addClass":"removeClass"](o)}else(n===i||"boolean"===n)&&(this.className&&b._data(this,"__className__",this.className),this.className=this.className||e===!1?"":b._data(this,"__className__")||"")})},hasClass:function(e){var t=" "+e+" ",n=0,r=this.length;for(;r>n;n++)if(1===this[n].nodeType&&(" "+this[n].className+" ").replace(X," ").indexOf(t)>=0)return!0;return!1},val:function(e){var n,r,i,o=this[0];{if(arguments.length)return i=b.isFunction(e),this.each(function(n){var o,a=b(this);1===this.nodeType&&(o=i?e.call(this,n,a.val()):e,null==o?o="":"number"==typeof o?o+="":b.isArray(o)&&(o=b.map(o,function(e){return null==e?"":e+""})),r=b.valHooks[this.type]||b.valHooks[this.nodeName.toLowerCase()],r&&"set"in r&&r.set(this,o,"value")!==t||(this.value=o))});if(o)return r=b.valHooks[o.type]||b.valHooks[o.nodeName.toLowerCase()],r&&"get"in r&&(n=r.get(o,"value"))!==t?n:(n=o.value,"string"==typeof n?n.replace(U,""):null==n?"":n)}}}),b.extend({valHooks:{option:{get:function(e){var t=e.attributes.value;return!t||t.specified?e.value:e.text}},select:{get:function(e){var t,n,r=e.options,i=e.selectedIndex,o="select-one"===e.type||0>i,a=o?null:[],s=o?i+1:r.length,u=0>i?s:o?i:0;for(;s>u;u++)if(n=r[u],!(!n.selected&&u!==i||(b.support.optDisabled?n.disabled:null!==n.getAttribute("disabled"))||n.parentNode.disabled&&b.nodeName(n.parentNode,"optgroup"))){if(t=b(n).val(),o)return t;a.push(t)}return a},set:function(e,t){var n=b.makeArray(t);return b(e).find("option").each(function(){this.selected=b.inArray(b(this).val(),n)>=0}),n.length||(e.selectedIndex=-1),n}}},attr:function(e,n,r){var o,a,s,u=e.nodeType;if(e&&3!==u&&8!==u&&2!==u)return typeof e.getAttribute===i?b.prop(e,n,r):(a=1!==u||!b.isXMLDoc(e),a&&(n=n.toLowerCase(),o=b.attrHooks[n]||(J.test(n)?z:I)),r===t?o&&a&&"get"in o&&null!==(s=o.get(e,n))?s:(typeof e.getAttribute!==i&&(s=e.getAttribute(n)),null==s?t:s):null!==r?o&&a&&"set"in o&&(s=o.set(e,r,n))!==t?s:(e.setAttribute(n,r+""),r):(b.removeAttr(e,n),t))},removeAttr:function(e,t){var n,r,i=0,o=t&&t.match(w);if(o&&1===e.nodeType)while(n=o[i++])r=b.propFix[n]||n,J.test(n)?!Q&&G.test(n)?e[b.camelCase("default-"+n)]=e[r]=!1:e[r]=!1:b.attr(e,n,""),e.removeAttribute(Q?n:r)},attrHooks:{type:{set:function(e,t){if(!b.support.radioValue&&"radio"===t&&b.nodeName(e,"input")){var n=e.value;return e.setAttribute("type",t),n&&(e.value=n),t}}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(e,n,r){var i,o,a,s=e.nodeType;if(e&&3!==s&&8!==s&&2!==s)return a=1!==s||!b.isXMLDoc(e),a&&(n=b.propFix[n]||n,o=b.propHooks[n]),r!==t?o&&"set"in o&&(i=o.set(e,r,n))!==t?i:e[n]=r:o&&"get"in o&&null!==(i=o.get(e,n))?i:e[n]},propHooks:{tabIndex:{get:function(e){var n=e.getAttributeNode("tabindex");return n&&n.specified?parseInt(n.value,10):V.test(e.nodeName)||Y.test(e.nodeName)&&e.href?0:t}}}}),z={get:function(e,n){var r=b.prop(e,n),i="boolean"==typeof r&&e.getAttribute(n),o="boolean"==typeof r?K&&Q?null!=i:G.test(n)?e[b.camelCase("default-"+n)]:!!i:e.getAttributeNode(n);return o&&o.value!==!1?n.toLowerCase():t},set:function(e,t,n){return t===!1?b.removeAttr(e,n):K&&Q||!G.test(n)?e.setAttribute(!Q&&b.propFix[n]||n,n):e[b.camelCase("default-"+n)]=e[n]=!0,n}},K&&Q||(b.attrHooks.value={get:function(e,n){var r=e.getAttributeNode(n);return b.nodeName(e,"input")?e.defaultValue:r&&r.specified?r.value:t},set:function(e,n,r){return b.nodeName(e,"input")?(e.defaultValue=n,t):I&&I.set(e,n,r)}}),Q||(I=b.valHooks.button={get:function(e,n){var r=e.getAttributeNode(n);return r&&("id"===n||"name"===n||"coords"===n?""!==r.value:r.specified)?r.value:t},set:function(e,n,r){var i=e.getAttributeNode(r);return i||e.setAttributeNode(i=e.ownerDocument.createAttribute(r)),i.value=n+="","value"===r||n===e.getAttribute(r)?n:t}},b.attrHooks.contenteditable={get:I.get,set:function(e,t,n){I.set(e,""===t?!1:t,n)}},b.each(["width","height"],function(e,n){b.attrHooks[n]=b.extend(b.attrHooks[n],{set:function(e,r){return""===r?(e.setAttribute(n,"auto"),r):t}})})),b.support.hrefNormalized||(b.each(["href","src","width","height"],function(e,n){b.attrHooks[n]=b.extend(b.attrHooks[n],{get:function(e){var r=e.getAttribute(n,2);return null==r?t:r}})}),b.each(["href","src"],function(e,t){b.propHooks[t]={get:function(e){return e.getAttribute(t,4)}}})),b.support.style||(b.attrHooks.style={get:function(e){return e.style.cssText||t},set:function(e,t){return e.style.cssText=t+""}}),b.support.optSelected||(b.propHooks.selected=b.extend(b.propHooks.selected,{get:function(e){var t=e.parentNode;return t&&(t.selectedIndex,t.parentNode&&t.parentNode.selectedIndex),null}})),b.support.enctype||(b.propFix.enctype="encoding"),b.support.checkOn||b.each(["radio","checkbox"],function(){b.valHooks[this]={get:function(e){return null===e.getAttribute("value")?"on":e.value}}}),b.each(["radio","checkbox"],function(){b.valHooks[this]=b.extend(b.valHooks[this],{set:function(e,n){return b.isArray(n)?e.checked=b.inArray(b(e).val(),n)>=0:t}})});var Z=/^(?:input|select|textarea)$/i,et=/^key/,tt=/^(?:mouse|contextmenu)|click/,nt=/^(?:focusinfocus|focusoutblur)$/,rt=/^([^.]*)(?:\.(.+)|)$/;function it(){return!0}function ot(){return!1}b.event={global:{},add:function(e,n,r,o,a){var s,u,l,c,p,f,d,h,g,m,y,v=b._data(e);if(v){r.handler&&(c=r,r=c.handler,a=c.selector),r.guid||(r.guid=b.guid++),(u=v.events)||(u=v.events={}),(f=v.handle)||(f=v.handle=function(e){return typeof b===i||e&&b.event.triggered===e.type?t:b.event.dispatch.apply(f.elem,arguments)},f.elem=e),n=(n||"").match(w)||[""],l=n.length;while(l--)s=rt.exec(n[l])||[],g=y=s[1],m=(s[2]||"").split(".").sort(),p=b.event.special[g]||{},g=(a?p.delegateType:p.bindType)||g,p=b.event.special[g]||{},d=b.extend({type:g,origType:y,data:o,handler:r,guid:r.guid,selector:a,needsContext:a&&b.expr.match.needsContext.test(a),namespace:m.join(".")},c),(h=u[g])||(h=u[g]=[],h.delegateCount=0,p.setup&&p.setup.call(e,o,m,f)!==!1||(e.addEventListener?e.addEventListener(g,f,!1):e.attachEvent&&e.attachEvent("on"+g,f))),p.add&&(p.add.call(e,d),d.handler.guid||(d.handler.guid=r.guid)),a?h.splice(h.delegateCount++,0,d):h.push(d),b.event.global[g]=!0;e=null}},remove:function(e,t,n,r,i){var o,a,s,u,l,c,p,f,d,h,g,m=b.hasData(e)&&b._data(e);if(m&&(c=m.events)){t=(t||"").match(w)||[""],l=t.length;while(l--)if(s=rt.exec(t[l])||[],d=g=s[1],h=(s[2]||"").split(".").sort(),d){p=b.event.special[d]||{},d=(r?p.delegateType:p.bindType)||d,f=c[d]||[],s=s[2]&&RegExp("(^|\\.)"+h.join("\\.(?:.*\\.|)")+"(\\.|$)"),u=o=f.length;while(o--)a=f[o],!i&&g!==a.origType||n&&n.guid!==a.guid||s&&!s.test(a.namespace)||r&&r!==a.selector&&("**"!==r||!a.selector)||(f.splice(o,1),a.selector&&f.delegateCount--,p.remove&&p.remove.call(e,a));u&&!f.length&&(p.teardown&&p.teardown.call(e,h,m.handle)!==!1||b.removeEvent(e,d,m.handle),delete c[d])}else for(d in c)b.event.remove(e,d+t[l],n,r,!0);b.isEmptyObject(c)&&(delete m.handle,b._removeData(e,"events"))}},trigger:function(n,r,i,a){var s,u,l,c,p,f,d,h=[i||o],g=y.call(n,"type")?n.type:n,m=y.call(n,"namespace")?n.namespace.split("."):[];if(l=f=i=i||o,3!==i.nodeType&&8!==i.nodeType&&!nt.test(g+b.event.triggered)&&(g.indexOf(".")>=0&&(m=g.split("."),g=m.shift(),m.sort()),u=0>g.indexOf(":")&&"on"+g,n=n[b.expando]?n:new b.Event(g,"object"==typeof n&&n),n.isTrigger=!0,n.namespace=m.join("."),n.namespace_re=n.namespace?RegExp("(^|\\.)"+m.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,n.result=t,n.target||(n.target=i),r=null==r?[n]:b.makeArray(r,[n]),p=b.event.special[g]||{},a||!p.trigger||p.trigger.apply(i,r)!==!1)){if(!a&&!p.noBubble&&!b.isWindow(i)){for(c=p.delegateType||g,nt.test(c+g)||(l=l.parentNode);l;l=l.parentNode)h.push(l),f=l;f===(i.ownerDocument||o)&&h.push(f.defaultView||f.parentWindow||e)}d=0;while((l=h[d++])&&!n.isPropagationStopped())n.type=d>1?c:p.bindType||g,s=(b._data(l,"events")||{})[n.type]&&b._data(l,"handle"),s&&s.apply(l,r),s=u&&l[u],s&&b.acceptData(l)&&s.apply&&s.apply(l,r)===!1&&n.preventDefault();if(n.type=g,!(a||n.isDefaultPrevented()||p._default&&p._default.apply(i.ownerDocument,r)!==!1||"click"===g&&b.nodeName(i,"a")||!b.acceptData(i)||!u||!i[g]||b.isWindow(i))){f=i[u],f&&(i[u]=null),b.event.triggered=g;try{i[g]()}catch(v){}b.event.triggered=t,f&&(i[u]=f)}return n.result}},dispatch:function(e){e=b.event.fix(e);var n,r,i,o,a,s=[],u=h.call(arguments),l=(b._data(this,"events")||{})[e.type]||[],c=b.event.special[e.type]||{};if(u[0]=e,e.delegateTarget=this,!c.preDispatch||c.preDispatch.call(this,e)!==!1){s=b.event.handlers.call(this,e,l),n=0;while((o=s[n++])&&!e.isPropagationStopped()){e.currentTarget=o.elem,a=0;while((i=o.handlers[a++])&&!e.isImmediatePropagationStopped())(!e.namespace_re||e.namespace_re.test(i.namespace))&&(e.handleObj=i,e.data=i.data,r=((b.event.special[i.origType]||{}).handle||i.handler).apply(o.elem,u),r!==t&&(e.result=r)===!1&&(e.preventDefault(),e.stopPropagation()))}return c.postDispatch&&c.postDispatch.call(this,e),e.result}},handlers:function(e,n){var r,i,o,a,s=[],u=n.delegateCount,l=e.target;if(u&&l.nodeType&&(!e.button||"click"!==e.type))for(;l!=this;l=l.parentNode||this)if(1===l.nodeType&&(l.disabled!==!0||"click"!==e.type)){for(o=[],a=0;u>a;a++)i=n[a],r=i.selector+" ",o[r]===t&&(o[r]=i.needsContext?b(r,this).index(l)>=0:b.find(r,this,null,[l]).length),o[r]&&o.push(i);o.length&&s.push({elem:l,handlers:o})}return n.length>u&&s.push({elem:this,handlers:n.slice(u)}),s},fix:function(e){if(e[b.expando])return e;var t,n,r,i=e.type,a=e,s=this.fixHooks[i];s||(this.fixHooks[i]=s=tt.test(i)?this.mouseHooks:et.test(i)?this.keyHooks:{}),r=s.props?this.props.concat(s.props):this.props,e=new b.Event(a),t=r.length;while(t--)n=r[t],e[n]=a[n];return e.target||(e.target=a.srcElement||o),3===e.target.nodeType&&(e.target=e.target.parentNode),e.metaKey=!!e.metaKey,s.filter?s.filter(e,a):e},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(e,t){return null==e.which&&(e.which=null!=t.charCode?t.charCode:t.keyCode),e}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(e,n){var r,i,a,s=n.button,u=n.fromElement;return null==e.pageX&&null!=n.clientX&&(i=e.target.ownerDocument||o,a=i.documentElement,r=i.body,e.pageX=n.clientX+(a&&a.scrollLeft||r&&r.scrollLeft||0)-(a&&a.clientLeft||r&&r.clientLeft||0),e.pageY=n.clientY+(a&&a.scrollTop||r&&r.scrollTop||0)-(a&&a.clientTop||r&&r.clientTop||0)),!e.relatedTarget&&u&&(e.relatedTarget=u===e.target?n.toElement:u),e.which||s===t||(e.which=1&s?1:2&s?3:4&s?2:0),e}},special:{load:{noBubble:!0},click:{trigger:function(){return b.nodeName(this,"input")&&"checkbox"===this.type&&this.click?(this.click(),!1):t}},focus:{trigger:function(){if(this!==o.activeElement&&this.focus)try{return this.focus(),!1}catch(e){}},delegateType:"focusin"},blur:{trigger:function(){return this===o.activeElement&&this.blur?(this.blur(),!1):t},delegateType:"focusout"},beforeunload:{postDispatch:function(e){e.result!==t&&(e.originalEvent.returnValue=e.result)}}},simulate:function(e,t,n,r){var i=b.extend(new b.Event,n,{type:e,isSimulated:!0,originalEvent:{}});r?b.event.trigger(i,null,t):b.event.dispatch.call(t,i),i.isDefaultPrevented()&&n.preventDefault()}},b.removeEvent=o.removeEventListener?function(e,t,n){e.removeEventListener&&e.removeEventListener(t,n,!1)}:function(e,t,n){var r="on"+t;e.detachEvent&&(typeof e[r]===i&&(e[r]=null),e.detachEvent(r,n))},b.Event=function(e,n){return this instanceof b.Event?(e&&e.type?(this.originalEvent=e,this.type=e.type,this.isDefaultPrevented=e.defaultPrevented||e.returnValue===!1||e.getPreventDefault&&e.getPreventDefault()?it:ot):this.type=e,n&&b.extend(this,n),this.timeStamp=e&&e.timeStamp||b.now(),this[b.expando]=!0,t):new b.Event(e,n)},b.Event.prototype={isDefaultPrevented:ot,isPropagationStopped:ot,isImmediatePropagationStopped:ot,preventDefault:function(){var e=this.originalEvent;this.isDefaultPrevented=it,e&&(e.preventDefault?e.preventDefault():e.returnValue=!1)},stopPropagation:function(){var e=this.originalEvent;this.isPropagationStopped=it,e&&(e.stopPropagation&&e.stopPropagation(),e.cancelBubble=!0)},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=it,this.stopPropagation()}},b.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(e,t){b.event.special[e]={delegateType:t,bindType:t,handle:function(e){var n,r=this,i=e.relatedTarget,o=e.handleObj;
return(!i||i!==r&&!b.contains(r,i))&&(e.type=o.origType,n=o.handler.apply(this,arguments),e.type=t),n}}}),b.support.submitBubbles||(b.event.special.submit={setup:function(){return b.nodeName(this,"form")?!1:(b.event.add(this,"click._submit keypress._submit",function(e){var n=e.target,r=b.nodeName(n,"input")||b.nodeName(n,"button")?n.form:t;r&&!b._data(r,"submitBubbles")&&(b.event.add(r,"submit._submit",function(e){e._submit_bubble=!0}),b._data(r,"submitBubbles",!0))}),t)},postDispatch:function(e){e._submit_bubble&&(delete e._submit_bubble,this.parentNode&&!e.isTrigger&&b.event.simulate("submit",this.parentNode,e,!0))},teardown:function(){return b.nodeName(this,"form")?!1:(b.event.remove(this,"._submit"),t)}}),b.support.changeBubbles||(b.event.special.change={setup:function(){return Z.test(this.nodeName)?(("checkbox"===this.type||"radio"===this.type)&&(b.event.add(this,"propertychange._change",function(e){"checked"===e.originalEvent.propertyName&&(this._just_changed=!0)}),b.event.add(this,"click._change",function(e){this._just_changed&&!e.isTrigger&&(this._just_changed=!1),b.event.simulate("change",this,e,!0)})),!1):(b.event.add(this,"beforeactivate._change",function(e){var t=e.target;Z.test(t.nodeName)&&!b._data(t,"changeBubbles")&&(b.event.add(t,"change._change",function(e){!this.parentNode||e.isSimulated||e.isTrigger||b.event.simulate("change",this.parentNode,e,!0)}),b._data(t,"changeBubbles",!0))}),t)},handle:function(e){var n=e.target;return this!==n||e.isSimulated||e.isTrigger||"radio"!==n.type&&"checkbox"!==n.type?e.handleObj.handler.apply(this,arguments):t},teardown:function(){return b.event.remove(this,"._change"),!Z.test(this.nodeName)}}),b.support.focusinBubbles||b.each({focus:"focusin",blur:"focusout"},function(e,t){var n=0,r=function(e){b.event.simulate(t,e.target,b.event.fix(e),!0)};b.event.special[t]={setup:function(){0===n++&&o.addEventListener(e,r,!0)},teardown:function(){0===--n&&o.removeEventListener(e,r,!0)}}}),b.fn.extend({on:function(e,n,r,i,o){var a,s;if("object"==typeof e){"string"!=typeof n&&(r=r||n,n=t);for(a in e)this.on(a,n,r,e[a],o);return this}if(null==r&&null==i?(i=n,r=n=t):null==i&&("string"==typeof n?(i=r,r=t):(i=r,r=n,n=t)),i===!1)i=ot;else if(!i)return this;return 1===o&&(s=i,i=function(e){return b().off(e),s.apply(this,arguments)},i.guid=s.guid||(s.guid=b.guid++)),this.each(function(){b.event.add(this,e,i,r,n)})},one:function(e,t,n,r){return this.on(e,t,n,r,1)},off:function(e,n,r){var i,o;if(e&&e.preventDefault&&e.handleObj)return i=e.handleObj,b(e.delegateTarget).off(i.namespace?i.origType+"."+i.namespace:i.origType,i.selector,i.handler),this;if("object"==typeof e){for(o in e)this.off(o,n,e[o]);return this}return(n===!1||"function"==typeof n)&&(r=n,n=t),r===!1&&(r=ot),this.each(function(){b.event.remove(this,e,r,n)})},bind:function(e,t,n){return this.on(e,null,t,n)},unbind:function(e,t){return this.off(e,null,t)},delegate:function(e,t,n,r){return this.on(t,e,n,r)},undelegate:function(e,t,n){return 1===arguments.length?this.off(e,"**"):this.off(t,e||"**",n)},trigger:function(e,t){return this.each(function(){b.event.trigger(e,t,this)})},triggerHandler:function(e,n){var r=this[0];return r?b.event.trigger(e,n,r,!0):t}}),function(e,t){var n,r,i,o,a,s,u,l,c,p,f,d,h,g,m,y,v,x="sizzle"+-new Date,w=e.document,T={},N=0,C=0,k=it(),E=it(),S=it(),A=typeof t,j=1<<31,D=[],L=D.pop,H=D.push,q=D.slice,M=D.indexOf||function(e){var t=0,n=this.length;for(;n>t;t++)if(this[t]===e)return t;return-1},_="[\\x20\\t\\r\\n\\f]",F="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",O=F.replace("w","w#"),B="([*^$|!~]?=)",P="\\["+_+"*("+F+")"+_+"*(?:"+B+_+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+O+")|)|)"+_+"*\\]",R=":("+F+")(?:\\(((['\"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|"+P.replace(3,8)+")*)|.*)\\)|)",W=RegExp("^"+_+"+|((?:^|[^\\\\])(?:\\\\.)*)"+_+"+$","g"),$=RegExp("^"+_+"*,"+_+"*"),I=RegExp("^"+_+"*([\\x20\\t\\r\\n\\f>+~])"+_+"*"),z=RegExp(R),X=RegExp("^"+O+"$"),U={ID:RegExp("^#("+F+")"),CLASS:RegExp("^\\.("+F+")"),NAME:RegExp("^\\[name=['\"]?("+F+")['\"]?\\]"),TAG:RegExp("^("+F.replace("w","w*")+")"),ATTR:RegExp("^"+P),PSEUDO:RegExp("^"+R),CHILD:RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+_+"*(even|odd|(([+-]|)(\\d*)n|)"+_+"*(?:([+-]|)"+_+"*(\\d+)|))"+_+"*\\)|)","i"),needsContext:RegExp("^"+_+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+_+"*((?:-\\d)?\\d*)"+_+"*\\)|)(?=[^-]|$)","i")},V=/[\x20\t\r\n\f]*[+~]/,Y=/^[^{]+\{\s*\[native code/,J=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,G=/^(?:input|select|textarea|button)$/i,Q=/^h\d$/i,K=/'|\\/g,Z=/\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,et=/\\([\da-fA-F]{1,6}[\x20\t\r\n\f]?|.)/g,tt=function(e,t){var n="0x"+t-65536;return n!==n?t:0>n?String.fromCharCode(n+65536):String.fromCharCode(55296|n>>10,56320|1023&n)};try{q.call(w.documentElement.childNodes,0)[0].nodeType}catch(nt){q=function(e){var t,n=[];while(t=this[e++])n.push(t);return n}}function rt(e){return Y.test(e+"")}function it(){var e,t=[];return e=function(n,r){return t.push(n+=" ")>i.cacheLength&&delete e[t.shift()],e[n]=r}}function ot(e){return e[x]=!0,e}function at(e){var t=p.createElement("div");try{return e(t)}catch(n){return!1}finally{t=null}}function st(e,t,n,r){var i,o,a,s,u,l,f,g,m,v;if((t?t.ownerDocument||t:w)!==p&&c(t),t=t||p,n=n||[],!e||"string"!=typeof e)return n;if(1!==(s=t.nodeType)&&9!==s)return[];if(!d&&!r){if(i=J.exec(e))if(a=i[1]){if(9===s){if(o=t.getElementById(a),!o||!o.parentNode)return n;if(o.id===a)return n.push(o),n}else if(t.ownerDocument&&(o=t.ownerDocument.getElementById(a))&&y(t,o)&&o.id===a)return n.push(o),n}else{if(i[2])return H.apply(n,q.call(t.getElementsByTagName(e),0)),n;if((a=i[3])&&T.getByClassName&&t.getElementsByClassName)return H.apply(n,q.call(t.getElementsByClassName(a),0)),n}if(T.qsa&&!h.test(e)){if(f=!0,g=x,m=t,v=9===s&&e,1===s&&"object"!==t.nodeName.toLowerCase()){l=ft(e),(f=t.getAttribute("id"))?g=f.replace(K,"\\$&"):t.setAttribute("id",g),g="[id='"+g+"'] ",u=l.length;while(u--)l[u]=g+dt(l[u]);m=V.test(e)&&t.parentNode||t,v=l.join(",")}if(v)try{return H.apply(n,q.call(m.querySelectorAll(v),0)),n}catch(b){}finally{f||t.removeAttribute("id")}}}return wt(e.replace(W,"$1"),t,n,r)}a=st.isXML=function(e){var t=e&&(e.ownerDocument||e).documentElement;return t?"HTML"!==t.nodeName:!1},c=st.setDocument=function(e){var n=e?e.ownerDocument||e:w;return n!==p&&9===n.nodeType&&n.documentElement?(p=n,f=n.documentElement,d=a(n),T.tagNameNoComments=at(function(e){return e.appendChild(n.createComment("")),!e.getElementsByTagName("*").length}),T.attributes=at(function(e){e.innerHTML="<select></select>";var t=typeof e.lastChild.getAttribute("multiple");return"boolean"!==t&&"string"!==t}),T.getByClassName=at(function(e){return e.innerHTML="<div class='hidden e'></div><div class='hidden'></div>",e.getElementsByClassName&&e.getElementsByClassName("e").length?(e.lastChild.className="e",2===e.getElementsByClassName("e").length):!1}),T.getByName=at(function(e){e.id=x+0,e.innerHTML="<a name='"+x+"'></a><div name='"+x+"'></div>",f.insertBefore(e,f.firstChild);var t=n.getElementsByName&&n.getElementsByName(x).length===2+n.getElementsByName(x+0).length;return T.getIdNotName=!n.getElementById(x),f.removeChild(e),t}),i.attrHandle=at(function(e){return e.innerHTML="<a href='#'></a>",e.firstChild&&typeof e.firstChild.getAttribute!==A&&"#"===e.firstChild.getAttribute("href")})?{}:{href:function(e){return e.getAttribute("href",2)},type:function(e){return e.getAttribute("type")}},T.getIdNotName?(i.find.ID=function(e,t){if(typeof t.getElementById!==A&&!d){var n=t.getElementById(e);return n&&n.parentNode?[n]:[]}},i.filter.ID=function(e){var t=e.replace(et,tt);return function(e){return e.getAttribute("id")===t}}):(i.find.ID=function(e,n){if(typeof n.getElementById!==A&&!d){var r=n.getElementById(e);return r?r.id===e||typeof r.getAttributeNode!==A&&r.getAttributeNode("id").value===e?[r]:t:[]}},i.filter.ID=function(e){var t=e.replace(et,tt);return function(e){var n=typeof e.getAttributeNode!==A&&e.getAttributeNode("id");return n&&n.value===t}}),i.find.TAG=T.tagNameNoComments?function(e,n){return typeof n.getElementsByTagName!==A?n.getElementsByTagName(e):t}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},i.find.NAME=T.getByName&&function(e,n){return typeof n.getElementsByName!==A?n.getElementsByName(name):t},i.find.CLASS=T.getByClassName&&function(e,n){return typeof n.getElementsByClassName===A||d?t:n.getElementsByClassName(e)},g=[],h=[":focus"],(T.qsa=rt(n.querySelectorAll))&&(at(function(e){e.innerHTML="<select><option selected=''></option></select>",e.querySelectorAll("[selected]").length||h.push("\\["+_+"*(?:checked|disabled|ismap|multiple|readonly|selected|value)"),e.querySelectorAll(":checked").length||h.push(":checked")}),at(function(e){e.innerHTML="<input type='hidden' i=''/>",e.querySelectorAll("[i^='']").length&&h.push("[*^$]="+_+"*(?:\"\"|'')"),e.querySelectorAll(":enabled").length||h.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),h.push(",.*:")})),(T.matchesSelector=rt(m=f.matchesSelector||f.mozMatchesSelector||f.webkitMatchesSelector||f.oMatchesSelector||f.msMatchesSelector))&&at(function(e){T.disconnectedMatch=m.call(e,"div"),m.call(e,"[s!='']:x"),g.push("!=",R)}),h=RegExp(h.join("|")),g=RegExp(g.join("|")),y=rt(f.contains)||f.compareDocumentPosition?function(e,t){var n=9===e.nodeType?e.documentElement:e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return!0;return!1},v=f.compareDocumentPosition?function(e,t){var r;return e===t?(u=!0,0):(r=t.compareDocumentPosition&&e.compareDocumentPosition&&e.compareDocumentPosition(t))?1&r||e.parentNode&&11===e.parentNode.nodeType?e===n||y(w,e)?-1:t===n||y(w,t)?1:0:4&r?-1:1:e.compareDocumentPosition?-1:1}:function(e,t){var r,i=0,o=e.parentNode,a=t.parentNode,s=[e],l=[t];if(e===t)return u=!0,0;if(!o||!a)return e===n?-1:t===n?1:o?-1:a?1:0;if(o===a)return ut(e,t);r=e;while(r=r.parentNode)s.unshift(r);r=t;while(r=r.parentNode)l.unshift(r);while(s[i]===l[i])i++;return i?ut(s[i],l[i]):s[i]===w?-1:l[i]===w?1:0},u=!1,[0,0].sort(v),T.detectDuplicates=u,p):p},st.matches=function(e,t){return st(e,null,null,t)},st.matchesSelector=function(e,t){if((e.ownerDocument||e)!==p&&c(e),t=t.replace(Z,"='$1']"),!(!T.matchesSelector||d||g&&g.test(t)||h.test(t)))try{var n=m.call(e,t);if(n||T.disconnectedMatch||e.document&&11!==e.document.nodeType)return n}catch(r){}return st(t,p,null,[e]).length>0},st.contains=function(e,t){return(e.ownerDocument||e)!==p&&c(e),y(e,t)},st.attr=function(e,t){var n;return(e.ownerDocument||e)!==p&&c(e),d||(t=t.toLowerCase()),(n=i.attrHandle[t])?n(e):d||T.attributes?e.getAttribute(t):((n=e.getAttributeNode(t))||e.getAttribute(t))&&e[t]===!0?t:n&&n.specified?n.value:null},st.error=function(e){throw Error("Syntax error, unrecognized expression: "+e)},st.uniqueSort=function(e){var t,n=[],r=1,i=0;if(u=!T.detectDuplicates,e.sort(v),u){for(;t=e[r];r++)t===e[r-1]&&(i=n.push(r));while(i--)e.splice(n[i],1)}return e};function ut(e,t){var n=t&&e,r=n&&(~t.sourceIndex||j)-(~e.sourceIndex||j);if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return-1;return e?1:-1}function lt(e){return function(t){var n=t.nodeName.toLowerCase();return"input"===n&&t.type===e}}function ct(e){return function(t){var n=t.nodeName.toLowerCase();return("input"===n||"button"===n)&&t.type===e}}function pt(e){return ot(function(t){return t=+t,ot(function(n,r){var i,o=e([],n.length,t),a=o.length;while(a--)n[i=o[a]]&&(n[i]=!(r[i]=n[i]))})})}o=st.getText=function(e){var t,n="",r=0,i=e.nodeType;if(i){if(1===i||9===i||11===i){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=o(e)}else if(3===i||4===i)return e.nodeValue}else for(;t=e[r];r++)n+=o(t);return n},i=st.selectors={cacheLength:50,createPseudo:ot,match:U,find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(et,tt),e[3]=(e[4]||e[5]||"").replace(et,tt),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||st.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&st.error(e[0]),e},PSEUDO:function(e){var t,n=!e[5]&&e[2];return U.CHILD.test(e[0])?null:(e[4]?e[2]=e[4]:n&&z.test(n)&&(t=ft(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){return"*"===e?function(){return!0}:(e=e.replace(et,tt).toLowerCase(),function(t){return t.nodeName&&t.nodeName.toLowerCase()===e})},CLASS:function(e){var t=k[e+" "];return t||(t=RegExp("(^|"+_+")"+e+"("+_+"|$)"))&&k(e,function(e){return t.test(e.className||typeof e.getAttribute!==A&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=st.attr(r,e);return null==i?"!="===t:t?(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.slice(-n.length)===n:"~="===t?(" "+i+" ").indexOf(n)>-1:"|="===t?i===n||i.slice(0,n.length+1)===n+"-":!1):!0}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),a="last"!==e.slice(-4),s="of-type"===t;return 1===r&&0===i?function(e){return!!e.parentNode}:function(t,n,u){var l,c,p,f,d,h,g=o!==a?"nextSibling":"previousSibling",m=t.parentNode,y=s&&t.nodeName.toLowerCase(),v=!u&&!s;if(m){if(o){while(g){p=t;while(p=p[g])if(s?p.nodeName.toLowerCase()===y:1===p.nodeType)return!1;h=g="only"===e&&!h&&"nextSibling"}return!0}if(h=[a?m.firstChild:m.lastChild],a&&v){c=m[x]||(m[x]={}),l=c[e]||[],d=l[0]===N&&l[1],f=l[0]===N&&l[2],p=d&&m.childNodes[d];while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if(1===p.nodeType&&++f&&p===t){c[e]=[N,d,f];break}}else if(v&&(l=(t[x]||(t[x]={}))[e])&&l[0]===N)f=l[1];else while(p=++d&&p&&p[g]||(f=d=0)||h.pop())if((s?p.nodeName.toLowerCase()===y:1===p.nodeType)&&++f&&(v&&((p[x]||(p[x]={}))[e]=[N,f]),p===t))break;return f-=i,f===r||0===f%r&&f/r>=0}}},PSEUDO:function(e,t){var n,r=i.pseudos[e]||i.setFilters[e.toLowerCase()]||st.error("unsupported pseudo: "+e);return r[x]?r(t):r.length>1?(n=[e,e,"",t],i.setFilters.hasOwnProperty(e.toLowerCase())?ot(function(e,n){var i,o=r(e,t),a=o.length;while(a--)i=M.call(e,o[a]),e[i]=!(n[i]=o[a])}):function(e){return r(e,0,n)}):r}},pseudos:{not:ot(function(e){var t=[],n=[],r=s(e.replace(W,"$1"));return r[x]?ot(function(e,t,n,i){var o,a=r(e,null,i,[]),s=e.length;while(s--)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),!n.pop()}}),has:ot(function(e){return function(t){return st(e,t).length>0}}),contains:ot(function(e){return function(t){return(t.textContent||t.innerText||o(t)).indexOf(e)>-1}}),lang:ot(function(e){return X.test(e||"")||st.error("unsupported lang: "+e),e=e.replace(et,tt).toLowerCase(),function(t){var n;do if(n=d?t.getAttribute("xml:lang")||t.getAttribute("lang"):t.lang)return n=n.toLowerCase(),n===e||0===n.indexOf(e+"-");while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===f},focus:function(e){return e===p.activeElement&&(!p.hasFocus||p.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:function(e){return e.disabled===!1},disabled:function(e){return e.disabled===!0},checked:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,e.selected===!0},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeName>"@"||3===e.nodeType||4===e.nodeType)return!1;return!0},parent:function(e){return!i.pseudos.empty(e)},header:function(e){return Q.test(e.nodeName)},input:function(e){return G.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return"input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return"input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||t.toLowerCase()===e.type)},first:pt(function(){return[0]}),last:pt(function(e,t){return[t-1]}),eq:pt(function(e,t,n){return[0>n?n+t:n]}),even:pt(function(e,t){var n=0;for(;t>n;n+=2)e.push(n);return e}),odd:pt(function(e,t){var n=1;for(;t>n;n+=2)e.push(n);return e}),lt:pt(function(e,t,n){var r=0>n?n+t:n;for(;--r>=0;)e.push(r);return e}),gt:pt(function(e,t,n){var r=0>n?n+t:n;for(;t>++r;)e.push(r);return e})}};for(n in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})i.pseudos[n]=lt(n);for(n in{submit:!0,reset:!0})i.pseudos[n]=ct(n);function ft(e,t){var n,r,o,a,s,u,l,c=E[e+" "];if(c)return t?0:c.slice(0);s=e,u=[],l=i.preFilter;while(s){(!n||(r=$.exec(s)))&&(r&&(s=s.slice(r[0].length)||s),u.push(o=[])),n=!1,(r=I.exec(s))&&(n=r.shift(),o.push({value:n,type:r[0].replace(W," ")}),s=s.slice(n.length));for(a in i.filter)!(r=U[a].exec(s))||l[a]&&!(r=l[a](r))||(n=r.shift(),o.push({value:n,type:a,matches:r}),s=s.slice(n.length));if(!n)break}return t?s.length:s?st.error(e):E(e,u).slice(0)}function dt(e){var t=0,n=e.length,r="";for(;n>t;t++)r+=e[t].value;return r}function ht(e,t,n){var i=t.dir,o=n&&"parentNode"===i,a=C++;return t.first?function(t,n,r){while(t=t[i])if(1===t.nodeType||o)return e(t,n,r)}:function(t,n,s){var u,l,c,p=N+" "+a;if(s){while(t=t[i])if((1===t.nodeType||o)&&e(t,n,s))return!0}else while(t=t[i])if(1===t.nodeType||o)if(c=t[x]||(t[x]={}),(l=c[i])&&l[0]===p){if((u=l[1])===!0||u===r)return u===!0}else if(l=c[i]=[p],l[1]=e(t,n,s)||r,l[1]===!0)return!0}}function gt(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return!1;return!0}:e[0]}function mt(e,t,n,r,i){var o,a=[],s=0,u=e.length,l=null!=t;for(;u>s;s++)(o=e[s])&&(!n||n(o,r,i))&&(a.push(o),l&&t.push(s));return a}function yt(e,t,n,r,i,o){return r&&!r[x]&&(r=yt(r)),i&&!i[x]&&(i=yt(i,o)),ot(function(o,a,s,u){var l,c,p,f=[],d=[],h=a.length,g=o||xt(t||"*",s.nodeType?[s]:s,[]),m=!e||!o&&t?g:mt(g,f,e,s,u),y=n?i||(o?e:h||r)?[]:a:m;if(n&&n(m,y,s,u),r){l=mt(y,d),r(l,[],s,u),c=l.length;while(c--)(p=l[c])&&(y[d[c]]=!(m[d[c]]=p))}if(o){if(i||e){if(i){l=[],c=y.length;while(c--)(p=y[c])&&l.push(m[c]=p);i(null,y=[],l,u)}c=y.length;while(c--)(p=y[c])&&(l=i?M.call(o,p):f[c])>-1&&(o[l]=!(a[l]=p))}}else y=mt(y===a?y.splice(h,y.length):y),i?i(null,a,y,u):H.apply(a,y)})}function vt(e){var t,n,r,o=e.length,a=i.relative[e[0].type],s=a||i.relative[" "],u=a?1:0,c=ht(function(e){return e===t},s,!0),p=ht(function(e){return M.call(t,e)>-1},s,!0),f=[function(e,n,r){return!a&&(r||n!==l)||((t=n).nodeType?c(e,n,r):p(e,n,r))}];for(;o>u;u++)if(n=i.relative[e[u].type])f=[ht(gt(f),n)];else{if(n=i.filter[e[u].type].apply(null,e[u].matches),n[x]){for(r=++u;o>r;r++)if(i.relative[e[r].type])break;return yt(u>1&&gt(f),u>1&&dt(e.slice(0,u-1)).replace(W,"$1"),n,r>u&&vt(e.slice(u,r)),o>r&&vt(e=e.slice(r)),o>r&&dt(e))}f.push(n)}return gt(f)}function bt(e,t){var n=0,o=t.length>0,a=e.length>0,s=function(s,u,c,f,d){var h,g,m,y=[],v=0,b="0",x=s&&[],w=null!=d,T=l,C=s||a&&i.find.TAG("*",d&&u.parentNode||u),k=N+=null==T?1:Math.random()||.1;for(w&&(l=u!==p&&u,r=n);null!=(h=C[b]);b++){if(a&&h){g=0;while(m=e[g++])if(m(h,u,c)){f.push(h);break}w&&(N=k,r=++n)}o&&((h=!m&&h)&&v--,s&&x.push(h))}if(v+=b,o&&b!==v){g=0;while(m=t[g++])m(x,y,u,c);if(s){if(v>0)while(b--)x[b]||y[b]||(y[b]=L.call(f));y=mt(y)}H.apply(f,y),w&&!s&&y.length>0&&v+t.length>1&&st.uniqueSort(f)}return w&&(N=k,l=T),x};return o?ot(s):s}s=st.compile=function(e,t){var n,r=[],i=[],o=S[e+" "];if(!o){t||(t=ft(e)),n=t.length;while(n--)o=vt(t[n]),o[x]?r.push(o):i.push(o);o=S(e,bt(i,r))}return o};function xt(e,t,n){var r=0,i=t.length;for(;i>r;r++)st(e,t[r],n);return n}function wt(e,t,n,r){var o,a,u,l,c,p=ft(e);if(!r&&1===p.length){if(a=p[0]=p[0].slice(0),a.length>2&&"ID"===(u=a[0]).type&&9===t.nodeType&&!d&&i.relative[a[1].type]){if(t=i.find.ID(u.matches[0].replace(et,tt),t)[0],!t)return n;e=e.slice(a.shift().value.length)}o=U.needsContext.test(e)?0:a.length;while(o--){if(u=a[o],i.relative[l=u.type])break;if((c=i.find[l])&&(r=c(u.matches[0].replace(et,tt),V.test(a[0].type)&&t.parentNode||t))){if(a.splice(o,1),e=r.length&&dt(a),!e)return H.apply(n,q.call(r,0)),n;break}}}return s(e,p)(r,t,d,n,V.test(e)),n}i.pseudos.nth=i.pseudos.eq;function Tt(){}i.filters=Tt.prototype=i.pseudos,i.setFilters=new Tt,c(),st.attr=b.attr,b.find=st,b.expr=st.selectors,b.expr[":"]=b.expr.pseudos,b.unique=st.uniqueSort,b.text=st.getText,b.isXMLDoc=st.isXML,b.contains=st.contains}(e);var at=/Until$/,st=/^(?:parents|prev(?:Until|All))/,ut=/^.[^:#\[\.,]*$/,lt=b.expr.match.needsContext,ct={children:!0,contents:!0,next:!0,prev:!0};b.fn.extend({find:function(e){var t,n,r,i=this.length;if("string"!=typeof e)return r=this,this.pushStack(b(e).filter(function(){for(t=0;i>t;t++)if(b.contains(r[t],this))return!0}));for(n=[],t=0;i>t;t++)b.find(e,this[t],n);return n=this.pushStack(i>1?b.unique(n):n),n.selector=(this.selector?this.selector+" ":"")+e,n},has:function(e){var t,n=b(e,this),r=n.length;return this.filter(function(){for(t=0;r>t;t++)if(b.contains(this,n[t]))return!0})},not:function(e){return this.pushStack(ft(this,e,!1))},filter:function(e){return this.pushStack(ft(this,e,!0))},is:function(e){return!!e&&("string"==typeof e?lt.test(e)?b(e,this.context).index(this[0])>=0:b.filter(e,this).length>0:this.filter(e).length>0)},closest:function(e,t){var n,r=0,i=this.length,o=[],a=lt.test(e)||"string"!=typeof e?b(e,t||this.context):0;for(;i>r;r++){n=this[r];while(n&&n.ownerDocument&&n!==t&&11!==n.nodeType){if(a?a.index(n)>-1:b.find.matchesSelector(n,e)){o.push(n);break}n=n.parentNode}}return this.pushStack(o.length>1?b.unique(o):o)},index:function(e){return e?"string"==typeof e?b.inArray(this[0],b(e)):b.inArray(e.jquery?e[0]:e,this):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(e,t){var n="string"==typeof e?b(e,t):b.makeArray(e&&e.nodeType?[e]:e),r=b.merge(this.get(),n);return this.pushStack(b.unique(r))},addBack:function(e){return this.add(null==e?this.prevObject:this.prevObject.filter(e))}}),b.fn.andSelf=b.fn.addBack;function pt(e,t){do e=e[t];while(e&&1!==e.nodeType);return e}b.each({parent:function(e){var t=e.parentNode;return t&&11!==t.nodeType?t:null},parents:function(e){return b.dir(e,"parentNode")},parentsUntil:function(e,t,n){return b.dir(e,"parentNode",n)},next:function(e){return pt(e,"nextSibling")},prev:function(e){return pt(e,"previousSibling")},nextAll:function(e){return b.dir(e,"nextSibling")},prevAll:function(e){return b.dir(e,"previousSibling")},nextUntil:function(e,t,n){return b.dir(e,"nextSibling",n)},prevUntil:function(e,t,n){return b.dir(e,"previousSibling",n)},siblings:function(e){return b.sibling((e.parentNode||{}).firstChild,e)},children:function(e){return b.sibling(e.firstChild)},contents:function(e){return b.nodeName(e,"iframe")?e.contentDocument||e.contentWindow.document:b.merge([],e.childNodes)}},function(e,t){b.fn[e]=function(n,r){var i=b.map(this,t,n);return at.test(e)||(r=n),r&&"string"==typeof r&&(i=b.filter(r,i)),i=this.length>1&&!ct[e]?b.unique(i):i,this.length>1&&st.test(e)&&(i=i.reverse()),this.pushStack(i)}}),b.extend({filter:function(e,t,n){return n&&(e=":not("+e+")"),1===t.length?b.find.matchesSelector(t[0],e)?[t[0]]:[]:b.find.matches(e,t)},dir:function(e,n,r){var i=[],o=e[n];while(o&&9!==o.nodeType&&(r===t||1!==o.nodeType||!b(o).is(r)))1===o.nodeType&&i.push(o),o=o[n];return i},sibling:function(e,t){var n=[];for(;e;e=e.nextSibling)1===e.nodeType&&e!==t&&n.push(e);return n}});function ft(e,t,n){if(t=t||0,b.isFunction(t))return b.grep(e,function(e,r){var i=!!t.call(e,r,e);return i===n});if(t.nodeType)return b.grep(e,function(e){return e===t===n});if("string"==typeof t){var r=b.grep(e,function(e){return 1===e.nodeType});if(ut.test(t))return b.filter(t,r,!n);t=b.filter(t,r)}return b.grep(e,function(e){return b.inArray(e,t)>=0===n})}function dt(e){var t=ht.split("|"),n=e.createDocumentFragment();if(n.createElement)while(t.length)n.createElement(t.pop());return n}var ht="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",gt=/ jQuery\d+="(?:null|\d+)"/g,mt=RegExp("<(?:"+ht+")[\\s/>]","i"),yt=/^\s+/,vt=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bt=/<([\w:]+)/,xt=/<tbody/i,wt=/<|&#?\w+;/,Tt=/<(?:script|style|link)/i,Nt=/^(?:checkbox|radio)$/i,Ct=/checked\s*(?:[^=]|=\s*.checked.)/i,kt=/^$|\/(?:java|ecma)script/i,Et=/^true\/(.*)/,St=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,At={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],area:[1,"<map>","</map>"],param:[1,"<object>","</object>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:b.support.htmlSerialize?[0,"",""]:[1,"X<div>","</div>"]},jt=dt(o),Dt=jt.appendChild(o.createElement("div"));At.optgroup=At.option,At.tbody=At.tfoot=At.colgroup=At.caption=At.thead,At.th=At.td,b.fn.extend({text:function(e){return b.access(this,function(e){return e===t?b.text(this):this.empty().append((this[0]&&this[0].ownerDocument||o).createTextNode(e))},null,e,arguments.length)},wrapAll:function(e){if(b.isFunction(e))return this.each(function(t){b(this).wrapAll(e.call(this,t))});if(this[0]){var t=b(e,this[0].ownerDocument).eq(0).clone(!0);this[0].parentNode&&t.insertBefore(this[0]),t.map(function(){var e=this;while(e.firstChild&&1===e.firstChild.nodeType)e=e.firstChild;return e}).append(this)}return this},wrapInner:function(e){return b.isFunction(e)?this.each(function(t){b(this).wrapInner(e.call(this,t))}):this.each(function(){var t=b(this),n=t.contents();n.length?n.wrapAll(e):t.append(e)})},wrap:function(e){var t=b.isFunction(e);return this.each(function(n){b(this).wrapAll(t?e.call(this,n):e)})},unwrap:function(){return this.parent().each(function(){b.nodeName(this,"body")||b(this).replaceWith(this.childNodes)}).end()},append:function(){return this.domManip(arguments,!0,function(e){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&this.appendChild(e)})},prepend:function(){return this.domManip(arguments,!0,function(e){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&this.insertBefore(e,this.firstChild)})},before:function(){return this.domManip(arguments,!1,function(e){this.parentNode&&this.parentNode.insertBefore(e,this)})},after:function(){return this.domManip(arguments,!1,function(e){this.parentNode&&this.parentNode.insertBefore(e,this.nextSibling)})},remove:function(e,t){var n,r=0;for(;null!=(n=this[r]);r++)(!e||b.filter(e,[n]).length>0)&&(t||1!==n.nodeType||b.cleanData(Ot(n)),n.parentNode&&(t&&b.contains(n.ownerDocument,n)&&Mt(Ot(n,"script")),n.parentNode.removeChild(n)));return this},empty:function(){var e,t=0;for(;null!=(e=this[t]);t++){1===e.nodeType&&b.cleanData(Ot(e,!1));while(e.firstChild)e.removeChild(e.firstChild);e.options&&b.nodeName(e,"select")&&(e.options.length=0)}return this},clone:function(e,t){return e=null==e?!1:e,t=null==t?e:t,this.map(function(){return b.clone(this,e,t)})},html:function(e){return b.access(this,function(e){var n=this[0]||{},r=0,i=this.length;if(e===t)return 1===n.nodeType?n.innerHTML.replace(gt,""):t;if(!("string"!=typeof e||Tt.test(e)||!b.support.htmlSerialize&&mt.test(e)||!b.support.leadingWhitespace&&yt.test(e)||At[(bt.exec(e)||["",""])[1].toLowerCase()])){e=e.replace(vt,"<$1></$2>");try{for(;i>r;r++)n=this[r]||{},1===n.nodeType&&(b.cleanData(Ot(n,!1)),n.innerHTML=e);n=0}catch(o){}}n&&this.empty().append(e)},null,e,arguments.length)},replaceWith:function(e){var t=b.isFunction(e);return t||"string"==typeof e||(e=b(e).not(this).detach()),this.domManip([e],!0,function(e){var t=this.nextSibling,n=this.parentNode;n&&(b(this).remove(),n.insertBefore(e,t))})},detach:function(e){return this.remove(e,!0)},domManip:function(e,n,r){e=f.apply([],e);var i,o,a,s,u,l,c=0,p=this.length,d=this,h=p-1,g=e[0],m=b.isFunction(g);if(m||!(1>=p||"string"!=typeof g||b.support.checkClone)&&Ct.test(g))return this.each(function(i){var o=d.eq(i);m&&(e[0]=g.call(this,i,n?o.html():t)),o.domManip(e,n,r)});if(p&&(l=b.buildFragment(e,this[0].ownerDocument,!1,this),i=l.firstChild,1===l.childNodes.length&&(l=i),i)){for(n=n&&b.nodeName(i,"tr"),s=b.map(Ot(l,"script"),Ht),a=s.length;p>c;c++)o=l,c!==h&&(o=b.clone(o,!0,!0),a&&b.merge(s,Ot(o,"script"))),r.call(n&&b.nodeName(this[c],"table")?Lt(this[c],"tbody"):this[c],o,c);if(a)for(u=s[s.length-1].ownerDocument,b.map(s,qt),c=0;a>c;c++)o=s[c],kt.test(o.type||"")&&!b._data(o,"globalEval")&&b.contains(u,o)&&(o.src?b.ajax({url:o.src,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0}):b.globalEval((o.text||o.textContent||o.innerHTML||"").replace(St,"")));l=i=null}return this}});function Lt(e,t){return e.getElementsByTagName(t)[0]||e.appendChild(e.ownerDocument.createElement(t))}function Ht(e){var t=e.getAttributeNode("type");return e.type=(t&&t.specified)+"/"+e.type,e}function qt(e){var t=Et.exec(e.type);return t?e.type=t[1]:e.removeAttribute("type"),e}function Mt(e,t){var n,r=0;for(;null!=(n=e[r]);r++)b._data(n,"globalEval",!t||b._data(t[r],"globalEval"))}function _t(e,t){if(1===t.nodeType&&b.hasData(e)){var n,r,i,o=b._data(e),a=b._data(t,o),s=o.events;if(s){delete a.handle,a.events={};for(n in s)for(r=0,i=s[n].length;i>r;r++)b.event.add(t,n,s[n][r])}a.data&&(a.data=b.extend({},a.data))}}function Ft(e,t){var n,r,i;if(1===t.nodeType){if(n=t.nodeName.toLowerCase(),!b.support.noCloneEvent&&t[b.expando]){i=b._data(t);for(r in i.events)b.removeEvent(t,r,i.handle);t.removeAttribute(b.expando)}"script"===n&&t.text!==e.text?(Ht(t).text=e.text,qt(t)):"object"===n?(t.parentNode&&(t.outerHTML=e.outerHTML),b.support.html5Clone&&e.innerHTML&&!b.trim(t.innerHTML)&&(t.innerHTML=e.innerHTML)):"input"===n&&Nt.test(e.type)?(t.defaultChecked=t.checked=e.checked,t.value!==e.value&&(t.value=e.value)):"option"===n?t.defaultSelected=t.selected=e.defaultSelected:("input"===n||"textarea"===n)&&(t.defaultValue=e.defaultValue)}}b.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(e,t){b.fn[e]=function(e){var n,r=0,i=[],o=b(e),a=o.length-1;for(;a>=r;r++)n=r===a?this:this.clone(!0),b(o[r])[t](n),d.apply(i,n.get());return this.pushStack(i)}});function Ot(e,n){var r,o,a=0,s=typeof e.getElementsByTagName!==i?e.getElementsByTagName(n||"*"):typeof e.querySelectorAll!==i?e.querySelectorAll(n||"*"):t;if(!s)for(s=[],r=e.childNodes||e;null!=(o=r[a]);a++)!n||b.nodeName(o,n)?s.push(o):b.merge(s,Ot(o,n));return n===t||n&&b.nodeName(e,n)?b.merge([e],s):s}function Bt(e){Nt.test(e.type)&&(e.defaultChecked=e.checked)}b.extend({clone:function(e,t,n){var r,i,o,a,s,u=b.contains(e.ownerDocument,e);if(b.support.html5Clone||b.isXMLDoc(e)||!mt.test("<"+e.nodeName+">")?o=e.cloneNode(!0):(Dt.innerHTML=e.outerHTML,Dt.removeChild(o=Dt.firstChild)),!(b.support.noCloneEvent&&b.support.noCloneChecked||1!==e.nodeType&&11!==e.nodeType||b.isXMLDoc(e)))for(r=Ot(o),s=Ot(e),a=0;null!=(i=s[a]);++a)r[a]&&Ft(i,r[a]);if(t)if(n)for(s=s||Ot(e),r=r||Ot(o),a=0;null!=(i=s[a]);a++)_t(i,r[a]);else _t(e,o);return r=Ot(o,"script"),r.length>0&&Mt(r,!u&&Ot(e,"script")),r=s=i=null,o},buildFragment:function(e,t,n,r){var i,o,a,s,u,l,c,p=e.length,f=dt(t),d=[],h=0;for(;p>h;h++)if(o=e[h],o||0===o)if("object"===b.type(o))b.merge(d,o.nodeType?[o]:o);else if(wt.test(o)){s=s||f.appendChild(t.createElement("div")),u=(bt.exec(o)||["",""])[1].toLowerCase(),c=At[u]||At._default,s.innerHTML=c[1]+o.replace(vt,"<$1></$2>")+c[2],i=c[0];while(i--)s=s.lastChild;if(!b.support.leadingWhitespace&&yt.test(o)&&d.push(t.createTextNode(yt.exec(o)[0])),!b.support.tbody){o="table"!==u||xt.test(o)?"<table>"!==c[1]||xt.test(o)?0:s:s.firstChild,i=o&&o.childNodes.length;while(i--)b.nodeName(l=o.childNodes[i],"tbody")&&!l.childNodes.length&&o.removeChild(l)
}b.merge(d,s.childNodes),s.textContent="";while(s.firstChild)s.removeChild(s.firstChild);s=f.lastChild}else d.push(t.createTextNode(o));s&&f.removeChild(s),b.support.appendChecked||b.grep(Ot(d,"input"),Bt),h=0;while(o=d[h++])if((!r||-1===b.inArray(o,r))&&(a=b.contains(o.ownerDocument,o),s=Ot(f.appendChild(o),"script"),a&&Mt(s),n)){i=0;while(o=s[i++])kt.test(o.type||"")&&n.push(o)}return s=null,f},cleanData:function(e,t){var n,r,o,a,s=0,u=b.expando,l=b.cache,p=b.support.deleteExpando,f=b.event.special;for(;null!=(n=e[s]);s++)if((t||b.acceptData(n))&&(o=n[u],a=o&&l[o])){if(a.events)for(r in a.events)f[r]?b.event.remove(n,r):b.removeEvent(n,r,a.handle);l[o]&&(delete l[o],p?delete n[u]:typeof n.removeAttribute!==i?n.removeAttribute(u):n[u]=null,c.push(o))}}});var Pt,Rt,Wt,$t=/alpha\([^)]*\)/i,It=/opacity\s*=\s*([^)]*)/,zt=/^(top|right|bottom|left)$/,Xt=/^(none|table(?!-c[ea]).+)/,Ut=/^margin/,Vt=RegExp("^("+x+")(.*)$","i"),Yt=RegExp("^("+x+")(?!px)[a-z%]+$","i"),Jt=RegExp("^([+-])=("+x+")","i"),Gt={BODY:"block"},Qt={position:"absolute",visibility:"hidden",display:"block"},Kt={letterSpacing:0,fontWeight:400},Zt=["Top","Right","Bottom","Left"],en=["Webkit","O","Moz","ms"];function tn(e,t){if(t in e)return t;var n=t.charAt(0).toUpperCase()+t.slice(1),r=t,i=en.length;while(i--)if(t=en[i]+n,t in e)return t;return r}function nn(e,t){return e=t||e,"none"===b.css(e,"display")||!b.contains(e.ownerDocument,e)}function rn(e,t){var n,r,i,o=[],a=0,s=e.length;for(;s>a;a++)r=e[a],r.style&&(o[a]=b._data(r,"olddisplay"),n=r.style.display,t?(o[a]||"none"!==n||(r.style.display=""),""===r.style.display&&nn(r)&&(o[a]=b._data(r,"olddisplay",un(r.nodeName)))):o[a]||(i=nn(r),(n&&"none"!==n||!i)&&b._data(r,"olddisplay",i?n:b.css(r,"display"))));for(a=0;s>a;a++)r=e[a],r.style&&(t&&"none"!==r.style.display&&""!==r.style.display||(r.style.display=t?o[a]||"":"none"));return e}b.fn.extend({css:function(e,n){return b.access(this,function(e,n,r){var i,o,a={},s=0;if(b.isArray(n)){for(o=Rt(e),i=n.length;i>s;s++)a[n[s]]=b.css(e,n[s],!1,o);return a}return r!==t?b.style(e,n,r):b.css(e,n)},e,n,arguments.length>1)},show:function(){return rn(this,!0)},hide:function(){return rn(this)},toggle:function(e){var t="boolean"==typeof e;return this.each(function(){(t?e:nn(this))?b(this).show():b(this).hide()})}}),b.extend({cssHooks:{opacity:{get:function(e,t){if(t){var n=Wt(e,"opacity");return""===n?"1":n}}}},cssNumber:{columnCount:!0,fillOpacity:!0,fontWeight:!0,lineHeight:!0,opacity:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":b.support.cssFloat?"cssFloat":"styleFloat"},style:function(e,n,r,i){if(e&&3!==e.nodeType&&8!==e.nodeType&&e.style){var o,a,s,u=b.camelCase(n),l=e.style;if(n=b.cssProps[u]||(b.cssProps[u]=tn(l,u)),s=b.cssHooks[n]||b.cssHooks[u],r===t)return s&&"get"in s&&(o=s.get(e,!1,i))!==t?o:l[n];if(a=typeof r,"string"===a&&(o=Jt.exec(r))&&(r=(o[1]+1)*o[2]+parseFloat(b.css(e,n)),a="number"),!(null==r||"number"===a&&isNaN(r)||("number"!==a||b.cssNumber[u]||(r+="px"),b.support.clearCloneStyle||""!==r||0!==n.indexOf("background")||(l[n]="inherit"),s&&"set"in s&&(r=s.set(e,r,i))===t)))try{l[n]=r}catch(c){}}},css:function(e,n,r,i){var o,a,s,u=b.camelCase(n);return n=b.cssProps[u]||(b.cssProps[u]=tn(e.style,u)),s=b.cssHooks[n]||b.cssHooks[u],s&&"get"in s&&(a=s.get(e,!0,r)),a===t&&(a=Wt(e,n,i)),"normal"===a&&n in Kt&&(a=Kt[n]),""===r||r?(o=parseFloat(a),r===!0||b.isNumeric(o)?o||0:a):a},swap:function(e,t,n,r){var i,o,a={};for(o in t)a[o]=e.style[o],e.style[o]=t[o];i=n.apply(e,r||[]);for(o in t)e.style[o]=a[o];return i}}),e.getComputedStyle?(Rt=function(t){return e.getComputedStyle(t,null)},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),u=s?s.getPropertyValue(n)||s[n]:t,l=e.style;return s&&(""!==u||b.contains(e.ownerDocument,e)||(u=b.style(e,n)),Yt.test(u)&&Ut.test(n)&&(i=l.width,o=l.minWidth,a=l.maxWidth,l.minWidth=l.maxWidth=l.width=u,u=s.width,l.width=i,l.minWidth=o,l.maxWidth=a)),u}):o.documentElement.currentStyle&&(Rt=function(e){return e.currentStyle},Wt=function(e,n,r){var i,o,a,s=r||Rt(e),u=s?s[n]:t,l=e.style;return null==u&&l&&l[n]&&(u=l[n]),Yt.test(u)&&!zt.test(n)&&(i=l.left,o=e.runtimeStyle,a=o&&o.left,a&&(o.left=e.currentStyle.left),l.left="fontSize"===n?"1em":u,u=l.pixelLeft+"px",l.left=i,a&&(o.left=a)),""===u?"auto":u});function on(e,t,n){var r=Vt.exec(t);return r?Math.max(0,r[1]-(n||0))+(r[2]||"px"):t}function an(e,t,n,r,i){var o=n===(r?"border":"content")?4:"width"===t?1:0,a=0;for(;4>o;o+=2)"margin"===n&&(a+=b.css(e,n+Zt[o],!0,i)),r?("content"===n&&(a-=b.css(e,"padding"+Zt[o],!0,i)),"margin"!==n&&(a-=b.css(e,"border"+Zt[o]+"Width",!0,i))):(a+=b.css(e,"padding"+Zt[o],!0,i),"padding"!==n&&(a+=b.css(e,"border"+Zt[o]+"Width",!0,i)));return a}function sn(e,t,n){var r=!0,i="width"===t?e.offsetWidth:e.offsetHeight,o=Rt(e),a=b.support.boxSizing&&"border-box"===b.css(e,"boxSizing",!1,o);if(0>=i||null==i){if(i=Wt(e,t,o),(0>i||null==i)&&(i=e.style[t]),Yt.test(i))return i;r=a&&(b.support.boxSizingReliable||i===e.style[t]),i=parseFloat(i)||0}return i+an(e,t,n||(a?"border":"content"),r,o)+"px"}function un(e){var t=o,n=Gt[e];return n||(n=ln(e,t),"none"!==n&&n||(Pt=(Pt||b("<iframe frameborder='0' width='0' height='0'/>").css("cssText","display:block !important")).appendTo(t.documentElement),t=(Pt[0].contentWindow||Pt[0].contentDocument).document,t.write("<!doctype html><html><body>"),t.close(),n=ln(e,t),Pt.detach()),Gt[e]=n),n}function ln(e,t){var n=b(t.createElement(e)).appendTo(t.body),r=b.css(n[0],"display");return n.remove(),r}b.each(["height","width"],function(e,n){b.cssHooks[n]={get:function(e,r,i){return r?0===e.offsetWidth&&Xt.test(b.css(e,"display"))?b.swap(e,Qt,function(){return sn(e,n,i)}):sn(e,n,i):t},set:function(e,t,r){var i=r&&Rt(e);return on(e,t,r?an(e,n,r,b.support.boxSizing&&"border-box"===b.css(e,"boxSizing",!1,i),i):0)}}}),b.support.opacity||(b.cssHooks.opacity={get:function(e,t){return It.test((t&&e.currentStyle?e.currentStyle.filter:e.style.filter)||"")?.01*parseFloat(RegExp.$1)+"":t?"1":""},set:function(e,t){var n=e.style,r=e.currentStyle,i=b.isNumeric(t)?"alpha(opacity="+100*t+")":"",o=r&&r.filter||n.filter||"";n.zoom=1,(t>=1||""===t)&&""===b.trim(o.replace($t,""))&&n.removeAttribute&&(n.removeAttribute("filter"),""===t||r&&!r.filter)||(n.filter=$t.test(o)?o.replace($t,i):o+" "+i)}}),b(function(){b.support.reliableMarginRight||(b.cssHooks.marginRight={get:function(e,n){return n?b.swap(e,{display:"inline-block"},Wt,[e,"marginRight"]):t}}),!b.support.pixelPosition&&b.fn.position&&b.each(["top","left"],function(e,n){b.cssHooks[n]={get:function(e,r){return r?(r=Wt(e,n),Yt.test(r)?b(e).position()[n]+"px":r):t}}})}),b.expr&&b.expr.filters&&(b.expr.filters.hidden=function(e){return 0>=e.offsetWidth&&0>=e.offsetHeight||!b.support.reliableHiddenOffsets&&"none"===(e.style&&e.style.display||b.css(e,"display"))},b.expr.filters.visible=function(e){return!b.expr.filters.hidden(e)}),b.each({margin:"",padding:"",border:"Width"},function(e,t){b.cssHooks[e+t]={expand:function(n){var r=0,i={},o="string"==typeof n?n.split(" "):[n];for(;4>r;r++)i[e+Zt[r]+t]=o[r]||o[r-2]||o[0];return i}},Ut.test(e)||(b.cssHooks[e+t].set=on)});var cn=/%20/g,pn=/\[\]$/,fn=/\r?\n/g,dn=/^(?:submit|button|image|reset|file)$/i,hn=/^(?:input|select|textarea|keygen)/i;b.fn.extend({serialize:function(){return b.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var e=b.prop(this,"elements");return e?b.makeArray(e):this}).filter(function(){var e=this.type;return this.name&&!b(this).is(":disabled")&&hn.test(this.nodeName)&&!dn.test(e)&&(this.checked||!Nt.test(e))}).map(function(e,t){var n=b(this).val();return null==n?null:b.isArray(n)?b.map(n,function(e){return{name:t.name,value:e.replace(fn,"\r\n")}}):{name:t.name,value:n.replace(fn,"\r\n")}}).get()}}),b.param=function(e,n){var r,i=[],o=function(e,t){t=b.isFunction(t)?t():null==t?"":t,i[i.length]=encodeURIComponent(e)+"="+encodeURIComponent(t)};if(n===t&&(n=b.ajaxSettings&&b.ajaxSettings.traditional),b.isArray(e)||e.jquery&&!b.isPlainObject(e))b.each(e,function(){o(this.name,this.value)});else for(r in e)gn(r,e[r],n,o);return i.join("&").replace(cn,"+")};function gn(e,t,n,r){var i;if(b.isArray(t))b.each(t,function(t,i){n||pn.test(e)?r(e,i):gn(e+"["+("object"==typeof i?t:"")+"]",i,n,r)});else if(n||"object"!==b.type(t))r(e,t);else for(i in t)gn(e+"["+i+"]",t[i],n,r)}b.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(e,t){b.fn[t]=function(e,n){return arguments.length>0?this.on(t,null,e,n):this.trigger(t)}}),b.fn.hover=function(e,t){return this.mouseenter(e).mouseleave(t||e)};var mn,yn,vn=b.now(),bn=/\?/,xn=/#.*$/,wn=/([?&])_=[^&]*/,Tn=/^(.*?):[ \t]*([^\r\n]*)\r?$/gm,Nn=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Cn=/^(?:GET|HEAD)$/,kn=/^\/\//,En=/^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,Sn=b.fn.load,An={},jn={},Dn="*/".concat("*");try{yn=a.href}catch(Ln){yn=o.createElement("a"),yn.href="",yn=yn.href}mn=En.exec(yn.toLowerCase())||[];function Hn(e){return function(t,n){"string"!=typeof t&&(n=t,t="*");var r,i=0,o=t.toLowerCase().match(w)||[];if(b.isFunction(n))while(r=o[i++])"+"===r[0]?(r=r.slice(1)||"*",(e[r]=e[r]||[]).unshift(n)):(e[r]=e[r]||[]).push(n)}}function qn(e,n,r,i){var o={},a=e===jn;function s(u){var l;return o[u]=!0,b.each(e[u]||[],function(e,u){var c=u(n,r,i);return"string"!=typeof c||a||o[c]?a?!(l=c):t:(n.dataTypes.unshift(c),s(c),!1)}),l}return s(n.dataTypes[0])||!o["*"]&&s("*")}function Mn(e,n){var r,i,o=b.ajaxSettings.flatOptions||{};for(i in n)n[i]!==t&&((o[i]?e:r||(r={}))[i]=n[i]);return r&&b.extend(!0,e,r),e}b.fn.load=function(e,n,r){if("string"!=typeof e&&Sn)return Sn.apply(this,arguments);var i,o,a,s=this,u=e.indexOf(" ");return u>=0&&(i=e.slice(u,e.length),e=e.slice(0,u)),b.isFunction(n)?(r=n,n=t):n&&"object"==typeof n&&(a="POST"),s.length>0&&b.ajax({url:e,type:a,dataType:"html",data:n}).done(function(e){o=arguments,s.html(i?b("<div>").append(b.parseHTML(e)).find(i):e)}).complete(r&&function(e,t){s.each(r,o||[e.responseText,t,e])}),this},b.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(e,t){b.fn[t]=function(e){return this.on(t,e)}}),b.each(["get","post"],function(e,n){b[n]=function(e,r,i,o){return b.isFunction(r)&&(o=o||i,i=r,r=t),b.ajax({url:e,type:n,dataType:o,data:r,success:i})}}),b.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:yn,type:"GET",isLocal:Nn.test(mn[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Dn,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText"},converters:{"* text":e.String,"text html":!0,"text json":b.parseJSON,"text xml":b.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(e,t){return t?Mn(Mn(e,b.ajaxSettings),t):Mn(b.ajaxSettings,e)},ajaxPrefilter:Hn(An),ajaxTransport:Hn(jn),ajax:function(e,n){"object"==typeof e&&(n=e,e=t),n=n||{};var r,i,o,a,s,u,l,c,p=b.ajaxSetup({},n),f=p.context||p,d=p.context&&(f.nodeType||f.jquery)?b(f):b.event,h=b.Deferred(),g=b.Callbacks("once memory"),m=p.statusCode||{},y={},v={},x=0,T="canceled",N={readyState:0,getResponseHeader:function(e){var t;if(2===x){if(!c){c={};while(t=Tn.exec(a))c[t[1].toLowerCase()]=t[2]}t=c[e.toLowerCase()]}return null==t?null:t},getAllResponseHeaders:function(){return 2===x?a:null},setRequestHeader:function(e,t){var n=e.toLowerCase();return x||(e=v[n]=v[n]||e,y[e]=t),this},overrideMimeType:function(e){return x||(p.mimeType=e),this},statusCode:function(e){var t;if(e)if(2>x)for(t in e)m[t]=[m[t],e[t]];else N.always(e[N.status]);return this},abort:function(e){var t=e||T;return l&&l.abort(t),k(0,t),this}};if(h.promise(N).complete=g.add,N.success=N.done,N.error=N.fail,p.url=((e||p.url||yn)+"").replace(xn,"").replace(kn,mn[1]+"//"),p.type=n.method||n.type||p.method||p.type,p.dataTypes=b.trim(p.dataType||"*").toLowerCase().match(w)||[""],null==p.crossDomain&&(r=En.exec(p.url.toLowerCase()),p.crossDomain=!(!r||r[1]===mn[1]&&r[2]===mn[2]&&(r[3]||("http:"===r[1]?80:443))==(mn[3]||("http:"===mn[1]?80:443)))),p.data&&p.processData&&"string"!=typeof p.data&&(p.data=b.param(p.data,p.traditional)),qn(An,p,n,N),2===x)return N;u=p.global,u&&0===b.active++&&b.event.trigger("ajaxStart"),p.type=p.type.toUpperCase(),p.hasContent=!Cn.test(p.type),o=p.url,p.hasContent||(p.data&&(o=p.url+=(bn.test(o)?"&":"?")+p.data,delete p.data),p.cache===!1&&(p.url=wn.test(o)?o.replace(wn,"$1_="+vn++):o+(bn.test(o)?"&":"?")+"_="+vn++)),p.ifModified&&(b.lastModified[o]&&N.setRequestHeader("If-Modified-Since",b.lastModified[o]),b.etag[o]&&N.setRequestHeader("If-None-Match",b.etag[o])),(p.data&&p.hasContent&&p.contentType!==!1||n.contentType)&&N.setRequestHeader("Content-Type",p.contentType),N.setRequestHeader("Accept",p.dataTypes[0]&&p.accepts[p.dataTypes[0]]?p.accepts[p.dataTypes[0]]+("*"!==p.dataTypes[0]?", "+Dn+"; q=0.01":""):p.accepts["*"]);for(i in p.headers)N.setRequestHeader(i,p.headers[i]);if(p.beforeSend&&(p.beforeSend.call(f,N,p)===!1||2===x))return N.abort();T="abort";for(i in{success:1,error:1,complete:1})N[i](p[i]);if(l=qn(jn,p,n,N)){N.readyState=1,u&&d.trigger("ajaxSend",[N,p]),p.async&&p.timeout>0&&(s=setTimeout(function(){N.abort("timeout")},p.timeout));try{x=1,l.send(y,k)}catch(C){if(!(2>x))throw C;k(-1,C)}}else k(-1,"No Transport");function k(e,n,r,i){var c,y,v,w,T,C=n;2!==x&&(x=2,s&&clearTimeout(s),l=t,a=i||"",N.readyState=e>0?4:0,r&&(w=_n(p,N,r)),e>=200&&300>e||304===e?(p.ifModified&&(T=N.getResponseHeader("Last-Modified"),T&&(b.lastModified[o]=T),T=N.getResponseHeader("etag"),T&&(b.etag[o]=T)),204===e?(c=!0,C="nocontent"):304===e?(c=!0,C="notmodified"):(c=Fn(p,w),C=c.state,y=c.data,v=c.error,c=!v)):(v=C,(e||!C)&&(C="error",0>e&&(e=0))),N.status=e,N.statusText=(n||C)+"",c?h.resolveWith(f,[y,C,N]):h.rejectWith(f,[N,C,v]),N.statusCode(m),m=t,u&&d.trigger(c?"ajaxSuccess":"ajaxError",[N,p,c?y:v]),g.fireWith(f,[N,C]),u&&(d.trigger("ajaxComplete",[N,p]),--b.active||b.event.trigger("ajaxStop")))}return N},getScript:function(e,n){return b.get(e,t,n,"script")},getJSON:function(e,t,n){return b.get(e,t,n,"json")}});function _n(e,n,r){var i,o,a,s,u=e.contents,l=e.dataTypes,c=e.responseFields;for(s in c)s in r&&(n[c[s]]=r[s]);while("*"===l[0])l.shift(),o===t&&(o=e.mimeType||n.getResponseHeader("Content-Type"));if(o)for(s in u)if(u[s]&&u[s].test(o)){l.unshift(s);break}if(l[0]in r)a=l[0];else{for(s in r){if(!l[0]||e.converters[s+" "+l[0]]){a=s;break}i||(i=s)}a=a||i}return a?(a!==l[0]&&l.unshift(a),r[a]):t}function Fn(e,t){var n,r,i,o,a={},s=0,u=e.dataTypes.slice(),l=u[0];if(e.dataFilter&&(t=e.dataFilter(t,e.dataType)),u[1])for(i in e.converters)a[i.toLowerCase()]=e.converters[i];for(;r=u[++s];)if("*"!==r){if("*"!==l&&l!==r){if(i=a[l+" "+r]||a["* "+r],!i)for(n in a)if(o=n.split(" "),o[1]===r&&(i=a[l+" "+o[0]]||a["* "+o[0]])){i===!0?i=a[n]:a[n]!==!0&&(r=o[0],u.splice(s--,0,r));break}if(i!==!0)if(i&&e["throws"])t=i(t);else try{t=i(t)}catch(c){return{state:"parsererror",error:i?c:"No conversion from "+l+" to "+r}}}l=r}return{state:"success",data:t}}b.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(e){return b.globalEval(e),e}}}),b.ajaxPrefilter("script",function(e){e.cache===t&&(e.cache=!1),e.crossDomain&&(e.type="GET",e.global=!1)}),b.ajaxTransport("script",function(e){if(e.crossDomain){var n,r=o.head||b("head")[0]||o.documentElement;return{send:function(t,i){n=o.createElement("script"),n.async=!0,e.scriptCharset&&(n.charset=e.scriptCharset),n.src=e.url,n.onload=n.onreadystatechange=function(e,t){(t||!n.readyState||/loaded|complete/.test(n.readyState))&&(n.onload=n.onreadystatechange=null,n.parentNode&&n.parentNode.removeChild(n),n=null,t||i(200,"success"))},r.insertBefore(n,r.firstChild)},abort:function(){n&&n.onload(t,!0)}}}});var On=[],Bn=/(=)\?(?=&|$)|\?\?/;b.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var e=On.pop()||b.expando+"_"+vn++;return this[e]=!0,e}}),b.ajaxPrefilter("json jsonp",function(n,r,i){var o,a,s,u=n.jsonp!==!1&&(Bn.test(n.url)?"url":"string"==typeof n.data&&!(n.contentType||"").indexOf("application/x-www-form-urlencoded")&&Bn.test(n.data)&&"data");return u||"jsonp"===n.dataTypes[0]?(o=n.jsonpCallback=b.isFunction(n.jsonpCallback)?n.jsonpCallback():n.jsonpCallback,u?n[u]=n[u].replace(Bn,"$1"+o):n.jsonp!==!1&&(n.url+=(bn.test(n.url)?"&":"?")+n.jsonp+"="+o),n.converters["script json"]=function(){return s||b.error(o+" was not called"),s[0]},n.dataTypes[0]="json",a=e[o],e[o]=function(){s=arguments},i.always(function(){e[o]=a,n[o]&&(n.jsonpCallback=r.jsonpCallback,On.push(o)),s&&b.isFunction(a)&&a(s[0]),s=a=t}),"script"):t});var Pn,Rn,Wn=0,$n=e.ActiveXObject&&function(){var e;for(e in Pn)Pn[e](t,!0)};function In(){try{return new e.XMLHttpRequest}catch(t){}}function zn(){try{return new e.ActiveXObject("Microsoft.XMLHTTP")}catch(t){}}b.ajaxSettings.xhr=e.ActiveXObject?function(){return!this.isLocal&&In()||zn()}:In,Rn=b.ajaxSettings.xhr(),b.support.cors=!!Rn&&"withCredentials"in Rn,Rn=b.support.ajax=!!Rn,Rn&&b.ajaxTransport(function(n){if(!n.crossDomain||b.support.cors){var r;return{send:function(i,o){var a,s,u=n.xhr();if(n.username?u.open(n.type,n.url,n.async,n.username,n.password):u.open(n.type,n.url,n.async),n.xhrFields)for(s in n.xhrFields)u[s]=n.xhrFields[s];n.mimeType&&u.overrideMimeType&&u.overrideMimeType(n.mimeType),n.crossDomain||i["X-Requested-With"]||(i["X-Requested-With"]="XMLHttpRequest");try{for(s in i)u.setRequestHeader(s,i[s])}catch(l){}u.send(n.hasContent&&n.data||null),r=function(e,i){var s,l,c,p;try{if(r&&(i||4===u.readyState))if(r=t,a&&(u.onreadystatechange=b.noop,$n&&delete Pn[a]),i)4!==u.readyState&&u.abort();else{p={},s=u.status,l=u.getAllResponseHeaders(),"string"==typeof u.responseText&&(p.text=u.responseText);try{c=u.statusText}catch(f){c=""}s||!n.isLocal||n.crossDomain?1223===s&&(s=204):s=p.text?200:404}}catch(d){i||o(-1,d)}p&&o(s,c,p,l)},n.async?4===u.readyState?setTimeout(r):(a=++Wn,$n&&(Pn||(Pn={},b(e).unload($n)),Pn[a]=r),u.onreadystatechange=r):r()},abort:function(){r&&r(t,!0)}}}});var Xn,Un,Vn=/^(?:toggle|show|hide)$/,Yn=RegExp("^(?:([+-])=|)("+x+")([a-z%]*)$","i"),Jn=/queueHooks$/,Gn=[nr],Qn={"*":[function(e,t){var n,r,i=this.createTween(e,t),o=Yn.exec(t),a=i.cur(),s=+a||0,u=1,l=20;if(o){if(n=+o[2],r=o[3]||(b.cssNumber[e]?"":"px"),"px"!==r&&s){s=b.css(i.elem,e,!0)||n||1;do u=u||".5",s/=u,b.style(i.elem,e,s+r);while(u!==(u=i.cur()/a)&&1!==u&&--l)}i.unit=r,i.start=s,i.end=o[1]?s+(o[1]+1)*n:n}return i}]};function Kn(){return setTimeout(function(){Xn=t}),Xn=b.now()}function Zn(e,t){b.each(t,function(t,n){var r=(Qn[t]||[]).concat(Qn["*"]),i=0,o=r.length;for(;o>i;i++)if(r[i].call(e,t,n))return})}function er(e,t,n){var r,i,o=0,a=Gn.length,s=b.Deferred().always(function(){delete u.elem}),u=function(){if(i)return!1;var t=Xn||Kn(),n=Math.max(0,l.startTime+l.duration-t),r=n/l.duration||0,o=1-r,a=0,u=l.tweens.length;for(;u>a;a++)l.tweens[a].run(o);return s.notifyWith(e,[l,o,n]),1>o&&u?n:(s.resolveWith(e,[l]),!1)},l=s.promise({elem:e,props:b.extend({},t),opts:b.extend(!0,{specialEasing:{}},n),originalProperties:t,originalOptions:n,startTime:Xn||Kn(),duration:n.duration,tweens:[],createTween:function(t,n){var r=b.Tween(e,l.opts,t,n,l.opts.specialEasing[t]||l.opts.easing);return l.tweens.push(r),r},stop:function(t){var n=0,r=t?l.tweens.length:0;if(i)return this;for(i=!0;r>n;n++)l.tweens[n].run(1);return t?s.resolveWith(e,[l,t]):s.rejectWith(e,[l,t]),this}}),c=l.props;for(tr(c,l.opts.specialEasing);a>o;o++)if(r=Gn[o].call(l,e,c,l.opts))return r;return Zn(l,c),b.isFunction(l.opts.start)&&l.opts.start.call(e,l),b.fx.timer(b.extend(u,{elem:e,anim:l,queue:l.opts.queue})),l.progress(l.opts.progress).done(l.opts.done,l.opts.complete).fail(l.opts.fail).always(l.opts.always)}function tr(e,t){var n,r,i,o,a;for(i in e)if(r=b.camelCase(i),o=t[r],n=e[i],b.isArray(n)&&(o=n[1],n=e[i]=n[0]),i!==r&&(e[r]=n,delete e[i]),a=b.cssHooks[r],a&&"expand"in a){n=a.expand(n),delete e[r];for(i in n)i in e||(e[i]=n[i],t[i]=o)}else t[r]=o}b.Animation=b.extend(er,{tweener:function(e,t){b.isFunction(e)?(t=e,e=["*"]):e=e.split(" ");var n,r=0,i=e.length;for(;i>r;r++)n=e[r],Qn[n]=Qn[n]||[],Qn[n].unshift(t)},prefilter:function(e,t){t?Gn.unshift(e):Gn.push(e)}});function nr(e,t,n){var r,i,o,a,s,u,l,c,p,f=this,d=e.style,h={},g=[],m=e.nodeType&&nn(e);n.queue||(c=b._queueHooks(e,"fx"),null==c.unqueued&&(c.unqueued=0,p=c.empty.fire,c.empty.fire=function(){c.unqueued||p()}),c.unqueued++,f.always(function(){f.always(function(){c.unqueued--,b.queue(e,"fx").length||c.empty.fire()})})),1===e.nodeType&&("height"in t||"width"in t)&&(n.overflow=[d.overflow,d.overflowX,d.overflowY],"inline"===b.css(e,"display")&&"none"===b.css(e,"float")&&(b.support.inlineBlockNeedsLayout&&"inline"!==un(e.nodeName)?d.zoom=1:d.display="inline-block")),n.overflow&&(d.overflow="hidden",b.support.shrinkWrapBlocks||f.always(function(){d.overflow=n.overflow[0],d.overflowX=n.overflow[1],d.overflowY=n.overflow[2]}));for(i in t)if(a=t[i],Vn.exec(a)){if(delete t[i],u=u||"toggle"===a,a===(m?"hide":"show"))continue;g.push(i)}if(o=g.length){s=b._data(e,"fxshow")||b._data(e,"fxshow",{}),"hidden"in s&&(m=s.hidden),u&&(s.hidden=!m),m?b(e).show():f.done(function(){b(e).hide()}),f.done(function(){var t;b._removeData(e,"fxshow");for(t in h)b.style(e,t,h[t])});for(i=0;o>i;i++)r=g[i],l=f.createTween(r,m?s[r]:0),h[r]=s[r]||b.style(e,r),r in s||(s[r]=l.start,m&&(l.end=l.start,l.start="width"===r||"height"===r?1:0))}}function rr(e,t,n,r,i){return new rr.prototype.init(e,t,n,r,i)}b.Tween=rr,rr.prototype={constructor:rr,init:function(e,t,n,r,i,o){this.elem=e,this.prop=n,this.easing=i||"swing",this.options=t,this.start=this.now=this.cur(),this.end=r,this.unit=o||(b.cssNumber[n]?"":"px")},cur:function(){var e=rr.propHooks[this.prop];return e&&e.get?e.get(this):rr.propHooks._default.get(this)},run:function(e){var t,n=rr.propHooks[this.prop];return this.pos=t=this.options.duration?b.easing[this.easing](e,this.options.duration*e,0,1,this.options.duration):e,this.now=(this.end-this.start)*t+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),n&&n.set?n.set(this):rr.propHooks._default.set(this),this}},rr.prototype.init.prototype=rr.prototype,rr.propHooks={_default:{get:function(e){var t;return null==e.elem[e.prop]||e.elem.style&&null!=e.elem.style[e.prop]?(t=b.css(e.elem,e.prop,""),t&&"auto"!==t?t:0):e.elem[e.prop]},set:function(e){b.fx.step[e.prop]?b.fx.step[e.prop](e):e.elem.style&&(null!=e.elem.style[b.cssProps[e.prop]]||b.cssHooks[e.prop])?b.style(e.elem,e.prop,e.now+e.unit):e.elem[e.prop]=e.now}}},rr.propHooks.scrollTop=rr.propHooks.scrollLeft={set:function(e){e.elem.nodeType&&e.elem.parentNode&&(e.elem[e.prop]=e.now)}},b.each(["toggle","show","hide"],function(e,t){var n=b.fn[t];b.fn[t]=function(e,r,i){return null==e||"boolean"==typeof e?n.apply(this,arguments):this.animate(ir(t,!0),e,r,i)}}),b.fn.extend({fadeTo:function(e,t,n,r){return this.filter(nn).css("opacity",0).show().end().animate({opacity:t},e,n,r)},animate:function(e,t,n,r){var i=b.isEmptyObject(e),o=b.speed(t,n,r),a=function(){var t=er(this,b.extend({},e),o);a.finish=function(){t.stop(!0)},(i||b._data(this,"finish"))&&t.stop(!0)};return a.finish=a,i||o.queue===!1?this.each(a):this.queue(o.queue,a)},stop:function(e,n,r){var i=function(e){var t=e.stop;delete e.stop,t(r)};return"string"!=typeof e&&(r=n,n=e,e=t),n&&e!==!1&&this.queue(e||"fx",[]),this.each(function(){var t=!0,n=null!=e&&e+"queueHooks",o=b.timers,a=b._data(this);if(n)a[n]&&a[n].stop&&i(a[n]);else for(n in a)a[n]&&a[n].stop&&Jn.test(n)&&i(a[n]);for(n=o.length;n--;)o[n].elem!==this||null!=e&&o[n].queue!==e||(o[n].anim.stop(r),t=!1,o.splice(n,1));(t||!r)&&b.dequeue(this,e)})},finish:function(e){return e!==!1&&(e=e||"fx"),this.each(function(){var t,n=b._data(this),r=n[e+"queue"],i=n[e+"queueHooks"],o=b.timers,a=r?r.length:0;for(n.finish=!0,b.queue(this,e,[]),i&&i.cur&&i.cur.finish&&i.cur.finish.call(this),t=o.length;t--;)o[t].elem===this&&o[t].queue===e&&(o[t].anim.stop(!0),o.splice(t,1));for(t=0;a>t;t++)r[t]&&r[t].finish&&r[t].finish.call(this);delete n.finish})}});function ir(e,t){var n,r={height:e},i=0;for(t=t?1:0;4>i;i+=2-t)n=Zt[i],r["margin"+n]=r["padding"+n]=e;return t&&(r.opacity=r.width=e),r}b.each({slideDown:ir("show"),slideUp:ir("hide"),slideToggle:ir("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(e,t){b.fn[e]=function(e,n,r){return this.animate(t,e,n,r)}}),b.speed=function(e,t,n){var r=e&&"object"==typeof e?b.extend({},e):{complete:n||!n&&t||b.isFunction(e)&&e,duration:e,easing:n&&t||t&&!b.isFunction(t)&&t};return r.duration=b.fx.off?0:"number"==typeof r.duration?r.duration:r.duration in b.fx.speeds?b.fx.speeds[r.duration]:b.fx.speeds._default,(null==r.queue||r.queue===!0)&&(r.queue="fx"),r.old=r.complete,r.complete=function(){b.isFunction(r.old)&&r.old.call(this),r.queue&&b.dequeue(this,r.queue)},r},b.easing={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2}},b.timers=[],b.fx=rr.prototype.init,b.fx.tick=function(){var e,n=b.timers,r=0;for(Xn=b.now();n.length>r;r++)e=n[r],e()||n[r]!==e||n.splice(r--,1);n.length||b.fx.stop(),Xn=t},b.fx.timer=function(e){e()&&b.timers.push(e)&&b.fx.start()},b.fx.interval=13,b.fx.start=function(){Un||(Un=setInterval(b.fx.tick,b.fx.interval))},b.fx.stop=function(){clearInterval(Un),Un=null},b.fx.speeds={slow:600,fast:200,_default:400},b.fx.step={},b.expr&&b.expr.filters&&(b.expr.filters.animated=function(e){return b.grep(b.timers,function(t){return e===t.elem}).length}),b.fn.offset=function(e){if(arguments.length)return e===t?this:this.each(function(t){b.offset.setOffset(this,e,t)});var n,r,o={top:0,left:0},a=this[0],s=a&&a.ownerDocument;if(s)return n=s.documentElement,b.contains(n,a)?(typeof a.getBoundingClientRect!==i&&(o=a.getBoundingClientRect()),r=or(s),{top:o.top+(r.pageYOffset||n.scrollTop)-(n.clientTop||0),left:o.left+(r.pageXOffset||n.scrollLeft)-(n.clientLeft||0)}):o},b.offset={setOffset:function(e,t,n){var r=b.css(e,"position");"static"===r&&(e.style.position="relative");var i=b(e),o=i.offset(),a=b.css(e,"top"),s=b.css(e,"left"),u=("absolute"===r||"fixed"===r)&&b.inArray("auto",[a,s])>-1,l={},c={},p,f;u?(c=i.position(),p=c.top,f=c.left):(p=parseFloat(a)||0,f=parseFloat(s)||0),b.isFunction(t)&&(t=t.call(e,n,o)),null!=t.top&&(l.top=t.top-o.top+p),null!=t.left&&(l.left=t.left-o.left+f),"using"in t?t.using.call(e,l):i.css(l)}},b.fn.extend({position:function(){if(this[0]){var e,t,n={top:0,left:0},r=this[0];return"fixed"===b.css(r,"position")?t=r.getBoundingClientRect():(e=this.offsetParent(),t=this.offset(),b.nodeName(e[0],"html")||(n=e.offset()),n.top+=b.css(e[0],"borderTopWidth",!0),n.left+=b.css(e[0],"borderLeftWidth",!0)),{top:t.top-n.top-b.css(r,"marginTop",!0),left:t.left-n.left-b.css(r,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var e=this.offsetParent||o.documentElement;while(e&&!b.nodeName(e,"html")&&"static"===b.css(e,"position"))e=e.offsetParent;return e||o.documentElement})}}),b.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(e,n){var r=/Y/.test(n);b.fn[e]=function(i){return b.access(this,function(e,i,o){var a=or(e);return o===t?a?n in a?a[n]:a.document.documentElement[i]:e[i]:(a?a.scrollTo(r?b(a).scrollLeft():o,r?o:b(a).scrollTop()):e[i]=o,t)},e,i,arguments.length,null)}});function or(e){return b.isWindow(e)?e:9===e.nodeType?e.defaultView||e.parentWindow:!1}b.each({Height:"height",Width:"width"},function(e,n){b.each({padding:"inner"+e,content:n,"":"outer"+e},function(r,i){b.fn[i]=function(i,o){var a=arguments.length&&(r||"boolean"!=typeof i),s=r||(i===!0||o===!0?"margin":"border");return b.access(this,function(n,r,i){var o;return b.isWindow(n)?n.document.documentElement["client"+e]:9===n.nodeType?(o=n.documentElement,Math.max(n.body["scroll"+e],o["scroll"+e],n.body["offset"+e],o["offset"+e],o["client"+e])):i===t?b.css(n,r,s):b.style(n,r,i,s)},n,a?i:t,a,null)}})}),e.jQuery=e.$=b,"function"==typeof define&&define.amd&&define.amd.jQuery&&define("jquery",[],function(){return b})})(window);		
jqueryminjs_BLOCK
	}
#
#
#
ouputta_jquerytextfillmin()
	{
	cat <<'jquerytextfillmin_BLOCK'
/*
  textfill
 @name      jquery.textfill.js
 @author    Russ Painter
 @author    Yu-Jie Lin
 @version   0.3.5
 @date      2013-05-08
 @copyright (c) 2012-2013 Yu-Jie Lin
 @copyright (c) 2009 Russ Painter
 @license   MIT License
 @homepage  https://github.com/jquery-textfill/jquery-textfill
 @example   http://jquery-textfill.github.io/jquery-textfill/index.html
*/
(function(e){e.fn.textfill=function(p){function l(){a.debug&&!("undefined"==typeof console||"undefined"==typeof console.debug)&&console.debug.apply(console,arguments)}function m(c,b,a,h,f,j){function d(b,a){var c=" / ";b>a?c=" > ":b==a&&(c=" = ");return c}l(c+"font: "+b.css("font-size")+", H: "+b.height()+d(b.height(),a)+a+", W: "+b.width()+d(b.width(),h)+h+", minFontPixels: "+f+", maxFontPixels: "+j)}function n(a,b,g,h,f,j,d,k){for(m(a+": ",b,f,j,d,k);d<k-1;){var e=Math.floor((d+k)/2);b.css("font-size",
e);if(g.call(b)<=h){if(d=e,g.call(b)==h)break}else k=e;m(a+": ",b,f,j,d,k)}b.css("font-size",k);g.call(b)<=h&&(d=k,m(a+"* ",b,f,j,d,k));return d}var a=e.extend({debug:!1,maxFontPixels:40,minFontPixels:4,innerTag:"span",widthOnly:!1,callback:null,complete:null,explicitWidth:null,explicitHeight:null},p);this.each(function(){var c=e(a.innerTag+":visible:first",this),b=a.explicitHeight||e(this).height(),g=a.explicitWidth||e(this).width(),h=c.css("font-size");l("Opts: ",a);l("Vars: maxHeight: "+b+", maxWidth: "+
g);var f=a.minFontPixels,j=0>=a.maxFontPixels?b:a.maxFontPixels,d=void 0;a.widthOnly||(d=n("H",c,e.fn.height,b,b,g,f,j));f=n("W",c,e.fn.width,g,b,g,f,j);a.widthOnly?c.css("font-size",f):c.css("font-size",Math.min(d,f));l("Final: "+c.css("font-size"));(c.width()>g||c.height()>b)&&c.css("font-size",h);a.callback&&a.callback(this)});a.complete&&a.complete(this);return this}})(window.jQuery);		
jquerytextfillmin_BLOCK
	}
#
#
#
go_bk()
	{
	HTML_bk()
		{
		#
		##########################
		#
		export HTML_file_to_read="${dir_Karaoke}"/.lyrics
		HTML_file_to_read__directory_path="$(dirname "${HTML_file_to_read}" )"
		#
		[ ! -d "${HTML_file_to_read__directory_path}"/css ] && mkdir "${HTML_file_to_read__directory_path}"/css
		cd "${HTML_file_to_read__directory_path}"/css
		[ ! -f "css_karaoke.css" ] && ouputta_css 1> css_karaoke.css
		cd - 1>/dev/null
		#
		[ ! -d "${HTML_file_to_read__directory_path}"/js ] && mkdir "${HTML_file_to_read__directory_path}"/js
		cd "${HTML_file_to_read__directory_path}"/js
		[ ! -f "config.js" ] && ouputta_configjs 1> config.js
		[ ! -f "jquery.min.js" ] && ouputta_jqueryminjs 1> jquery.min.js
		[ ! -f "jquery.textfill.min.js" ] && ouputta_jquerytextfillmin 1> jquery.textfill.min.js
		cd - 1>/dev/null
		#
		##
		#
		[ ${#bkbrowser} -eq 0 ] && bkbrowser="embedded"
		if [ "${bkbrowser}" = "embedded" ]
			then
			bkbrowser="${embedded_browser}" 
		fi
		#
		##
		#
		GO_file_content="$(0< "${dir_Karaoke}/${go_file}" )"
		if [ "${GO_file_content}" = "GO" ]
			then
			if [ "${bkbrowser}" = "${embedded_browser}" ]
				then
				embedded_browser_dir="$(dirname "${embedded_browser}" )"
				cd "${embedded_browser_dir}"
					./$(basename "${bkbrowser}" ) -f "${HTML_file_to_read}"
					uscita_di_embedded_browser="${?}"
				cd - 1>/dev/null
				if [ ${uscita_di_embedded_browser} -ne 0 ]
					then
					[ "${l}" = "IT" ] && alert_message "Sembra che il browser \"embedded\" \n sia uscito inaspettatamente. \n Per favore, nota che esso \n ha bisogno di Python e Webkit \n per funzionare. \n\n Potresti considerare \n di cambiare \n il browser di fullscreen \n in bashkaraoke \n -> \"CONFIGURA\" -> \"Varie...\""
					[ "${l}" = "EN" ] && alert_message "It seems that \"embedded\" browser \n exited with an error. \n Please, note that \n it needs Python and Webkit \n to work. \n\n You would consider \n to change fullscreen browser \n in bashkaraoke \n -> \"CONFIGURE\" -> \"Misc...\""
				fi
			else
				${bkbrowser} file://"${HTML_file_to_read}"
			fi &
			:
		fi
		#
		[ "${bkbrowser}" = "${embedded_browser}" ] && : || sleep 1
		#
		##########################
		#
		#
		[ ${#midi} -eq 0 ] && alert_message "Error: \n no \"\${midi}\" set..."
		[ ${#bk_OUT} -eq 0 ] && alert_message "Error: \n no \"\${bk_OUT}\" set..."
		[ ${#HTML_file_to_read} -eq 0 ] && alert_message "Error: \n no \"\${HTML_file_to_read}\" set..."
		#
		exec xterm -title "Playing: $(basename "${midi}" | iconv -f "${char_encoding}" )" -geometry 72x1 -e "${bk_OUT}" -o h -f "${HTML_file_to_read}" "${midi}"
		}
	#
	##
	#
	xterm_bk()
		{
		#
		exec xterm -cr "${background}" -xrm 'xterm*cursorUnderLine: true' -xrm "xterm*allowWindowOps: true" -title "$(basename "${0}"): $(basename "${midi}" | iconv -f "${char_encoding}" ) (${extract_way}#$(basename "${sf}" ))" -bg "${background}" -fg "${foreground_1}" -fn "${font}" -geometry ${columns}x3+20+400 -e "${bkcore}" "${midi}"
		}
	#
	##
	#
	nude_bk()
		{
		#
		if [ ${#soundfont} -gt 0 ]
			then
			export soundfont_string="-x\"soundfont ${soundfont}\""
		else
			export soundfont_string=""
		fi
		: soundfont_string
		#
		: muted_channels
		if [ "${muted_channels}" = "NONE" ]
			then
			channel_exclude_string=""
		elif [ "${muted_channels}" = "ALL" ]
			then
			channel_exclude_string="-Q0"
		else
			channel_exclude_string="-Q${muted_channels}"
		fi
		: channel_exclude_string
		#
		: spectrogram_window
		if [ "${spectrogram_window}" = "false" ]
			then
			spectrogram_string=""
		elif [ "${spectrogram_window}" = "true" ]
			then
			spectrogram_string="-g0.1"
		fi
		: spectrogram_string
		#
		: volume
		: tempo
		: pitch
		: midi
		#
		if [ "${levels_window}" = "true" -o "${channels_window}" = "true" ]
			then
			clean_temp
			eval timidity ${soundfont_string} ${channel_exclude_string} ${spectrogram_string} -A${volume} --volume-compensation -T${tempo} -K${pitch} -idqqqt \"${midi}\" 1> /dev/null
		else
			continua="SI"
			while [ "${continua}" = "SI" ]
				do
				#
				eval timidity ${soundfont_string} ${channel_exclude_string} ${spectrogram_string} -A${volume} --volume-compensation -T${tempo} -K${pitch} -idqqqt \"${midi}\" &
				#
				#[ "${l}" = "IT" ] && nudewindow="$(Xdialog --stdout ${rc} --ok-label "Riavvia canzone" --cancel-label "Esci" --title "$(basename "${0}")" ${icona_BK} --yesno "Riproduzione di\n$(basename "${midi}" )" "${dimensione_finestra_1}" "${dimensione_finestra_2}" ; click=${?} ; echo -e "\n\n\n${click}" )"
				[ "${l}" = "IT" ] && nudewindow="$(question "Riproduzione di \n $(basename "${midi}" ) \n ... \n\n\n Riavvio \n la canzone ?" ; \
				click=${?} ; echo -e "\n\n\n${click}" )"
				#
				#[ "${l}" = "EN" ] && nudewindow="$(Xdialog --stdout ${rc} --ok-label "Restart song" --cancel-label "Quit" --title "$(basename "${0}")" ${icona_BK} --yesno "Playing\n$(basename "${midi}" )" "${dimensione_finestra_1}" "${dimensione_finestra_2}" ; click=${?} ; echo -e "\n\n\n${click}" )"
				[ "${l}" = "IT" ] && nudewindow="$(question "Playing \n $(basename "${midi}" ) \n ... \n\n\n Restart \n song ?" ; \
				click=${?} ; echo -e "\n\n\n${click}" )"
				#
				click="$(echo "${nudewindow}" | tail -n 1 )"
				if [ ${click} -eq 0 ]
					then
					#
					continua="SI"
					#
				elif [ ${click} -eq 1 ]
					then
					#
					continua="NO"
					#
				else
					#
					continua="NO"
					#
				fi
				clean_temp
				killall timidity
				wait
			done
		fi
		#
		}
	#
	###########
	#############################
	################################
	if [ "${karaoke_window}" = "true" ]
		then
		if [ "${parent_bkscript}" = "${HTML_karaoke_scriptname}" ]
			then
			echo -en "GO" 1>> "${dir_Karaoke}/${go_file}"
			HTML_bk
		elif [ "${parent_bkscript}" = "${xterm_karaoke_scriptname}" ]
			then
			xterm_bk
		else
			alert_message "Error: \n no \"\${parent_bkscript}\" set..."
		fi
	elif [ "${karaoke_window}" = "false" ]
		then
		nude_bk
	fi
	################################
	#############################
	###########
	#
	}
#
#
#
crea_database()
	{
	extensions=( ${extensions_var} )
	#
	while :
		do
		[ "${l}" = "IT" ] && message "Prego, \n seleziona \n la directory \n delle canzoni..."
		[ "${l}" = "EN" ] && message "Please, \n select \n songs directory..."
		#
		dselect ; dir_canzoni="$(0< "${dir_tmp}/${file_tmp}" )" && if_arg_is_an_empty_variable_then_exit "dir_canzoni"
		#
		if [ -d "${dir_canzoni}" ]
			then
			: dir_canzoni
		else
			[ "${l}" = "IT" ] && alert_message "Errore: \n non e' una directory."
			[ "${l}" = "EN" ] && alert_message "Error: \n it's not a directory."
			continue
		fi
		#
		if [ "${l}" = "IT" ]
			then 
			question "La dir. scelta e': \n$(echo "${dir_canzoni}" | gsed s\#'/'#'\n/'#g ) \n\n Continuo?"
			risposta=${?}
		elif [ "${l}" = "EN" ]
			then
			question "Selected dir. is: \n$(echo "${dir_canzoni}" | gsed s\#'/'#'\n/'#g ) \n\n Continue?"
			risposta=${?}
		fi
		if [ ${risposta} -eq 0 ]
			then
			break
		elif [ ${risposta} -eq 1 ]
			then
			continue
		else
			ciao
		fi
	done
	#
	if [ -f "${database}" ]
		then
		mv "${database}" "${database}_OLD"
	fi
	#
	####
	####
	#
	[ "${l}" = "IT" ] && wait_for "Controllo \n le canzoni presenti..."
	[ "${l}" = "EN" ] && wait_for "Checking \n songs..."
	#
	##
	#
	IFS=$'\n' ; array_canzoni=( $(find "${dir_canzoni}" -type f 2>/dev/null | \
						iconv -f "${char_encoding}" | \
						grep -Ei "($(for (( index=0 ; index < ${#extensions[@]} ; index++ ))
								do
								echo -n "${extensions[${index}]}$|"
							done | gsed s\#'.$'#''# ))" | \
						sort ) ) ; IFS=$' \t\n'
	#
	if [ ${#array_canzoni[@]} -eq 0 ]
		then
		IFS=$'\n' ; array_canzoni=( $(find "${dir_canzoni}" -type f 2>/dev/null | \
						grep -Ei "($(for (( index=0 ; index < ${#extensions[@]} ; index++ ))
								do
								echo -n "${extensions[${index}]}$|"
							done | gsed s\#'.$'#''# ))" | \
						sort ) ) ; IFS=$' \t\n'
	fi
	#
	##
	#
	terminate_wait_for
	#
	####
	####
	#
	: array_canzoni[@]
		{
		for (( index=0 ; index < ${#array_canzoni[@]} ; index++ ))
			do
			#
			path_canzone="$(echo "${array_canzoni[${index}]}" | gsed s\#"^${HOME}"#'~'# )"
			#
			####
			######
			eval array_dati_database[${index}]=\"${path_canzone}\"
			######
			####
			#
			echo "PROGRESS"
			#
		done
		#
		##
		#
		[ "${l}" = "IT" ] && wait_for "Inizializzazione \n del database (1)..."
		[ "${l}" = "EN" ] && wait_for "Database \n initializing (1)..."
		# fase a) :
		echo "[Bash!Karaoke Database]" 1> "${database}"
		dati_database="$(for (( index=0 ; index < ${#array_dati_database[@]} ; index++ ))
					do
					# Old database composed by file path only:
					#echo "${array_dati_database[${index}]}"
					#
					# Current database:
					# id="""num.progressivo""", path="""/path/to/file.kar""", title="""Canzone stupenda""", artist="""Cantante Stonatissimo""", info="""Futili informazioni sulla canzone""", duration="""159""", completed="""false"""
					#echo "id=\"\"\"${index}\"\"\", path=\"\"\"${array_dati_database[${index}]}\"\"\", title=\"\"\"\"\"\", artist=\"\"\"\"\"\", info=\"\"\"\"\"\", duration=\"\"\"\"\"\"", completed=\"\"\"false\"\"\"
					echo -e "id=${index}\tpath=${array_dati_database[${index}]}\ttitle=\tartist=\tinfo=\tduration=\tcompleted=false\t"
					#
				done )"
		# fase b) :
		echo "${dati_database}" 1>> "${database}"
		#
		terminate_wait_for
		#
		##
		#
		} | \
			progress "$(if [ "${l}" = "IT" ]; 
						then
						echo "Creazione \n del database \n di ${#array_canzoni[@]} canzoni..."
					elif [ "${l}" = "EN" ]
						then
						echo "${#array_canzoni[@]} songs \n database \n creation..."
					fi 
					)" "${#array_canzoni[@]}"
	#
	##
	#
	[ "${l}" = "IT" ] && wait_for "Database \n initializing (2)..."
	[ "${l}" = "EN" ] && wait_for "Inizializzazione \n del database (2)..."
	#var_database="$(cat "${database}" )"
	#var_database="$(gsed -n s\#'^.*path="""\(.*\)""", title=.*$'#'\1'#p 0< "${database}" )"
	var_database="$(gsed -n s\#'^.*path=\(.*\)\ttitle=.*$'#'\1'#p 0< "${database}" )"
	sleep 1
	terminate_wait_for
	#
	}
#
#
#
scrivi_riga_nel_database()
	{
	# id="""num.progressivo""", path="""/path/to/file.kar""", title="""Canzone stupenda""", artist="""Cantante Stonatissimo""", info="""Futili informazioni sulla canzone""", duration="""159""", completed="""false"""
	#
	# scrivi_riga_nel_database "id" "path" "title" "artist" "info" "duration" "completed"
	id="${1}"
	path="${2}"
	title="${3}"
	artist="${4}"
	info="${5}"
	duration="${6}"
	completed="${7}"
	#############
	#
	#
	#
	#############
	# id analyzing...
	if [ $(echo "${id}" | tr -dc [[:digit:]] | wc -c) -eq 0 ]
		then
		alert_message "Error. \n Incorrect id: \n \"${id}\" \n ..."
		return
	fi
	#
	#############
	# path analizing...
	#
	# 1) files in same directory...
	[ "$(dirname "${path}" )" = "." ] && path="${PWD}/${2}"
	#
	# 2) files not existing...
	if [ ! -f "${path}" ]
		then
		alert_message "Error. \n Incorrect path: \n \"${path}\" \n ..."
		return
	fi
	#
	# 3) let's substitute "~" character...
	path="$(echo "${path}" | gsed s\#"^${HOME}"#'~'# )"
	#############
	#
	gsed s\#"^\(id=${id}\tpath=.*\)$"#"id=${id}\tpath=${path}\ttitle=${title}\tartist=${artist}\tinfo=${info}\tduration=${duration}\tcompleted=${completed}\t"# 0< "${database}" 1> "${database}_TEMP"
	mv "${database}_TEMP" "${database}"
	#
	}
#
#
#
estrai_dal_database()
	{
	#
	#######################
	#
	var_crea_database="NO"
	#
	if [ ! -f "${database}" ]
		then
		[ "${l}" = "IT" ] && alert_message "Attenzione: \n il file \n del database \n non esiste..."
		[ "${l}" = "EN" ] && alert_message "Database \n file \n doesn't exist..."
		var_crea_database="SI"
	else
		if [ $(wc -l 0< "${database}" ) -eq 0 ]
			then
			[ "${l}" = "IT" ] && alert_message "Attenzione: database vuoto..."
			[ "${l}" = "EN" ] && alert_message "Database is empty..."
			var_crea_database="SI"
		fi
	fi
	#
	if [ "${var_crea_database}" = "SI" ]
		then
		if [ "${l}" = "IT" ]
			then 
			question "Per fare la ricerca rapida \n serve un database aggiornato... \n\n Vuoi creare \n il database \n delle canzoni?"
			risposta="${?}"
		elif [ "${l}" = "EN" ]
			then 
			question "For quick search \n I need an up-to-date \n database...  \n\n Do you want \n create \n the song database?"
			risposta="${?}"
		fi
		if [ ${risposta} -eq 0 ]
			then
			crea_database
		elif [ ${risposta} -eq 1 ]
			then
			[ "${l}" = "IT" ] && alert_message "OK. \n Ma NON posso fare \n la ricerca rapida \n delle canzoni..."
			[ "${l}" = "EN" ] && alert_message "OK. \n But I can NOT \n quick search \n songs..."
			return
		else
			ciao
		fi
	fi
	#
	#######################
	#
	while :
		do
		#
		##
		#
		#[ "${l}" = "IT" ] && input $([ "${mode}" = "Xdialog" ] && echo -en "-h 550 " ) 1 "Artista/Canzone - es. \"M?dugno\", o \"m?gno/nel?blu\""
		#[ "${l}" = "EN" ] && input $([ "${mode}" = "Xdialog" ] && echo -en "-h 550 " ) 1 "Artist/Song - e.g. \"Be?tles\", or \"beatl?s/com?gether\""
		[ "${l}" = "IT" ] && input $([ "${mode}" = "Xdialog" ] && echo -en "-h 550 " ) 1 "Artista/Canzone - es. 'M?dugno', o 'm?gno/nel?blu'"
		[ "${l}" = "EN" ] && input $([ "${mode}" = "Xdialog" ] && echo -en "-h 550 " ) 1 "Artist/Song - e.g. 'Be?tles', or 'beatl?s/com?gether'"
		#
		artista_titolo="$(tr -c '[[:alnum:]]' '?' 0< "${dir_tmp}/${file_tmp}" |  gsed s\#'\?'#'\.\*'#g )" ; [ "${artista_titolo}" = ".*" ] && clean_temp && exit 0
		#
		##
		#
		[ "${mode}" = "dialog" ] || [ "${l}" = "IT" ] && wait_for "Ricerca nel database \n in corso..."
		[ "${mode}" = "dialog" ] || [ "${l}" = "EN" ] && wait_for "Database searching..."
		#
		lista="$(echo "${var_database}" | gsed -n "\#${artista_titolo}#Ip" | gsed s\#"^${HOME}"#'~'# )"
		: lista
		#
		IFS=$'\n' ; array_lista=( ${lista} ) ; IFS=$' \t\n'
		: array_lista[@]
		#
		[ "${mode}" = "dialog" ] || terminate_wait_for
		#
		if [ ${#array_lista[@]} -eq 0 ]
			then
			[ "${mode}" = "dialog" ] || [ "${l}" = "IT" ] && alert_message "Mi dispiace: \n nessuna canzone trovata \n con quella parola chiave..."
			[ "${mode}" = "dialog" ] || [ "${l}" = "EN" ] && alert_message "Sorry: \n no song found \n with that key word..."
			continue
		else
			break
		fi
	done
	#
	if [ ${#array_lista[@]} -eq 1 ]
		then
		scelta="${array_lista[0]}"
		echo "${scelta}" 1> "${dir_Karaoke}/${lista_karaoke}" &
		:
	else
		[ "${mode}" = "dialog" ] || [ "${l}" = "IT" ] && wait_for "Creazione della lista \n in corso..."
		[ "${mode}" = "dialog" ] || [ "${l}" = "EN" ] && wait_for "List creating..."
		#
		echo "${lista}" 1> "${dir_Karaoke}/${lista_karaoke}" &
		#
		scelte="$(for (( index=0 ; index < ${#array_lista[@]} ; index++ )); do echo -ne "\"$(echo "${array_lista[${index}]}" | tr -c '[a-z][A-Z][:digit:][:punct:][:blank:][:space:]' '?' )\"\t" ; done )"
		#
		[ "${mode}" = "dialog" ] || terminate_wait_for
		#
		: > "${dir_tmp}/${file_tmp}"
		IFS=$'\t' ; eval menu ${scelte} ; IFS=$' \t\n'
		scelta="$(0< "${dir_tmp}/${file_tmp}" )" ; [ ${#scelta} -eq 0 ] && return
		#
	fi
	#
	if [ -f "$(echo "${scelta}" | gsed s\#"^~"#"${HOME}"# )" ]
		then
		#
		: scelta
		#
		##
		####
		path_canzone_pre="${scelta}"
		####
		##
		#
		path_canzone="$(echo "${path_canzone_pre}" | gsed s\#"^~"#"${HOME}"# )"
		#
	else
		#
		scelta="$(echo "${scelta}" | gsed s\#'?'#'.\\?'#g )"
		#
		##
		####
		path_canzone_pre="$(associazione_path "${scelta}" )"
		####
		##
		#
		path_canzone="$(echo "${path_canzone_pre}" | gsed s\#"^~"#"${HOME}"# )"
		#
	fi
	#
	echo "${path_canzone}"
	#
	}
#
#
#
associazione_path()
	{
	#
	scelta="${1}"
	#
	[ "${mode}" = "dialog" ] || [ "${l}" = "IT" ] && wait_for "Associazione del path..."
	[ "${mode}" = "dialog" ] || [ "${l}" = "EN" ] && wait_for "Path retrieving..."
	IFS=$'\n' && array_path=( $(echo "${var_database}" | cut -f 2 | gsed -n "\#${scelta}#Ip" ) ) && IFS=$' \t\n'
	while :
		do
		if [ ${#array_path[@]} -eq 0 ]
			then
			sleep 1
			[ "${mode}" = "dialog" ] || terminate_wait_for
			sleep 1
			[ "${mode}" = "dialog" ] || [ "${l}" = "IT" ] && alert_message "Nessun path \n trovato \n con la var.: \"\${scelta}\" ..."
			[ "${mode}" = "dialog" ] || [ "${l}" = "EN" ] && alert_message "No path \n found \n with var.: \"\${scelta}\" ..."
			exit 1
		elif [ ${#array_path[@]} -eq 1 ]
			then
			# Associazione di "${scelta}" ad un vero e proprio path del file-system...
			#
			IFS=$'\n'
			array_path_canzone=( $(echo "${array_path[0]}" | tr -c '[a-z][A-Z][:digit:][:punct:][:blank:]' '\n' ) )
			IFS=$' \t\n'
			#
			##
			####
			path_canzone_pre="$(for (( index=0 ; index < ${#array_path_canzone[@]} ; index++ ))
							do
							echo -n "\"${array_path_canzone[${index}]}\"?"
						done | \
						gsed s\#'[[:space:]]\+'#'"*"'#g | \
						gsed -n s\#'\(.*\)?$'#'\1'#p 
						)"
			path_canzone="$(echo "${path_canzone_pre}" | gsed s\#'^"~'#"\"${HOME}"# )"
			####
			##
			#
			risultato_ls=$(eval ls "${path_canzone}" 2>/dev/null | wc -l )
			if [ ${risultato_ls} -eq 0 ]
				then
				sleep 1
				[ "${mode}" = "dialog" ] || terminate_wait_for
				sleep 1
				[ "${mode}" = "dialog" ] || [ "${l}" = "IT" ] && alert_message "Non sono riuscito \n ad associare un path \n alla var.: \n \"\${path_canzone}\" \n ($(basename "${path_canzone}" )) \n..."
				[ "${mode}" = "dialog" ] || [ "${l}" = "EN" ] && alert_message "I couldn't \n refer a path \n to var.:\n \"\${path_canzone}\" \n ($(basename "${path_canzone}" )) \n..."
				exit 1
			elif [ ${risultato_ls} -eq 1 ]
				then
				sleep 1
				[ "${mode}" = "dialog" ] || terminate_wait_for # Questo e' quello che va' a terminare il wait_for proprio quando e' andato tutto bene...
				path_canzone="$(eval ls "${path_canzone}" )"
				break
				#
			elif [ ${risultato_ls} -gt 1 ]
				then
				IFS=$'\n' && array_path=( $(eval ls "${path_canzone}" ) ) && IFS=$' \t\n'
				[ "${mode}" = "dialog" ] || [ "${l}" = "IT" ] && alert_message "\"ls\" mi da' \n PIU' di un path... \n\n Clicca <OK> \n per scegliere..."
				[ "${mode}" = "dialog" ] || [ "${l}" = "EN" ] && alert_message "\"ls\" gives \n MORE than one path... \n\n Select \n <OK> button \n to choose..."
				continue # In pratica vai a: "elif [ ${#array_path[@]} -gt 1 ]"
			fi
			#
		elif [ ${#array_path[@]} -gt 1 ]
			then
			scelte="$(for (( index=0 ; index < ${#array_path[@]} ; index++ )); do echo -ne "\"${array_path[${index}]}\"\t" ; done )"
			IFS=$'\t' && eval menu ${scelte} && IFS=$' \t\n'
			scelta="$(0< "${dir_tmp}/${file_tmp}" )"
			if [ $(echo -n "${scelta}" | wc -c ) -eq 0 ]
				then
				sleep 1
				[ "${mode}" = "dialog" ] || terminate_wait_for
				exit
			fi
			# Se invece: [ $(echo -n "${scelta}" | wc -c ) -gt 0 ] ...
			IFS=$'\n' && array_path=( $(echo "${var_database}" | cut -f 2 | gsed -n "\#${scelta}#Ip" ) ) && IFS=$' \t\n'
			continue
		fi
		#
	done
	#
	echo "${path_canzone}"
	}
#
#
#
extract_song_lyric()
	{
	#
	local midi="${1}"
	#
	[ "${l}" = "IT" ] && wait_for "Attendere prego..."
	[ "${l}" = "EN" ] && wait_for "Please wait..."
	sleep 1
	testo_canzone="$("${bk_extractor}" "${midi}" 2> /dev/null )"
	righe_canzone=$(echo "${testo_canzone}" | wc -l | tr -dc '[[:digit:]]' )
	terminate_wait_for
	# Note: only "kdialog" and "zenity" support international chars :(  ...
	echo -e "${testo_canzone}" | text
	#xterm -cr "${background}" -xrm 'xterm*cursorUnderLine: true' -xrm "xterm*allowWindowOps: true" -title "$(basename "${0}"): $(basename "${midi}" | iconv -f "${char_encoding}" ) -> lyric" -bg "black" -fg "blue" -fn "${font}" -geometry $(( ${columns} * 2 ))x$(( ${righe_canzone} / 2 ))+20+400 -e "less \"${dir_tmp}/${file_tmp}\""
	chiusura_finestra="${?}" ; [ ${chiusura_finestra} -ne 0 ] && return
	#
	if [ "${l}" = "IT" ]
		then 
		question "Vuoi salvare \n il testo \n della canzone \n ?"
		risposta=${?}
	elif [ "${l}" = "EN" ]
		then
		question "Do you want \n save \n song lyric \n ?"
		risposta=${?}
	fi
	if [ ${risposta} -eq 0 ]
		then
		dselect ; dir_testo="$(0< "${dir_tmp}/${file_tmp}" )" ; [ ${#dir_testo} -eq 0 ] && continue 1
		#
		[ "${l}" = "IT" ] && wait_for "Attendere prego..."
		[ "${l}" = "EN" ] && wait_for "Please wait..."
		basename_midi="$(basename "${midi}" )"
		file_testo="${basename_midi%.*}.txt"
		echo "${testo_canzone}" 1> "${dir_testo}/${file_testo}"
		sleep 1
		terminate_wait_for
		[ "${l}" = "IT" ] && ok_message "Salvato in \n ${dir_testo} \n ..."
		[ "${l}" = "EN" ] && ok_message "Saved in \n ${dir_testo} \n ..."
		#
	elif [ ${risposta} -eq 1 ]
		then
		unset testo_canzone
		:
	else
		ciao
	fi
	}
#
#
#
outputta_bkXbuc()
	{
	cat <<-BLOCCO_bkXbuc_1
<?xml version="1.0"?>
<config>
	<global var="BK_VERSION_NUMBER" code="echo ${BK_VERSION_NUMBER}" />
	<global var="dir_Karaoke" code="echo ${dir_Karaoke}" /> 
	<global var="rc_file" code="echo ${rc_file}" />
	<global var="bk_gtk_binary" code="echo ${bk_gtk_binary}" />
	<global var="extensions" code="echo ${extensions_var}" /> 
	<global var="database" code="echo ${database}" /> 
	<global var="lista_karaoke" code="echo ${lista_karaoke}" />
	<global var="log_file" code="echo ${log_file}" />
	<global var="timidity_log_file" code="echo ${timidity_log_file}" />
	<global var="l" code="echo ${l}" />
	<global var="black_icon" code="echo ${black_icon}" />
	<global var="red_icon" code="echo ${red_icon}" />
	<global var="green_icon" code="echo ${green_icon}" />
	<global var="yellow_icon" code="echo ${yellow_icon}" />
	<global var="blue_icon" code="echo ${blue_icon}" />
	<global var="magenta_icon" code="echo ${magenta_icon}" />
	<global var="cyan_icon" code="echo ${cyan_icon}" />
	<global var="white_icon" code="echo ${white_icon}" />
	<global var="font" code="echo ${font}" />
	<global var="columns" code="echo ${columns}" />
	
	<global var="ORIG" code="echo ${dir_Karaoke}/${rc_file}" />
	<global var="TEMP" code="echo ${dir_Karaoke}/${rc_file}_TEMP" /> 
	<global var="TEMP1" code="echo ${dir_Karaoke}/${rc_file}_TEMP1" /> 
	<global var="TEMP2" code="echo ${dir_Karaoke}/${rc_file}_TEMP2" /> 
	<global var="delim" code="echo =============================" />
	<global var="dbg" code="echo ${default_background}" />
	<global var="dfg1" code="echo ${default_foreground_1}" />
	<global var="dfg2" code="echo ${default_foreground_2}" />
	<global var="dff" code="echo ${default_font_family}" />
	<global var="dv" code="echo ${default_Volume}" />
	<global var="dp" code="echo ${default_Pitch}" />
	<global var="dt" code="echo ${default_Tempo}" />
	
	
	<img src="${buc_BK_icon}" align="center"/>

	
BLOCCO_bkXbuc_1
	cat <<-'BLOCCO_bkXbuc_2'
	
	<tab><title>[ "${l}" = "IT" ] && echo "Suona" ; [ "${l}" = "EN" ] && echo "Play"</title>
		<hlayout>
			<label>
				<code>
				[ "${l}" = "IT" ] && echo "RICERCA il midi nel database..."
				[ "${l}" = "EN" ] && echo "SEARCH midi in database..."
				</code>
			</label>
			<text var="stringa_da_cercare">
				<code>
				[ "${l}" = "IT" ] && echo "Artista/Canzone - es. m?dugno/nel?blu"
				[ "${l}" = "EN" ] && echo "Artist/Song - e.g. beatl?s/com?gether"
				</code>
			</text>
			<button>
				<text>
				[ "${l}" = "IT" ] && echo "ricerca"
				[ "${l}" = "EN" ] && echo "search"
				</text>
				<code>
				if [ -f "${database}" ]
					then
					var_database="$(cat "${database}" )"
				fi
				artista_titolo="$(echo "${stringa_da_cercare}" | tr -c '[[:alnum:]]' '?' | sed s\#'\?'#'\.\*'#g )"
				lista="$(echo "${var_database}" | sed -n "\#${artista_titolo}#Ip" )"
				if [ ${#lista} -eq 0 ]
					then
					[ "${l}" = "IT" ] && echo "Mi dispiace: nessuna canzone trovata con quella parola chiave..."
					[ "${l}" = "EN" ] && echo "Sorry: no song found with that keyword..."
				else
					echo "${lista}" | sed s\#"^${HOME}"#'~'#
				fi
				</code>
			</button>
		</hlayout>

		<hlayout>
			<label>
				<code>
				[ "${l}" = "IT" ] && echo "AGGIORNA il database..."
				[ "${l}" = "EN" ] && echo "UPDATE database..."
				</code>
			</label>
			<file var="dir_canzoni" mode="dir" >
				<code>
				echo ""
				</code>
			</file>
			<button>
				<text>
				[ "${l}" = "IT" ] && echo "aggiorna"
				[ "${l}" = "EN" ] && echo "update"
				</text>
				<code>
				cd "${dir_canzoni}"
					#
					if [ -f "${database}" ]
						then
						mv "${database}" "${database}_OLD"
					fi
					echo "${delim}"
					: 1> "${database}"
					for ext in ${extensions}
						do
						xterm -e "export supermode=dialog ; source easybashgui ; wait_for Searching${ext}... ; find ./ -type f | fgrep -i ${ext} 1>> "${database}_TEMP" ; sleep 1 ; terminate_wait_for; clean_temp"
					done
					cat "${database}_TEMP" | sed s\#'^./'#"$(pwd)/"# | sort 1> "${database}"
					rm "${database}_TEMP"
					#
				cd - 1> /dev/null
				#
				[ "${l}" = "IT" ] && echo "Inizio creazione del database delle canzoni..."
				[ "${l}" = "EN" ] && echo "Songs database creation starting..."
				echo "${delim}"
				cat "${database}"
				echo "${delim}"
				[ "${l}" = "IT" ] && echo "Fine creazione del database delle canzoni."
				[ "${l}" = "EN" ] && echo "Songs database created."
				echo "${delim}"
				</code>
			</button>
		</hlayout>
		<textlog/>

		<label/>
		<label/>

		<hlayout>
			<label>
				<code>
				[ "${l}" = "IT" ] && echo "SUONA questo file: -->"
				[ "${l}" = "EN" ] && echo "PLAY this file: -->"
				</code>
			</label>
			<file var="midi" mode="open" filter="Karaoke-files(*.midi *.MIDI *.mid *.MID *.rmi *.RMI *.rcp *.RCP *.r36 *.R36 *.g18 *.G18 *.g36 *.G36 *.mfi *.MFI *.kar *.KAR *.mod *.MOD *.wrd *.WRD)"/>
		</hlayout>

		<hlayout>
			<label>
				<code>
				[ "${l}" = "IT" ] && echo "SCEGLI il player..."
				[ "${l}" = "EN" ] && echo "CHOOSE player..."
				</code>
			</label>
			<button text="${HTML_karaoke_scriptname}">
				<code>
				player="${HTML_karaoke_scriptname}"
				if [ $(which "${player}" | wc -c ) -eq 0 ]
					then
					[ "${l}" = "IT" ] && echo "Err.: \"${player}\" non trovato..."
					[ "${l}" = "EN" ] && echo "Err.: \"${player}\" not found..."
				fi
				#
				midi="$(echo "${midi}" | sed s\#'^~'#"${HOME}"# )"
				if [ -f "${midi}" ]
					then
					export LD_LIBRARY_PATH="/usr/lib"
					${HTML_karaoke_scriptname} "${midi}" &
					:
				else
					[ "${l}" = "IT" ] && echo "Err.: \"${midi}\" non esiste..."
					[ "${l}" = "EN" ] && echo "Err.: \"${midi}\" does not exist..."
				fi
				</code>
			</button>
			<button text="${xterm_karaoke_scriptname}">
				<code>
				player="${xterm_karaoke_scriptname}"
				if [ $(which "${player}" | wc -c ) -eq 0 ]
					then
					[ "${l}" = "IT" ] && echo "Err.: \"${player}\" non trovato..."
					[ "${l}" = "EN" ] && echo "Err.: \"${player}\" not found..."
				fi
				#
				midi="$(echo "${midi}" | sed s\#'^~'#"${HOME}"# )"
				if [ -f "${midi}" ]
					then
					export LD_LIBRARY_PATH="/usr/lib"
					${xterm_karaoke_scriptname} "${midi}" &
					:
				else
					[ "${l}" = "IT" ] && echo "Err.: \"${midi}\" non esiste..."
					[ "${l}" = "EN" ] && echo "Err.: \"${midi}\" does not exist..."
				fi
				</code>
			</button>
BLOCCO_bkXbuc_2
	if [ $(echo -n "$(type "pykar" 2>/dev/null)" | wc -c) -gt 0 ]
		then
		cat <<-'BLOCCO_bkXbuc_pykar'
			<button text="pykar">
				<code>
				player="pykar"
				if [ $(which "${player}" | wc -c ) -eq 0 ]
					then
					[ "${l}" = "IT" ] && echo "Err.: \"${player}\" non trovato..."
					[ "${l}" = "EN" ] && echo "Err.: \"${player}\" not found..."
				fi
				#
				pykar_height_1=199
				pykar_height_2=324
				#
				midi="$(echo "${midi}" | sed s\#'^~'#"${HOME}"# )"
				if [ -f "${midi}" ]
					then
					pykar --width="1236" --height="${pykar_height_1}" --font-scale="3" --title="pykar: $(basename "${midi}")" "${midi}" &
					:
				else
					[ "${l}" = "IT" ] && echo "Err.: \"${midi}\" non esiste..."
					[ "${l}" = "EN" ] && echo "Err.: \"${midi}\" doesn't exist..."
				fi
				</code>
			</button>
BLOCCO_bkXbuc_pykar
	fi
	if [ $(echo -n "$(type "xplaymidi" 2>/dev/null)" | wc -c) -gt 0 ]
		then
		cat <<-'BLOCCO_bkXbuc_xplaymidi'
			<button text="xplaymidi">
				<code>
				player="xplaymidi"
				if [ $(which "${player}" | wc -c ) -eq 0 ]
					then
					[ "${l}" = "IT" ] && echo "Err.: \"${player}\" non trovato..."
					[ "${l}" = "EN" ] && echo "Err.: \"${player}\" not found..."
				fi
				#
				midi="$(echo "${midi}" | sed s\#'^~'#"${HOME}"# )"
				if [ -f "${midi}" ]
					then
					xplaymidi "${midi}" &
					:
				else
					[ "${l}" = "IT" ] && echo "Err.: \"${midi}\" non esiste..."
					[ "${l}" = "EN" ] && echo "Err.: \"${midi}\" doesn't exist..."
				fi
				</code>
			</button>
BLOCCO_bkXbuc_xplaymidi
	fi
	cat <<-'BLOCCO_bkXbuc_3'
			<button text="timidity">
				<code>
				player="timidity"
				if [ $(which "${player}" | wc -c ) -eq 0 ]
					then
					[ "${l}" = "IT" ] && echo "Err.: \"${player}\" non trovato..."
					[ "${l}" = "EN" ] && echo "Err.: \"${player}\" not found..."
				fi
				#
				midi="$(echo "${midi}" | sed s\#'^~'#"${HOME}"# )"
				if [ -f "${midi}" ]
					then
					#xterm -cr "${background}" -uc -bg "${background}" -fg "${foreground_2}" -fn "${font}" -geometry ${columns}x2+20+400 -e timidity -idt "${midi}" &
					#timidity ${soundfont_string} -A 105 --volume-compensation -iat "${midi}" &
					timidity -A 105 --volume-compensation -igt "${midi}" &
					:
				else
					[ "${l}" = "IT" ] && echo "Err.: \"${midi}\" non esiste..."
					[ "${l}" = "EN" ] && echo "Err.: \"${midi}\" doesn't exist..."
				fi
				</code>
			</button>
		</hlayout>

	</tab>


	<tab><title>[ "${l}" = "IT" ] && echo "Configura" ; [ "${l}" = "EN" ] && echo "Configure"</title>

		<tab><title>[ "${l}" = "IT" ] && echo "Finestre" ; [ "${l}" = "EN" ] && echo "Windows"</title>

			<tab><title>[ "${l}" = "IT" ] && echo "Modo" ; [ "${l}" = "EN" ] && echo "Mode"</title>
				<combobox var="scelta_Modo">
					<code>
					echo "BUC"
					echo "GTK (fullscreen)"
					echo "GSW"
					echo "auto"
					echo "gtkdialog"
					echo "Xdialog"
					echo "kdialog"
					echo "zenity"
					echo "dialog"
					</code>
				</combobox>
				<button>
					<text>
					[ "${l}" = "IT" ] && echo "salva"
					[ "${l}" = "EN" ] && echo "save"
					</text>
					<code>
					eval supermode_ORIG=$(cat "${ORIG}"| grep "supermode" | cut -d '=' -f 2 )
					if [ "${scelta_Modo}" = "BUC" ]
						then
						echo -n "use_buc => true"
						cat "${ORIG}" | sed s\#'use_buc=".*"'#'use_buc="true"'# 1> "${TEMP}"
						mv "${TEMP}" "${ORIG}"
						echo " [OK]"
						#
						echo -n "use_gsw => false"
						cat "${ORIG}" | sed s\#'use_gsw=".*"'#'use_gsw="false"'# 1> "${TEMP}"
						mv "${TEMP}" "${ORIG}"
						echo " [OK]"
						echo -n "use_gtk => false"
						cat "${ORIG}" | sed s\#'use_gtk=".*"'#'use_gtk="false"'# 1> "${TEMP}"
						mv "${TEMP}" "${ORIG}"
						echo " [OK]"
						#
						scelta_Modo="kdialog"
						#
					elif [ "${scelta_Modo}" = "GTK (fullscreen)" ]
						then
						if [ $(which "${bk_gtk_binary}" | wc -c ) -eq 0 ]
							then
							[ "${l}" = "IT" ] && echo " [fallito: nessun ${bk_gtk_binary} nel sistema...]"
							[ "${l}" = "EN" ] && echo " [failed: no ${bk_gtk_binary} in system...]"
							#
							echo -n "use_buc => true"
							cat "${ORIG}" | sed s\#'use_buc=".*"'#'use_buc="true"'# 1> "${TEMP}"
							mv "${TEMP}" "${ORIG}"
							echo " [OK]"
							#
							echo -n "use_gsw => false"
							cat "${ORIG}" | sed s\#'use_gsw=".*"'#'use_gsw="false"'# 1> "${TEMP}"
							mv "${TEMP}" "${ORIG}"
							echo " [OK]"
							echo -n "use_gtk => false"
							cat "${ORIG}" | sed s\#'use_gtk=".*"'#'use_gtk="false"'# 1> "${TEMP}"
							mv "${TEMP}" "${ORIG}"
							echo " [OK]"
							#
							scelta_Modo="kdialog"
							#
						else
							echo -n "use_gtk => true"
							cat "${ORIG}" | sed s\#'use_gtk=".*"'#'use_gtk="true"'# 1> "${TEMP}"
							mv "${TEMP}" "${ORIG}"
							echo " [OK]"
							#
							echo -n "use_buc => false"
							cat "${ORIG}" | sed s\#'use_buc=".*"'#'use_buc="false"'# 1> "${TEMP}"
							mv "${TEMP}" "${ORIG}"
							echo " [OK]"
							echo -n "use_gsw => false"
							cat "${ORIG}" | sed s\#'use_gsw=".*"'#'use_gsw="false"'# 1> "${TEMP}"
							mv "${TEMP}" "${ORIG}"
							echo " [OK]"
							#
							scelta_Modo="auto"
							#
						fi
						#
					elif [ "${scelta_Modo}" = "GSW" ]
						then
						if [ $(which "gtkdialog" | wc -c ) -eq 0 ]
							then
							[ "${l}" = "IT" ] && echo " [fallito: nessun gtkdialog nel sistema...]"
							[ "${l}" = "EN" ] && echo " [failed: no gtkdialog in system...]"
							#
							echo -n "use_buc => true"
							cat "${ORIG}" | sed s\#'use_buc=".*"'#'use_buc="true"'# 1> "${TEMP}"
							mv "${TEMP}" "${ORIG}"
							echo " [OK]"
							#
							echo -n "use_gsw => false"
							cat "${ORIG}" | sed s\#'use_gsw=".*"'#'use_gsw="false"'# 1> "${TEMP}"
							mv "${TEMP}" "${ORIG}"
							echo " [OK]"
							echo -n "use_gtk => false"
							cat "${ORIG}" | sed s\#'use_gtk=".*"'#'use_gtk="false"'# 1> "${TEMP}"
							mv "${TEMP}" "${ORIG}"
							echo " [OK]"
							#
							scelta_Modo="kdialog"
							#
						else
							echo -n "use_gsw => true"
							cat "${ORIG}" | sed s\#'use_gsw=".*"'#'use_gsw="true"'# 1> "${TEMP}"
							mv "${TEMP}" "${ORIG}"
							echo " [OK]"
							#
							echo -n "use_buc => false"
							cat "${ORIG}" | sed s\#'use_buc=".*"'#'use_buc="false"'# 1> "${TEMP}"
							mv "${TEMP}" "${ORIG}"
							echo " [OK]"
							echo -n "use_gtk => false"
							cat "${ORIG}" | sed s\#'use_gtk=".*"'#'use_gtk="false"'# 1> "${TEMP}"
							mv "${TEMP}" "${ORIG}"
							echo " [OK]"
							#
							scelta_Modo="gtkdialog"
							#
						fi
						#
					else
						echo -n "use_buc => false"
						cat "${ORIG}" | sed s\#'use_buc=".*"'#'use_buc="false"'# 1> "${TEMP}"
						mv "${TEMP}" "${ORIG}"
						echo " [OK]"
						#
					fi
					#
					echo -n "supermode (${supermode_ORIG}) => ${scelta_Modo}"
					if [ "${scelta_Modo}" = "${supermode_ORIG}" ]
						then
						[ "${l}" = "IT" ] && echo " [niente da cambiare...]"
						[ "${l}" = "EN" ] && echo " [nothing to change...]"
					else
						if [ "${scelta_Modo}" = "gtkdialog" -o "${scelta_Modo}" = "Xdialog" -o "${scelta_Modo}" = "kdialog" -o "${scelta_Modo}" = "zenity" -o "${scelta_Modo}" = "dialog" ]
							then
							if [ $(which "${scelta_Modo}" | wc -c ) -eq 0 ]
								then
								[ "${l}" = "IT" ] && echo " [fallito: nessun ${scelta_Modo} nel sistema...]"
								[ "${l}" = "EN" ] && echo " [failed: no ${scelta_Modo} in system...]"
							else
								cat "${ORIG}" | sed s\#'supermode=".*"'#"supermode=\"${scelta_Modo}\""# 1> "${TEMP}"
								mv "${TEMP}" "${ORIG}"
								echo " [OK]"
								#
								[ "${l}" = "IT" ] && echo "=> Riavvia bashkaraoke per vedere i cambiamenti..."
								[ "${l}" = "EN" ] && echo "=> Restart bashkaraoke to see changes..."
								#
							fi
						else
							#
							# that is: \${scelta_Modo} = "auto" ...
							#
							cat "${ORIG}" | sed s\#'supermode=".*"'#"supermode=\"${scelta_Modo}\""# 1> "${TEMP}"
							mv "${TEMP}" "${ORIG}"
							echo " [OK]"
							#
							[ "${l}" = "IT" ] && echo "=> Riavvia bashkaraoke per vedere i cambiamenti..."
							[ "${l}" = "EN" ] && echo "=> Restart bashkaraoke to see changes..."
							#
						fi
					fi
					</code>
				</button>
			</tab>

			<tab><title>[ "${l}" = "IT" ] && echo "Tipo" ; [ "${l}" = "EN" ] && echo "Type"</title>
				<checkbox var="karaoke_window_0_1">
					<text>
					[ "${l}" = "IT" ] && echo "Karaoke (clicca per abilitare)"
					[ "${l}" = "EN" ] && echo "Karaoke (check to enable)"
					</text>
				</checkbox>
				<checkbox var="levels_window_0_1">
					<text>
					[ "${l}" = "IT" ] && echo "Livelli (clicca per abilitare)"
					[ "${l}" = "EN" ] && echo "Levels (check to enable)"
					</text>
				</checkbox>
				<checkbox var="channels_window_0_1">
					<text>
					[ "${l}" = "IT" ] && echo "Canali (clicca per abilitare)"
					[ "${l}" = "EN" ] && echo "Channels (check to enable)"
					</text>
				</checkbox>
				<checkbox var="spectrogram_window_0_1">
					<text>
					[ "${l}" = "IT" ] && echo "Spettrogramma (clicca per abilitare)"
					[ "${l}" = "EN" ] && echo "Spectrogram (check to enable)"
					</text>
				</checkbox>
				<button>
					<text>
					[ "${l}" = "IT" ] && echo "salva"
					[ "${l}" = "EN" ] && echo "save"
					</text>
					<code>
					cat "${ORIG}" 1> "${TEMP1}"
					#
					[ ${karaoke_window_0_1} -eq 1 ] && karaoke_window="true" || karaoke_window="false"
					echo -n "karaoke_window => ${karaoke_window}"
					cat "${TEMP1}" | sed s\#'karaoke_window=".*"'#"karaoke_window=\"${karaoke_window}\""# 1> "${TEMP2}"
					echo " [OK]"
					#
					[ ${levels_window_0_1} -eq 1 ] && levels_window="true" || levels_window="false"
					echo -n "levels_window => ${levels_window}"
					cat "${TEMP2}" | sed s\#'levels_window=".*"'#"levels_window=\"${levels_window}\""# 1> "${TEMP1}"
					echo " [OK]"
					#
					[ ${channels_window_0_1} -eq 1 ] && channels_window="true" || channels_window="false"
					echo -n "channels_window => ${channels_window}"
					cat "${TEMP1}" | sed s\#'channels_window=".*"'#"channels_window=\"${channels_window}\""# 1> "${TEMP2}"
					echo " [OK]"
					#
					[ ${spectrogram_window_0_1} -eq 1 ] && spectrogram_window="true" || spectrogram_window="false"
					echo -n "spectrogram_window => ${spectrogram_window}"
					cat "${TEMP2}" | sed s\#'spectrogram_window=".*"'#"spectrogram_window=\"${spectrogram_window}\""# 1> "${TEMP1}"
					echo " [OK]"
					#
					mv "${TEMP1}" "${ORIG}"
					#echo " [DONE]"
					#
					</code>
				</button>
			</tab>
		</tab>


		<tab><title>[ "${l}" = "IT" ] && echo "Estetica" ; [ "${l}" = "EN" ] && echo "Apparence"</title>

			<tab><title>[ "${l}" = "IT" ] && echo "Colonne" ; [ "${l}" = "EN" ] && echo "Columns"</title>
				<label/>
				<label>
					<code>
					[ "${l}" = "IT" ] && echo "Quanti caratteri in orizzontale nella finestra Karaoke..."
					[ "${l}" = "EN" ] && echo "How many horizontal chars in Karaoke window..."
					</code>
				</label>
				<text var="columns">
					<code>
					echo "24"
					</code>
				</text>
				<button>
					<text>
					[ "${l}" = "IT" ] && echo "salva"
					[ "${l}" = "EN" ] && echo "save"
					</text>
					<code>
					eval columns_ORIG=$(cat "${ORIG}"| grep "columns" | cut -d '=' -f 2 )
					echo -n "columns => ${columns}"
					if [ "${columns}" = "${columns_ORIG}" ]
						then
						[ "${l}" = "IT" ] && echo " [niente da cambiare...]"
						[ "${l}" = "EN" ] && echo " [nothing to change...]"
					else
						cat "${ORIG}" | sed s\#'col.*n.*=".*"'#"columns=\"${columns}\""# 1> "${TEMP}"
						mv "${TEMP}" "${ORIG}"
						echo " [OK]"
					fi
					</code>
				</button>
			</tab>

			<tab><title>[ "${l}" = "IT" ] && echo "Tipo carattere" ; [ "${l}" = "EN" ] && echo "Font"</title>
				<label/>
				<label>
					<code>
					[ "${l}" = "IT" ] && echo "Tipo di carattere nella finestra Karaoke..."
					[ "${l}" = "EN" ] && echo "Font type in Karaoke window..."
					</code>
				</label>
				<text var="font">
					<code>
					echo "-b&h-lucidatypewriter-medium-r-normal-sans-70-*-*-*-*-*-iso8859-1"
					</code>
				</text>
				<button>
					<text>
					[ "${l}" = "IT" ] && echo "salva"
					[ "${l}" = "EN" ] && echo "save"
					</text>
					<code>
					eval font_ORIG=$(cat "${ORIG}"| grep "font" | cut -d '=' -f 2 )
					echo -n "font => ${font}"
					if [ "${font}" = "${font_ORIG}" ]
						then
						[ "${l}" = "IT" ] && echo " [niente da cambiare...]"
						[ "${l}" = "EN" ] && echo " [nothing to change...]"
					else
						cat "${ORIG}" | sed s\#'font=".*"'#"font=\"${font}\""# 1> "${TEMP}"
						mv "${TEMP}" "${ORIG}"
						echo " [OK]"
					fi
					</code>
				</button>
			</tab>

			<tab><title>[ "${l}" = "IT" ] && echo "Colore sfondo" ; [ "${l}" = "EN" ] && echo "Background color"</title>
				<label/>
				<label>
					<code>
					[ "${l}" = "IT" ] && echo "Colore sfondo nella finestra Karaoke..."
					[ "${l}" = "EN" ] && echo "Background color in Karaoke window..."
					</code>
				</label>
				<iconlist var="background">
					<icon text="black">
						<src>
						echo "${black_icon}"
						</src>
					</icon>
					<icon text="red">
						<src>
						echo "${red_icon}"
						</src>
					</icon>
					<icon text="green">
						<src>
						echo "${green_icon}"
						</src>
					</icon>
					<icon text="yellow">
						<src>
						echo "${yellow_icon}"
						</src>
					</icon>
					<icon text="blue">
						<src>
						echo "${blue_icon}"
						</src>
					</icon>
					<icon text="magenta">
						<src>
						echo "${magenta_icon}"
						</src>
					</icon>
					<icon text="cyan">
						<src>
						echo "${cyan_icon}"
						</src>
					</icon>
					<icon text="white">
						<src>
						echo "${white_icon}"
						</src>
					</icon>
				</iconlist>
				<button>
					<text>
					[ "${l}" = "IT" ] && echo "salva"
					[ "${l}" = "EN" ] && echo "save"
					</text>
					<code>
					eval background_ORIG=$(cat "${ORIG}"| grep "background" | cut -d '=' -f 2 )
					echo -n "background => ${background}"
					if [ "${background}" = "${background_ORIG}" ]
						then
						[ "${l}" = "IT" ] && echo " [niente da cambiare...]"
						[ "${l}" = "EN" ] && echo " [nothing to change...]"
					else
						cat "${ORIG}" | sed s\#'background=".*"'#"background=\"${background}\""# 1> "${TEMP}"
						mv "${TEMP}" "${ORIG}"
						echo " [OK]"
					fi
					</code>
				</button>
			</tab>

			<tab><title>[ "${l}" = "IT" ] && echo "Colore testo gia' cantato" ; [ "${l}" = "EN" ] && echo "Lyric color (already sung)"</title>
				<label/>
				<label>
					<code>
					[ "${l}" = "IT" ] && echo "Colore testo gia' cantato nella finestra Karaoke..."
					[ "${l}" = "EN" ] && echo "Lyric color (already sung) in Karaoke window..."
					</code>
				</label>
				<iconlist var="foreground_1">
					<icon text="black">
						<src>
						echo "${black_icon}"
						</src>
					</icon>
					<icon text="red">
						<src>
						echo "${red_icon}"
						</src>
					</icon>
					<icon text="green">
						<src>
						echo "${green_icon}"
						</src>
					</icon>
					<icon text="yellow">
						<src>
						echo "${yellow_icon}"
						</src>
					</icon>
					<icon text="blue">
						<src>
						echo "${blue_icon}"
						</src>
					</icon>
					<icon text="magenta">
						<src>
						echo "${magenta_icon}"
						</src>
					</icon>
					<icon text="cyan">
						<src>
						echo "${cyan_icon}"
						</src>
					</icon>
					<icon text="white">
						<src>
						echo "${white_icon}"
						</src>
					</icon>
				</iconlist>
				<button>
					<text>
					[ "${l}" = "IT" ] && echo "salva"
					[ "${l}" = "EN" ] && echo "save"
					</text>
					<code>
					eval foreground_1_ORIG=$(cat "${ORIG}"| grep "foreground_1" | cut -d '=' -f 2 )
					echo -n "foreground_1 => ${foreground_1}"
					if [ "${foreground_1}" = "${foreground_1_ORIG}" ]
						then
						[ "${l}" = "IT" ] && echo " [niente da cambiare...]"
						[ "${l}" = "EN" ] && echo " [nothing to change...]"
					else
						cat "${ORIG}" | sed s\#'foreground_1=".*"'#"foreground_1=\"${foreground_1}\""# 1> "${TEMP}"
						mv "${TEMP}" "${ORIG}"
						echo " [OK]"
					fi
					</code>
				</button>
			</tab>

			<tab><title>[ "${l}" = "IT" ] && echo "Colore testo da cantare" ; [ "${l}" = "EN" ] && echo "Lyric color (to sing)"</title>
				<label/>
				<label>
					<code>
					[ "${l}" = "IT" ] && echo "Colore testo ancora da cantare nella finestra Karaoke..."
					[ "${l}" = "EN" ] && echo "Lyric color (still to sing) in Karaoke window..."
					</code>
				</label>
				<iconlist var="foreground_2">
					<icon text="black">
						<src>
						echo "${black_icon}"
						</src>
					</icon>
					<icon text="red">
						<src>
						echo "${red_icon}"
						</src>
					</icon>
					<icon text="green">
						<src>
						echo "${green_icon}"
						</src>
					</icon>
					<icon text="yellow">
						<src>
						echo "${yellow_icon}"
						</src>
					</icon>
					<icon text="blue">
						<src>
						echo "${blue_icon}"
						</src>
					</icon>
					<icon text="magenta">
						<src>
						echo "${magenta_icon}"
						</src>
					</icon>
					<icon text="cyan">
						<src>
						echo "${cyan_icon}"
						</src>
					</icon>
					<icon text="white">
						<src>
						echo "${white_icon}"
						</src>
					</icon>
				</iconlist>
				<button>
					<text>
					[ "${l}" = "IT" ] && echo "salva"
					[ "${l}" = "EN" ] && echo "save"
					</text>
					<code>
					eval foreground_2_ORIG=$(cat "${ORIG}"| grep "foreground_2" | cut -d '=' -f 2 )
					echo -n "foreground_2 => ${foreground_2}"
					if [ "${foreground_2}" = "${foreground_2_ORIG}" ]
						then
						[ "${l}" = "IT" ] && echo " [niente da cambiare...]"
						[ "${l}" = "EN" ] && echo " [nothing to change...]"
					else
						cat "${ORIG}" | sed s\#'foreground_2=".*"'#"foreground_2=\"${foreground_2}\""# 1> "${TEMP}"
						mv "${TEMP}" "${ORIG}"
						echo " [OK]"
					fi
					</code>
				</button>
			</tab>
		</tab>

		<tab><title>[ "${l}" = "IT" ] && echo "Suono" ; [ "${l}" = "EN" ] && echo "Sound"</title>
			<label/>
			<label>
				<code>
				[ "${l}" = "IT" ] && echo "Per favore, seleziona il soundfont..."
				[ "${l}" = "EN" ] && echo "Please, select soundfont..."
				</code>
			</label>
			<file var="soundfont" mode="open" />
			<button>
				<text>
				[ "${l}" = "IT" ] && echo "salva"
				[ "${l}" = "EN" ] && echo "save"
				</text>
				<code>
				eval soundfont_ORIG=$(cat "${ORIG}"| grep "soundfont" | cut -d '=' -f 2 )
				echo -n "soundfont => ${soundfont}"
				if [ "${soundfont}" = "${soundfont_ORIG}" ]
					then
					[ "${l}" = "IT" ] && echo " [niente da cambiare...]"
					[ "${l}" = "EN" ] && echo " [nothing to change...]"
				else
					cat "${ORIG}" | sed s\#'soundfont=".*"'#"soundfont=\"${soundfont}\""# 1> "${TEMP}"
					mv "${TEMP}" "${ORIG}"
					echo " [OK]"
				fi
				</code>
			</button>
		</tab>


		<tab><title>[ "${l}" = "IT" ] && echo "Avanzato" ; [ "${l}" = "EN" ] && echo "Advanced"</title>
			<tab><title>[ "${l}" = "IT" ] && echo "Estrazione testo canzone" ; [ "${l}" = "EN" ] && echo "Lyric extraction"</title>
				<combobox var="extract_way">
					<code>
					echo "internal"
					[ "${l}" = "IT" ] && echo "through__midi_text24_pl (serve midi_text24.pl)"
					[ "${l}" = "EN" ] && echo "through__midi_text24_pl (you need midi_text24.pl)"
					[ "${l}" = "IT" ] && echo "through__pykar (serve pykar)"
					[ "${l}" = "EN" ] && echo "through__pykar (you need pykar)"
					</code>
				</combobox>
				<button>
					<text>
					[ "${l}" = "IT" ] && echo "salva"
					[ "${l}" = "EN" ] && echo "save"
					</text>
					<code>
					extract_way="$(echo "${extract_way}" | cut -d '(' -f 1 | cut -d ' ' -f 1 )"
					#									
					eval extract_way_ORIG=$(cat "${ORIG}"| grep "extract_way" | cut -d '=' -f 2 )
					echo -n "extract_way => ${extract_way}"
					if [ "${extract_way}" = "${extract_way_ORIG}" ]
						then
						[ "${l}" = "IT" ] && echo " [niente da cambiare...]"
						[ "${l}" = "EN" ] && echo " [nothing to change...]"
					else
						cat "${ORIG}" | sed s\#'extract_way=".*"'#"extract_way=\"${extract_way}\""# 1> "${TEMP}"
						mv "${TEMP}" "${ORIG}"
						echo " [OK]"
					fi
					</code>
				</button>
			</tab>

			<tab><title>[ "${l}" = "IT" ] && echo "Rapporto tolleranza agli errori/precisione" ; [ "${l}" = "EN" ] && echo "Error tolerance/precision ratio"</title>
				<combobox var="error_correction_chars">
					<code>
					[ "${l}" = "IT" ] && echo "0 (nessuna tolleranza/precisione perfetta)"
					[ "${l}" = "EN" ] && echo "0 (no tolerance/perfect precision)"
					[ "${l}" = "IT" ] && echo "1 (tolleranza media/precisione media)"
					[ "${l}" = "EN" ] && echo "1 (average tolerance/average precision)"
					[ "${l}" = "IT" ] && echo "2 (tolleranza alta/precisione bassa)"
					[ "${l}" = "EN" ] && echo "2 (high tolerance/low precision)"
					</code>
				</combobox>
				<button>
					<text>
					[ "${l}" = "IT" ] && echo "salva"
					[ "${l}" = "EN" ] && echo "save"
					</text>
					<code>
					error_correction_chars="$(echo "${error_correction_chars}" | cut -d '(' -f 1 | tr -dc '[[:digit:]]' )"
					#
					eval error_correction_chars_ORIG=$(cat "${ORIG}"| grep "error_correction_chars" | cut -d '=' -f 2 )
					echo -n "error_correction_chars => ${error_correction_chars}"
					if [ "${error_correction_chars}" = "${error_correction_chars_ORIG}" ]
						then
						[ "${l}" = "IT" ] && echo " [niente da cambiare...]"
						[ "${l}" = "EN" ] && echo " [nothing to change...]"
					else
						cat "${ORIG}" | sed s\#'error_correction_chars=".*"'#"error_correction_chars=\"${error_correction_chars}\""# 1> "${TEMP}"
						mv "${TEMP}" "${ORIG}"
						echo " [OK]"
					fi
					</code>
				</button>
			</tab>
		</tab>



		<tab><title>[ "${l}" = "IT" ] && echo "Varie" ; [ "${l}" = "EN" ] && echo "Misc"</title>

			<tab><title>[ "${l}" = "IT" ] && echo "Lingua delle canzoni" ; [ "${l}" = "EN" ] && echo "Song language"</title>
				<label/>
				<label>
					<code>
					[ "${l}" = "IT" ] && echo "Questo influisce anche sulla lingua del programma..."
					[ "${l}" = "EN" ] && echo "This affects also program language..."
					</code>
				</label>
				<combobox var="LANG_pre">
					<code>
					locale -a | grep -i "\.UTF.\?8"
					</code>
				</combobox>
				<button>
					<text>
					[ "${l}" = "IT" ] && echo "salva"
					[ "${l}" = "EN" ] && echo "save"
					</text>
					<code>
					LANG="$(echo -n "${LANG_pre}" | cut -d '.' -f 1 ).UTF-8"
					#
					eval LANG_ORIG=$(cat "${ORIG}"| grep "LANG" | cut -d '=' -f 2 )
					echo -n "LANG => ${LANG}"
					if [ "${LANG}" = "${LANG_ORIG}" ]
						then
						[ "${l}" = "IT" ] && echo " [niente da cambiare...]"
						[ "${l}" = "EN" ] && echo " [nothing to change...]"
					else
						cat "${ORIG}" | sed s\#'LANG=".*"'#"LANG=\"${LANG}\""# 1> "${TEMP}"
						mv "${TEMP}" "${ORIG}"
						echo " [OK]"
					fi
					</code>
				</button>
			</tab>

			<tab><title>[ "${l}" = "IT" ] && echo "Codifica dei caratteri" ; [ "${l}" = "EN" ] && echo "Character encoding"</title>
				<label/>
				<label>
					<code>
					[ "${l}" = "IT" ] && echo "Per mostrare correttamente i caratteri internazionali..."
					[ "${l}" = "EN" ] && echo "To correctly show international (non english) characters..."
					</code>
				</label>
				<combobox var="char_encoding">
					<code>
					iconv -l | sed s\#'//'#''# | grep -i iso
					</code>
				</combobox>
				<button>
					<text>
					[ "${l}" = "IT" ] && echo "salva"
					[ "${l}" = "EN" ] && echo "save"
					</text>
					<code>
					eval char_encoding_ORIG=$(cat "${ORIG}"| grep "char_encoding" | cut -d '=' -f 2 )
					echo -n "char_encoding => ${char_encoding}"
					if [ "${char_encoding}" = "${char_encoding_ORIG}" ]
						then
						[ "${l}" = "IT" ] && echo " [niente da cambiare...]"
						[ "${l}" = "EN" ] && echo " [nothing to change...]"
					else
						cat "${ORIG}" | sed s\#'char_encoding=".*"'#"char_encoding=\"${char_encoding}\""# 1> "${TEMP}"
						mv "${TEMP}" "${ORIG}"
						echo " [OK]"
					fi
					</code>
				</button>
			</tab>
		</tab>


	<label/>
	<button>
		<text>
		[ "${l}" = "IT" ] && echo "torna alla configurazione di default"
		[ "${l}" = "EN" ] && echo "back to default configuration"
		</text>
		<code>
		: 1> "${ORIG}"
		#
		echo -n "use_gtk => false"
		echo "export use_gtk=\"false\"" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "use_gsw => false"
		echo "export use_gsw=\"false\"" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "use_buc => false"
		echo "export use_buc=\"false\"" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "supermode => auto"
		echo "export supermode=\"auto\"" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "karaoke_window => true"
		echo "export karaoke_window=\"true\"" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "levels_window => true"
		echo "export levels_window=\"true\"" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "channels_window => false"
		echo "export channels_window=\"false\"" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "spectrogram_window => false"
		echo "export spectrogram_window=\"false\"" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "rows => 2"
		echo "export rows=2" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "columns => 24"
		echo "export columns=24" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "font => -b&h-lucidatypewriter-medium-r-normal-sans-70-*-*-*-*-*-iso8859-1"
		echo "export font=\"-b&h-lucidatypewriter-medium-r-normal-sans-70-*-*-*-*-*-iso8859-1\"" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "background => ${dbg}"
		echo "export background=\"${dbg}\"" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "foreground_1 => ${dfg1}"
		echo "export foreground_1=\"${dfg1}\"" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "foreground_2 => ${dfg2}"
		echo "export foreground_2=\"${dfg2}\"" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "soundfont => /usr/local/share/timidity/PC51f.sf2"
		echo "export soundfont=\"/usr/local/share/timidity/PC51f.sf2\"" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "extract_way => internal"
		echo "export extract_way=\"internal\"" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "error_correction_chars => 0"
		echo "export error_correction_chars=\"0\"" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "LANG => en_GB.UTF-8"
		echo "export LANG=\"en_GB.UTF-8\"" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "char_encoding => ISO-8859-1"
		echo "export char_encoding=\"ISO-8859-1\"" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "delimiter => ______________________________________"
		echo "export delimiter=\"______________________________________\"" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "default_Volume => ${dv}"
		echo "export predefvolume=${dv}" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "default_Pitch => ${dp}"
		echo "export predefpitch=${dp}" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "default_Tempo => ${dt}"
		echo "export predefspeed=${dt}" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "default_font_family => ${dff}"
		echo "export font_family=${dff}" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "show_debug => 0"
		echo "export show_debug=0" 1>> "${ORIG}"
		echo " [OK]"
		#
		echo -n "show_tabs => 0"
		echo "export show_tabs=0" 1>> "${ORIG}"
		echo " [OK]"
		</code>
	</button>

	<label/>
	<textlog/>
	</tab>
	

	<tab><title>[ "${l}" = "IT" ] && echo "Informazioni" ; [ "${l}" = "EN" ] && echo "About"</title>
		<label/>
		<label>
			<code>
			[ "${l}" = "IT" ] && echo "BashKaraoke v.${BK_VERSION_NUMBER} basata su BUC v.0.5.2"
			[ "${l}" = "EN" ] && echo "BashKaraoke v.${BK_VERSION_NUMBER} based on BUC v.0.5.2"
			</code>
		</label>
		<label/>
		<label>
			<code>
			[ "${l}" = "IT" ] && echo "BashKaraoke e' un programma karaoke open source, fondamentalmente un frontend di backend players (come Timidity)."
			[ "${l}" = "EN" ] && echo "BashKaraoke is an open source karaoke program, basically it's a backend player frontend (like Timidity)."
			</code>
		</label>
		<label/>
		<label/>
		<tab><title>[ "${l}" = "IT" ] && echo "Autore" ; [ "${l}" = "EN" ] && echo "Author"</title>
			<label>
				<code>
				echo "Vittorio Cagnetta"
				echo "	vaisarger@gmail.com"
				echo
				echo "Davide Depau"
				echo "	david.dep.1996@gmail.com"
				echo
				</code>
			</label>
		</tab>
		<tab><title>[ "${l}" = "IT" ] && echo "Ringraziamenti" ; [ "${l}" = "EN" ] && echo "Thanks"</title>
			<label>
				<code>
				echo "Timidity: All timidity people"
				echo "	:)"
				echo ""
				echo "embedded browser, bashkaraoke-gtk: Davide Depau"
				echo "	david.dep.1996@gmail.com"
				echo ""
				echo "BUC: Matteo Avalle, Valerio Billera"
				echo "	smat@sicilinux.org"
				</code>
			</label>
		</tab>
	</tab>

</config>
BLOCCO_bkXbuc_3
	}
#
#
#
outputta_bkXgtkdialog()
	{
	cat <<BLOCCO_bkXgtkdialog
	
<window title="Bash!Karaoke ${BK_VERSION_NUMBER}: bash the microphone and break your music!" default_height="${height}" default_width="${width}" window_position="1" icon-name="gtk-dialog-info">
	<vbox scrollable="true">
		$(
		[ "${l}" = "IT" ] && echo "<notebook labels=\"Suona|Configura|Informazioni\">" 
		[ "${l}" = "EN" ] && echo "<notebook labels=\"Play|Configure|About\">" 
		)
			<frame>
				<frame>
					<pixmap>
						<input file>${gsw_BK_icon}</input>
					</pixmap>
				</frame>
				
				<frame Midi Database>
					
						$(
						[ "${l}" = "IT" ] && echo "<button tooltip-text=\" RICERCA il midi nel database... \">" 
						[ "${l}" = "EN" ] && echo "<button tooltip-text=\" SEARCH midi in database... \">" 
						)
							<input file>${gsw_sing_BK_icon}</input>
							<action type="launch">GSW_SEARCH_DIALOG</action>
						</button>
					
						$(
						[ "${l}" = "IT" ] && echo "<button tooltip-text=\" AGGIORNA il database... \">" 
						[ "${l}" = "EN" ] && echo "<button tooltip-text=\" UPDATE database... \">" 
						)
							<input file stock="gtk-save"></input>
							<action type="launch">GSW_DIR_DIALOG</action>
						</button>
					
				</frame>
				
				<frame Filesystem>
					
						$(
						[ "${l}" = "IT" ] && echo "<button tooltip-text=\" SELEZIONA il midi direttamente nel filesystem... \">" 
						[ "${l}" = "EN" ] && echo "<button tooltip-text=\" SELECT midi directly in filesystem... \">" 
						)
							<input file stock="gtk-open"></input>
							<action type="launch">GSW_FILE_DIALOG</action>
						</button>
					
				</frame>
			</frame>
			
			
			
			
		
			<frame>
				
				
				$(
				[ "${l}" = "IT" ] && echo "<frame Configurazioni>" 
				[ "${l}" = "EN" ] && echo "<frame Settings>" 
				)
				
					<text>
						<input file>"${dir_Karaoke}/${rc_file}"</input>
						<variable>SETTINGS</variable>
					</text>
					
					
					
					$(
					[ "${l}" = "IT" ] && echo "<button tooltip-text=\" CONFIGURA $(basename "${0}" )... \">" 
					[ "${l}" = "EN" ] && echo "<button tooltip-text=\" CONFIGURE $(basename "${0}" )... \">" 
					)
						<input file stock="gtk-edit"></input>
						<action type="command">bash -c "source ${bk_COMMON}; modifica_rc ; clean_temp"</action>
						<action type="refresh">SETTINGS</action>
					</button>
					
					$(
					[ "${l}" = "IT" ] && echo "<button tooltip-text=\" TORNA alla configurazione di default... \">" 
					[ "${l}" = "EN" ] && echo "<button tooltip-text=\" GO BACK to default configuration... \">" 
					)
						<input file stock="gtk-home"></input>
						<action type="command">bash -c "source ${bk_COMMON}; crea_rc_default 1> ${dir_Karaoke}/${rc_file} ; clean_temp"</action>
						<action type="refresh">SETTINGS</action>
					</button>
				
				</frame>
			
				
			</frame>
	
		
		
		
		
		
			<frame>
				<frame>
					<pixmap>
						<input file>${gsw_BK_DOUBLE_icon}</input>
					</pixmap>
				</frame>
				
				$(
				[ "${l}" = "IT" ] && echo "<notebook labels=\"Informazioni|Autore|Ringraziamenti\">" 
				[ "${l}" = "EN" ] && echo "<notebook labels=\"About|Author|Thanks\">" 
				)
				<vbox>
					<frame>
						<pixmap xalign="0">
							<input file stock="gtk-dialog-info"></input>
						</pixmap>
						<text xalign="2">
							$(
							[ "${l}" = "IT" ] && echo "<label>\"Bash!Karaoke v.${BK_VERSION_NUMBER} basata su Gtkdialog ${required_gtkdialog_first_field}.${required_gtkdialog_second_field}.${required_gtkdialog_third_field}
					
Bash!Karaoke e' un programma karaoke open source, fondamentalmente un frontend di backend players (come Timidity).\"</label>" 
							[ "${l}" = "EN" ] && echo "<label>\"Bash!Karaoke v.${BK_VERSION_NUMBER} based on Gtkdialog ${required_gtkdialog_first_field}.${required_gtkdialog_second_field}.${required_gtkdialog_third_field}
					
Bash!Karaoke is an open source karaoke program, basically is a frontend to backend players (like Timidity).\"</label>" 
							)
						</text>
					</frame>
				</vbox>
				<vbox>
					<frame>
						<pixmap xalign="0">
							<input file stock="gtk-dialog-info"></input>
						</pixmap>
						<text xalign="2">
							<label>"Vittorio Cagnetta (vaisarger@gmail.com)
Davide Depau (david.dep.1996@gmail.com)"</label>
						</text>
					</frame>
				</vbox>
				<vbox>
					<frame>
						<text xalign="2">
							<label>"Timidity: All timidity people :)
							
Gtkdialog: Laszlo Pere, Matyas Koniorczyk -old developers- and Thunor -current developer- (thunorsif@hotmail.com) 

embedded browser, bashkaraoke-gtk: Davide Depau (david.dep.1996@gmail.com) "</label>
						</text>
					</frame>
				</vbox>
				</notebook>
			</frame>
		
			
			
		</notebook>
		<hbox>
			<button use-stock="true" label="gtk-quit"></button>
		</hbox>
	</vbox>
</window>

BLOCCO_bkXgtkdialog
	}
#
#
#
[ "${l}" = "IT" ] && export GSW_SEARCH_DIALOG_title="Bash!Karaoke: digita artista e/o canzone..."
[ "${l}" = "EN" ] && export GSW_SEARCH_DIALOG_title="Bash!Karaoke: type artist and/or song name..."
export GSW_SEARCH_DIALOG="
	<window title=\"${GSW_SEARCH_DIALOG_title}\" window_position=\"1\" default_width=\"400\">"'
		<vbox>
			<frame>
				<hbox>
				<entry>
					<input>cat ${dummy_file}</input>
					<variable>STRING_TO_FIND</variable>
				</entry>
				<button>
					<input file stock="gtk-find"></input>
					<action type="command">echo ATREASUREINSIDEANDSTRONGOUTSIDEMYPOWERISTHESHELL=$STRING_TO_FIND</action>
					<action type="launch">GSW_LIST_DIALOG</action>
					<action type="closewindow">GSW_SEARCH_DIALOG</action>
				</button>
				</hbox>
			</frame>
			<hbox>
				<button use-stock="true" label="gtk-close">
					<action type="closewindow">GSW_SEARCH_DIALOG</action>
				</button>
			</hbox>
		</vbox>
	</window>
'
#
#
#
# <action type="command">${bk_extractor} "$CHOISES" 1>${info_file} ; export info_file ; bash -c "source ${bk_COMMON}; cat \"${info_file}\" | text ; clean_temp"</action>
[ "${l}" = "IT" ] && export GSW_LIST_DIALOG_title="Bash!Karaoke: seleziona il midi..."
[ "${l}" = "EN" ] && export GSW_LIST_DIALOG_title="Bash!Karaoke: select midi..."
export GSW_LIST_DIALOG="
	<window title=\"${GSW_LIST_DIALOG_title}\" window_position=\"1\" default_width=\"500\">"'
		<vbox>
			<frame Midi list>
				<table>
					<variable>CHOISES</variable>
					<input>sleep 2; cat "${dir_Karaoke}/lista_karaoke.txt"</input>
				</table>
				<hbox>
					<button>
						<label>'${HTML_karaoke_scriptname}'</label>
						<action type="command">'${HTML_karaoke_scriptname}' "$CHOISES"</action>
						<action type="closewindow">GSW_SEARCH_DIALOG</action>
						<action type="closewindow">GSW_LIST_DIALOG</action>
					</button>
					<button>
						<label>'${xterm_karaoke_scriptname}'</label>
						<action type="command">'${xterm_karaoke_scriptname}' "$CHOISES"</action>
						<action type="closewindow">GSW_SEARCH_DIALOG</action>
						<action type="closewindow">GSW_LIST_DIALOG</action>
					</button>
					<button>
						<label>pykar</label>
						<action type="command">pykar_height_1=199; pykar_height_2=324 ; pykar --width="1236" --height="${pykar_height_1}" --font-scale="3" --title="pykar: $(basename "$CHOISES")" "$CHOISES"</action>
						<action type="closewindow">GSW_SEARCH_DIALOG</action>
						<action type="closewindow">GSW_LIST_DIALOG</action>
					</button>
					<button>
						<label>xplaymidi</label>
						<action type="command">xplaymidi "$CHOISES"</action>
						<action type="closewindow">GSW_SEARCH_DIALOG</action>
						<action type="closewindow">GSW_LIST_DIALOG</action>
					</button>
					<button>
						<label>timidity</label>
						<action type="command">timidity -A 105 --volume-compensation -igt "$CHOISES"</action>
						<action type="closewindow">GSW_SEARCH_DIALOG</action>
						<action type="closewindow">GSW_LIST_DIALOG</action>
					</button>
					<button>
						<input file stock="gtk-edit"></input>
						<action type="command">export CHOISES ; bash -c "source ${bk_COMMON}; extract_song_lyric \"${CHOISES}\" ; clean_temp"</action>
					</button>
					<button>
						<input file stock="gtk-info"></input>
						<action type="command">export CHOISES ; bash -c "source ${bk_COMMON}; message \"$(${bk_OUT} -i "${CHOISES}" )\" ; clean_temp"</action>
					</button>
				</hbox>
			</frame>
			<hbox>
				<button use-stock="true" label="gtk-close">
					<action type="closewindow">GSW_LIST_DIALOG</action>
				</button>
			</hbox>
		</vbox>
	</window>
'
#
#
#
[ "${l}" = "IT" ] && export GSW_DIR_DIALOG_title="Bash!Karaoke: seleziona la cartella..."
[ "${l}" = "EN" ] && export GSW_DIR_DIALOG_title="Bash!Karaoke: select directory..."
export GSW_DIR_DIALOG="
	<window title=\"${GSW_DIR_DIALOG_title}\" window_position=\"1\" default_width=\"400\">"'
		<vbox>
			<frame>
				<frame Midi directory>
					<hbox>
						<entry accept="directory">
							<label>Select a Directory</label>
							<variable>FILE_DIRECTORY</variable>
						</entry>
					<button>
						<input file stock="gtk-save"></input>
						<variable>BROWSE_DIRECTORY</variable>
						<action type="fileselect">FILE_DIRECTORY</action>
						
					</button>
					</hbox>
				</frame>
				<button ok>
					<action type="command">echo $FILE_DIRECTORY</action>
					<action type="command">echo ${extensions}</action>
					<action type="command">cd "$FILE_DIRECTORY" ; if [ -f "${database}" ] ; then mv "${database}" "${database}_OLD" ; fi ; echo "" 1> "${database}" ; for ext in ${extensions} ; do xterm -e "export supermode=dialog ; source easybashgui ; wait_for Searching${ext}... ; find ./ -type f | fgrep -i ${ext} 1>> "${database}_TEMP" ; sleep 1 ; terminate_wait_for; clean_temp" ; done ; cat "${database}_TEMP" | sed s\#'^./'#"$(pwd)/"# | sort 1> "${database}" ; rm "${database}_TEMP"</action>
					<action type="closewindow">GSW_DIR_DIALOG</action>
				</button>
			</frame>
			<hbox>
				<button use-stock="true" label="gtk-close">
					<action type="closewindow">GSW_DIR_DIALOG</action>
				</button>
			</hbox>
		</vbox>
	</window>
'
#
#
#
[ "${l}" = "IT" ] && export GSW_FILE_DIALOG_title="Bash!Karaoke: seleziona il file..."
[ "${l}" = "EN" ] && export GSW_FILE_DIALOG_title="Bash!Karaoke: select file..."
export GSW_FILE_DIALOG="
	<window title=\"${GSW_FILE_DIALOG_title}\" window_position=\"1\" default_width=\"500\">"'
		<vbox>
			<frame Midi filename>
				<frame>
					<hbox>
						<entry accept="filename">
							<label>Select a File</label>
							<variable>FILE_TO_PLAY</variable>
						</entry>
						<button>
							<input file stock="gtk-open"></input>
							<variable>BROWSE_FILE</variable>
							<action type="fileselect">FILE_TO_PLAY</action>
						</button>
					</hbox>
				</frame>
				<hbox>
					<button>
						<label>'${HTML_karaoke_scriptname}'</label>
						<action type="command">'${HTML_karaoke_scriptname}' "$FILE_TO_PLAY"</action>
					</button>
					<button>
						<label>'${xterm_karaoke_scriptname}'</label>
						<action type="command">'${xterm_karaoke_scriptname}' "$FILE_TO_PLAY"</action>
					</button>
					<button>
						<label>pykar</label>
						<action type="command">pykar_height_1=199; pykar_height_2=324 ; pykar --width="1236" --height="${pykar_height_1}" --font-scale="3" --title="pykar: $(basename "$CHOISES")" "$FILE_TO_PLAY"</action>
					</button>
					<button>
						<label>xplaymidi</label>
						<action type="command">xplaymidi "$FILE_TO_PLAY"</action>
					</button>
					<button>
						<label>timidity</label>
						<action type="command">timidity -A 105 --volume-compensation -igt "$FILE_TO_PLAY"</action>
					</button>
					<button>
						<input file stock="gtk-edit"></input>
						<action type="command">export FILE_TO_PLAY ; bash -c "source ${bk_COMMON}; extract_song_lyric \"${FILE_TO_PLAY}\" ; clean_temp"</action>
					</button>
					<button>
						<input file stock="gtk-info"></input>
						<action type="command">export FILE_TO_PLAY ; bash -c "source ${bk_COMMON}; message \"$(${bk_OUT} -i "${FILE_TO_PLAY}" )\" ; clean_temp"</action>
					</button>
				</hbox>
			</frame>
			<hbox>
				<button use-stock="true" label="gtk-close">
					<action type="closewindow">GSW_FILE_DIALOG</action>
				</button>
			</hbox>
		</vbox>
	</window>
'
#
#
#
togli_accordi()
	{
	# "internal" way doesn't use this function anymore...
	testo="${1}"
	echo "${testo}" | gsed s\^' [[:digit:]]\?'^'\n'^g | gsed s\^'%.*'^''^g | \
		(
		IFS=$'\n'
		while read -r riga
			do
			if [ ${#riga} -eq 0 ]
				then
				echo -n " "
			else
				echo -n "${riga} "
			fi
		done 
		)
	}
#
#
#
togli_intestazione()
	{
	# "internal" way doesn't use this function anymore...
	testo="${1}"
	echo "${testo#*@*/}"
	}
#
#
#
cat__international_chars()
	{
	gsed s\#"M-4"#"'"#g | \
	gsed s\#"M-^R"#"'"#g | \
	gsed s\#'M-`'#'à'#g | \
	gsed s\#'M-a'#'á'#g | \
	gsed s\#'M-h'#'è'#g | \
	gsed s\#'M-i'#'é'#g | \
	gsed s\#'M-l'#'ì'#g | \
	gsed s\#'M-m'#'í'#g | \
	gsed s\#'M-r'#'ò'#g | \
	gsed s\#'M-s'#'ó'#g | \
	gsed s\#'M-y'#'ù'#g | \
	gsed s\#'M-z'#'ú'#g | \
	gsed s\#'M-H'#'È'#g
	}
#
distingui()
	{
	while read -r riga1
		do
		primo_char="${riga1:0:1}"
		if [ "${primo_char}" = "^" ]
			then
			char="${riga1:1:1}"
			codice_ascii=$(printf "%o" "'${char}" )
			numero_caratteri=$(( 8#${codice_ascii} - 8#100 ))
			if [ ${numero_caratteri} -ge 0 ]
				then
				echo -e "${riga1:2:${numero_caratteri}}"
				#
			else
				char="$(echo -e "\x${char}" )"
				codice_ascii=$(printf "%o" "'${char}" )
				numero_caratteri=$(( 8#${codice_ascii} - 8#100 ))
				echo -e "${riga1:2:${numero_caratteri}}"
				#
			fi
			#
		else
			char="${riga1:0:1}"
			numero_caratteri=$(printf "%d" "'${char}" )
			echo -e "${riga1:1:${numero_caratteri}}"
			#
		fi
		#
	done
	}
#
estrai()
	{
	export song="${1}"
	#
	#echo "${testo_raw}" 1>&2
	echo "${testo_raw}" | \
	tr '\\' '/' | \
	tr '\n' '\\' | gsed s\#'\\'#'^J'#g | \
	gsed s\#"${!song}"#'\nATREASUREINSIDEANDSTRONGOUTSIDEMYPOWERISTHESHELL'#g | \
	gsed -n s\#'ATREASUREINSIDEANDSTRONGOUTSIDEMYPOWERISTHESHELL\(.*\)'#'\1'#p | \
	cut -d '^' -f 1,2,3 | \
	(
	IFS=$'\n'
	distingui
	)
	#gsed s\#'M-\^[A-G]'#' ^'#g | \
	#gsed s\#'.M-\^[H-Z]'#' ^'#g | \
	#gsed s\#'M-'#' ^'#g 
	#
	}
#
extract__internal()
	{
	#
	# ...ONLY with shell tools... 
	# this is "true" bash's karaoke... ;-)
	#
	#################################
	#
	if [ "${1}" = "--text" -o "${1}" = "--lyric" ]
		then
		midi="${2}"
		extract_field="$(echo "${1}" | tr -d '-' )"
	else
		midi="${1}"
		extract_field=""
	fi
	text="M-^?^A"
	lyric="M-^?^E"
	#
	#################################
	#

	#
	######################
	#
	testo_raw="$(cat -v "${midi}" | cat__international_chars )"
	#
	######
	#
	: testo_raw
	if [ ${#extract_field} -gt 0 ]
		then
		echo -e "\n\"${extract_field}\" field :\n---------------------------------------"
		if [ "${extract_field}" = "text" ]
			then
			canzone_text="$(estrai "text" )" ; canzone_text_senza_NOTE="$(echo "${canzone_text}" | tr -d 'ABCDEFGMajminSus34579#b ' )"
			#
			pre_testo="${canzone_text}"
			#
		elif [ "${extract_field}" = "lyric" ]
			then
			canzone_lyric="$(estrai "lyric" )"
			#
			pre_testo="${canzone_lyric}"
			#
		fi
	else
		#
		######
		#
		canzone_text="$(estrai "text" )"
		canzone_text_senza_NOTE="$(echo "${canzone_text}" | tr -d 'ABCDEFGMajminSus34579#b ' )"
		#
		canzone_lyric="$(estrai "lyric" )"
		#
		######
		#
		pre_testo="$( if [ ${#canzone_lyric} -gt ${#canzone_text_senza_NOTE} ]
				then
				echo "${canzone_lyric}"
				#
			else
				echo "${canzone_text}"
				#
			fi )"
	fi
	: pre_testo
	#
	#########################
	togli_accordi_internal()
		{
		testo="${1}"
		echo "${testo}"  | tr ' ' '\n' | gsed s\^'%.*'^''^g | \
			(
			IFS=$'\n'
			while read -r riga
				do
				if [ ${#riga} -eq 0 ]
					then
					echo -n ""
				else
					echo -n "${riga} "
				fi
			done 
			)
		}
	#
	togli_intestazione_internal()
		{
		testo="${1}"
		#
		#echo "${testo##@*@}"
		echo "${testo/#*@/@}" | \
		gsed s\#'@K'#'Info: '# | \
		gsed s\#'@L'#'Language: '# | \
		gsed s\#'@T'#'*** '#g | \
		gsed s\#'@[[:upper:]]'#" ${end_strophe}"#g
		}
	#
	: fine_canzone
	#
	if [ ${#extract_field} -eq 0 ]
		then
		end_strophe=""
	else
		end_strophe="ATREASUREINSIDEANDSTRONGOUTSIDEMYPOWERISTHESHELL"
	fi
	testo_di_controllo_pre="$(echo "$(
					echo -e "${pre_testo}${fine_canzone}" | \
					cut -d '^' -f 1 | \
						(
						IFS=$'\n'
						while read -r riga
							do
							if [ ${#riga} -eq 0 ]
								then
								echo -n " ${end_strophe}^"
							else
								echo -n "${riga}^"
							fi
						done 
						) | \
					gsed s\#" ^ ^ \?^\?"#" ${end_strophe}^"#g | \
					tr '\t' ' ' | \
					tr '<' ' ' | \
					gsed s\#"/"#" ${end_strophe}"#g | \
					tr -s ' ' 
					)"  
				)"
	testo_di_controllo_pre="$(togli_accordi_internal "${testo_di_controllo_pre}" )"
	testo_di_controllo_pre="$(togli_intestazione_internal "${testo_di_controllo_pre}" )"
	testo_di_controllo_pre="$(echo "${testo_di_controllo_pre}" | \
					gsed s\#'\([[:alnum:]]\+\)\([[:punct:]]*[[:blank:]]*[[:punct:]]*[[:blank:]]*\)^'#'\1^\2'#g | \
					gsed s\#'\([[:punct:]]\)^'#'\1'#g | \
					gsed s\#'\([[:blank:]]\)^'#'\1'#g | \
					gsed s\#"\^\(['\"?!);,:.]\)"#"\1^"#g )"
	#
	if [ ${#extract_field} -eq 0 ]
		then
		testo_di_controllo="$(echo "${testo_di_controllo_pre}" | sposta_parole "${columns}" )"
	else
		testo_di_controllo="${testo_di_controllo_pre}"
	fi
	: testo_di_controllo
	#
	###################
	#
	testo="$(echo "${testo_di_controllo}" | tr -d '^' )"
	if [ ${#extract_field} -eq 0 ]
		then
		:
	else
		testo="$(echo "${testo}" | gsed s\#"${end_strophe}"#'\n'#g )"
	fi
	: testo
	#
	###################
	#
	if [ ${#extract_field} -eq 0 ]
		then
		#
		testo_di_controllo_per_media="$(echo "${testo_di_controllo}" | tr '^' '\n' )"
		linee=$(echo "${testo_di_controllo_per_media}" | wc -l )
		var_media_columns=$(echo "${testo_di_controllo_per_media}" | media_columns ${linee} )
		#
		if [ ${var_media_columns} -gt ${soglia} ]
			then
			export righe=3
		elif [ ${var_media_columns} -le ${soglia} ]
			then
			export righe=2
		fi
		: righe 
		#
	else
		#
		echo "${testo}"
		echo -e "\n---------------------------------------\n"
		#
	fi
	#
	###################
	#
	}
#
#
#
extract__through__midi_text24_pl()
	{
	#
	if [ $(echo -n "$(type "midi_text24.pl" 2>/dev/null)" | wc -c) -eq 0 ]
		then
		[ "${l}" = "IT" ] && alert_message "Errore:\nmidi_text24.pl\nnon trovato..."
		[ "${l}" = "EN" ] && alert_message "Error:\nmidi_text24.pl\nnot found..."
		exit 1
	else
		midi_text24_pl__path="$(type -P "midi_text24.pl" | head -n 1)"
	fi
	#
	#################################
	#
	midi="${1}"
	text="Text event"
	lyric="Lyric"
	#
	#################################
	#
	extract()
		{
		while read -r -a array_riga
			do
			if [[ ${array_riga[0]} =~ .*[[:alnum:]]+.* ]]
				then
				testo_caratt="$(echo "${array_riga[0]}" | gsed s\#'[[:blank:]]*$'#''#g )"
				num_caratt=${array_riga[1]}
				if [[ ${num_caratt} =~ [[:digit:]]+ ]]
					then
					if [ ${#testo_caratt} -eq ${num_caratt} ]
						then
						echo -n "${testo_caratt}" ; continue
					else
						echo -n "${testo_caratt} " ; continue
					fi
				else
					echo ; continue
				fi
			else
				echo "/" ; continue
			fi
		done 
		}
	#
	extract_di_controllo()
		{
		while read -r -a array_riga
			do
			if [[ ${array_riga[0]} =~ .*[[:alnum:]]+.* ]]
				then
				testo_caratt="$(echo "${array_riga[0]}" | gsed s\#'[[:blank:]]*$'#''#g )"
				num_caratt=${array_riga[1]}
				if [[ ${num_caratt} =~ [[:digit:]]+ ]]
					then
					if [ ${#testo_caratt} -eq ${num_caratt} ]
						then
						echo -n "${testo_caratt}^" ; continue
					else
						echo -n "${testo_caratt} ^" ; continue
					fi
				else
					echo ; continue
				fi
			else
				echo "/^" ; continue
			fi
		done 
		}
	#
	################################# 
	# 
	raw="$("${midi_text24_pl__path}" "${midi}" 2>/dev/null | iconv -f "${char_encoding}" )"
	#
	canzone_text="$(IFS=$'()\t\n' && \
			echo "${raw}" | \
			tr '\' '/' | \
			gsed -n s\#"^.*${text}:[[:blank:]]*\(.*\)"#'\1'#p | \
			extract | tr '\' '\n' | tr '/' '\n' && \
			IFS=$' \t\n' )"
	canzone_text_di_controllo="$(IFS=$'()\t\n' && \
			echo "${raw}" | \
			tr '\' '/' | \
			gsed -n s\#"^.*${text}:[[:blank:]]*\(.*\)"#'\1'#p | \
			extract_di_controllo | tr '\' '\n' | tr '/' '\n' && \
			IFS=$' \t\n' )"
	#
	canzone_text_senza_NOTE="$(echo "${canzone_text}" | tr -d 'ABCDEFGMajminSsus34579#' )"
	canzone_text_senza_NOTE_di_controllo="$(echo "${canzone_text_di_controllo}" | tr -d 'ABCDEFGMajminSsus34579#' )"
	#
	canzone_lyric="$(IFS=$'()\t\n' && \
			echo "${raw}" | \
			tr '\' '/' | \
			gsed -n s\#"^.*${lyric}:[[:blank:]]*\(.*\)"#'\1'#p | \
			extract && \
			IFS=$' \t\n' )"
	canzone_lyric_di_controllo="$(IFS=$'()\t\n' && \
			echo "${raw}" | \
			tr '\' '/' | \
			gsed -n s\#"^.*${lyric}:[[:blank:]]*\(.*\)"#'\1'#p | \
			extract_di_controllo && \
			IFS=$' \t\n' )"
	#
	#########
	#
	pre_testo="$( if [ ${#canzone_lyric} -gt ${#canzone_text_senza_NOTE} ]
				then
				echo "${canzone_lyric}"
				#
			else
				echo "${canzone_text}"
				#
			fi | gsed -e '\#^$#d' )"
	pre_testo_di_controllo="$( if [ ${#canzone_lyric_di_controllo} -gt ${#canzone_text_senza_NOTE_di_controllo} ]
				then
				echo "${canzone_lyric_di_controllo}"
				#
			else
				echo "${canzone_text_di_controllo}"
				#
			fi | gsed -e '\#^$#d' )"
	#
	testo_di_controllo="$(echo ${pre_testo_di_controllo} | tr '\t' ' ' | tr -s ' ' | tr '<' ' / ' )"
	: testo_di_controllo
	#
	testo_di_controllo_per_media="$(echo "${testo_di_controllo}" | tr '^' '\n' )"
	linee=$(echo "${testo_di_controllo_per_media}" | wc -l )
	var_media_columns=$(echo "${testo_di_controllo_per_media}" | media_columns ${linee} )
	if [ ${var_media_columns} -gt ${soglia} ]
		then
		export righe=3
	elif [ ${var_media_columns} -le ${soglia} ]
		then
		export righe=2
	fi
	: righe 
	#
	testo="$(echo "${pre_testo} ${fine_canzone}" )"
	testo="$(echo "${testo}" | tr '\t' ' ' | tr -s ' ' | tr '<' ' / ' )"
	#
	: testo
	#
	testo="$(togli_accordi "${testo}" )"
	testo="$(togli_intestazione  "${testo}" )"
	: testo
	#
	testo_di_controllo="$(togli_accordi "${testo_di_controllo}" )"
	testo_di_controllo="$(togli_intestazione "${testo_di_controllo}" )"
	: testo_di_controllo
	}
#
#
#
extract__through__pykar()
	{
	#
	if [ $(echo -n "$(type "pykar" 2>/dev/null)" | wc -c) -eq 0 ]
		then
		[ "${l}" = "IT" ] && alert_message "Errore:\npykar\nnon trovato..."
		[ "${l}" = "EN" ] && alert_message "Error:\npykar\nnot found..."
		exit 1
	else
		pykar__path="$(type -P "pykar" | head -n 1)"
	fi
	#
	#################################
	#
	midi="${1}"
	#
		{ 
		unset DISPLAY ; pykar -n "${midi}" 2>/dev/null | gsed -n s\#'.*Lyric: \(.*\)'#'\1'#p 1> "${lyric}" 
		} &
	#
	#################################
	#
	sleep 4
	#
	RIPROVATO="NO"
	while :
		do
		array_pid_di_pykar=( $(ps auxww | grep "pykar" | grep -v grep | gsed -n s\#'[[:alnum:]]\+[[:blank:]]\+\([[:digit:]]\+\)[[:blank:]]\+.*'#'\1'#p) )
		if [ ${#array_pid_di_pykar[@]} -eq 0 ]
			then
			if [ "${RIPROVATO}" = "SI" ]
				then
				exit 1
			fi
			sleep 1
			[ "${l}" = "IT" ] && wait_for "Nessun PID di pykar trovato...\nci riprovo tra 4 secondi..."
			[ "${l}" = "EN" ] && wait_for "No pykar PID found...\nI will retry in 4 seconds..."
			sleep 4
			terminate_wait_for
			RIPROVATO="SI"
			continue
		elif [ ${#array_pid_di_pykar[@]} -eq 1 ]
			then
			break
		elif [ ${#array_pid_di_pykar[@]} -gt 1 ]
			then
			[ "${l}" = "IT" ] && alert_message "Trovati\n${#array_pid_di_pykar[@]} PIDs\ndi pykar...\n\n( fai\n\"killall pykar\" )"
			[ "${l}" = "EN" ] && alert_message "Found\n${#array_pid_di_pykar[@]} pykar\nPIDs...\n\n( please do\n\"killall pykar\" )"
			exit 1
		fi
	done
	#
	#
	sleep 3 && kill ${array_pid_di_pykar[0]} || echo "Oooops..."
	#
	#
	sleep 2
	IFS=$' \t\n'
	testo_pre="$(0< "${lyric}" )"
	if [ $(echo -n "${testo_pre}" | wc -c) -eq 0 ]
		then
		#
		if [ "${l}" = "IT" ]
			then 
			question "Attenzione: \n il file selezionato \n non contiene le parole...  :( \n -sorry- \n\n (il file: \"${lyric}\" \n e' vuoto) \n\n\n\n Vuoi ascoltarlo \n ugualmente?"
			risposta=${?}
		elif [ "${l}" = "EN" ]
			then 
			question "Warning: \n selected file \n doesn't have words...  :( \n -sorry- \n\n (file: \"${lyric}\" \n is empty) \n\n\n\n Do you want \n play it \n the same ?"
			risposta=${?}
		fi
		if [ ${risposta} -eq 0 ]
			then
			terminate_wait_for
			eval timidity ${soundfont_string} -A 105 --volume-compensation -idt \"${midi}\"
			exit 0
		elif [ ${risposta} -eq 1 ]
			then
			exit 1
		else
			exit 1
		fi
		#
	fi
	#
	pre_testo="$( while read linea_da_raddrizzare
				do
				#
				if [ "XYZ$(echo "${linea_da_raddrizzare}" | tr -dc '[:alnum:]')" = "XYZ" ]
					then
					echo "${linea_da_raddrizzare}"
				else
					echo -n "${linea_da_raddrizzare} "
				fi
				#
			done 0< "${lyric}" | gsed -e '\#^$#d' )"
	pre_testo_di_controllo="$( while read linea_da_raddrizzare
				do
				#
				if [ "XYZ$(echo "${linea_da_raddrizzare}" | tr -dc '[:alnum:]')" = "XYZ" ]
					then
					echo "${linea_da_raddrizzare}^"
				else
					echo -n "${linea_da_raddrizzare} ^"
				fi
				#
			done 0< "${lyric}" | gsed -e '\#^$#d' )"
	rm -f "${lyric}"
	#
	testo_di_controllo="$(echo "$(echo "${pre_testo_di_controllo}" | while read linea; do echo -n "${linea} " ; done ) ${fine_canzone}" | tr '\t' ' ' | tr -s ' ' | tr '<' ' / ' | tr '\' '/' )"
	: testo_di_controllo
	#
	testo_di_controllo_per_media="$(echo "${testo_di_controllo}" | tr '^' '\n' )"
	linee=$(echo "${testo_di_controllo_per_media}" | wc -l )
	var_media_columns=$(echo "${testo_di_controllo_per_media}" | media_columns ${linee} )
	if [ ${var_media_columns} -gt ${soglia} ]
		then
		export righe=3
	elif [ ${var_media_columns} -le ${soglia} ]
		then
		export righe=2
	fi
	: righe 
	#
	testo="$(echo "$(echo "${pre_testo}" | gsed -n s\#'\(.*\).$'#'\1'#p | while read linea; do echo -n "${linea} " ; done ) ${fine_canzone}" | tr '\t' ' ' | tr -s ' ' | tr '<' ' / ' | tr '\' '/' )"
	#
	: testo
	#
	testo="$(togli_accordi "${testo}" )"
	testo="$(togli_intestazione  "${testo}" )"
	: testo
	#
	testo_di_controllo="$(togli_accordi "${testo_di_controllo}" )"
	testo_di_controllo="$(togli_intestazione "${testo_di_controllo}" )"
	: testo_di_controllo
	}
#
#
#
media_columns()
	{
	diviso=${1}
	v_di_w__max_columns=0
	threshold=0
	stringa="$(while read riga
		do
		v_di_w__max_columns=$(( ${v_di_w__max_columns} + 1 ))
		if [ ${v_di_w__max_columns} -lt ${threshold} ]
			then
			continue
		elif [ ${v_di_w__max_columns} -ge ${threshold} ]
			then
			columns=${#riga}
			echo -n "${columns} + "
		fi
	done | gsed s\#' + $'#''#g )"
	echo "$(( $(( ${stringa} )) / ${diviso} ))"
	}
#
#
#
sposta_parole()
	{
	soglia_riga=${1}
	soglia=$(( ${soglia_riga} - 1 ))
	#
	differenza=0
	for (( i=1 ; ; i++ ))
		do
		: ====================
		: $i
		IFS=$'\t\n' ; read -r -n 1 car ; IFS=$' \t\n'
		#CCCCCCCCCCCCCCCCCCCCCCC="${car}"
		if [ "${car}" = "" ]
			then
			: fine_riga
			stringa_output="${stringa}"
			riga="${stringa_output}"
			riga="${rimanenza_riga}${riga}"
			#
			echo -n "${riga}"
			#
			##
			#quanti_caratteri_fr=$(echo -n "${riga}" | tr -d '^' | wc -c )
			#echo "(FINE=>${quanti_caratteri_fr})"
			##
			#
			#
			break
		fi
		#echo -n "${car}"
		stringa="${stringa}${car}"
		#
		#
		: ${i}
		: "=>"
		[ "${car}" = "^" ] && (( i-- ))
		: ${i}
		: ${soglia_riga}
		resto_divisione=$(( ${i} % ${soglia_riga} ))
		if [ ${resto_divisione} -eq 0 ] 
			then
			: BINGOOOOOOOOO
			######################################################################
			######################################################################
			######################################################################
			stringa_output="${stringa}"
			unset stringa
			#
			##
			#
			riga="${stringa_output}"
			IFS=$' \t\n'
			#
			if [ ${differenza} -eq 0 ]
				then
				: riga
			elif [ ${differenza} -ne 0 ]
				then
				: ${rimanenza_riga}
				: +
				: ${riga}
				riga="${rimanenza_riga}${riga}"
				#
				unset rimanenza_riga
				differenza=0
				#
			fi
			#
			#controllo_riga="${riga}"
			quanti_caratteri=$(echo -n "${riga}" | tr -d '^' | wc -c )
			#sleep 4
			#
			#let's check character # ${soglia} :
			car_soglia="${riga:(-1):1}"
			if [ "X${car_soglia}" = "X " -o "${#car_soglia}" = "0" -o "X${car_soglia}" = "X^" ]
				then
				echo -n "${riga}"
				#
				##
				#quanti_caratteri_yes=$(echo -n "${riga}" | tr -d '^' | wc -c )
				#echo "(YES=>${quanti_caratteri_yes})"
				##
				#
			else
				index_negativo="-1"
				while [ "${riga:(${index_negativo}):1}" != "" ]
					do
					index_negativo=$(( ${index_negativo} - 1 ))
					car="${riga:(${index_negativo}):1}"
					#
					if [ "${car}" != " " ]
						then
						# we didn't find the space char yet...
						#
						continue 1
						#
					elif [ "${car}" = " " ]
						then
						# we found it !!
						#
						# 1)
						rimanenza_riga="${riga:(${index_negativo})}"
						prima_parte_riga="${riga%${rimanenza_riga}}"
						echo -n "${prima_parte_riga}"
						# 
						# 2)
						quanti_spazi_servono_ancora=$(echo -n "${rimanenza_riga}" | tr -d '^' | wc -c )
						for (( n=1 ; n <= ${quanti_spazi_servono_ancora} ; n++ ))
							do
							echo -n " "
						done 
						#
						##
						#quanti_caratteri_ppr=$(echo -n "${prima_parte_riga}" | tr -d '^' | wc -c )
						#echo "($(( ${quanti_caratteri_ppr} + ${quanti_spazi_servono_ancora} )))"
						##
						#
						#
						# 3)
						: rimanenza_riga
						differenza=${quanti_spazi_servono_ancora}
						: $i
						i=$(( ${i} + ${differenza} ))
						continue 2
						#
					fi # if [ "${car}" != " " ]
					#
				done # for (( car_num=${soglia} ; car_num >= 0 ; car_num-- ))
				#
				# Note: if flow is here, it means word is bigger than "${soglia}" (it has more chars) ...
				echo -n "${riga}"
				#
				##
				#quanti_caratteri_big=$(echo -n "${riga}" | tr -d '^' | wc -c )
				#echo "(BIGGER=>${quanti_caratteri_big})"
				##
				#
			fi # if [ "${car_soglia}" = " " -o "${car_soglia}" = "" ]
			######################################################################
			######################################################################
			######################################################################
			#
		fi # if [ ${resto_divisione} -eq 0 ]
		#
	done # for (( i=1 ; ; i++ ))
	#
	}
#
#
#

#
#
#
find_pid_py()
	{
	command_line="${1}"
	#
	outputta_python_script()
		{
		cat <<'EOScript'
#!/usr/bin/env python
#-*- coding:utf-8 -*-
#
# pygrep.py
# Copyright (C) 2012 Davide Depau <david.dep.1996@gmail.com>
#
# PyGrep is free software: you can redistribute it and/or modify it
# under the terms of the GNU General Public License as published by the
# Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# PyGrep is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
# See the GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program.    If not, see <http://www.gnu.org/licenses/>.

import os, sys

if sys.argv[1] in ("-h", "--help"):
    print "Usage: {0} [-h,--help] [command_line]\n\nReturns the PID of the process with the given command line."
    sys.exit(0)
else:
    cmdline = sys.argv[1]

dirs = os.listdir("/proc")

status = 1
for d in dirs:
    if "." in d:
        continue
    try:
        int(d)
        c = open(os.path.join("/proc", d, "cmdline"), "r")
        cmd = c.read().replace("\x00", " ")
        c.close()
        if cmdline in cmd and not sys.argv[0] in cmd:
            print d
            status = 0
    except ValueError:
        pass

sys.exit(status)
EOScript
		}
	#
	pid_found="$(python <(outputta_python_script ) "${command_line}" )"
	#
	[ ${#pid_found} -gt 0 ] && echo "${pid_found}" || echo "PID-NOT-FOUND"
	#
	}
#
#
#
:<<-'EOB'

( Final various notes... )

	#
	########################
	#
	cat <<-find_file_1 1> "${find_file}"
	# "find midi" functions:
	export dummy_file="${dummy_file}"
	export database="${database}"
	export dir_Karaoke="${dir_Karaoke}"
	
find_file_1
	cat <<-'find_file_2' 1>> "${find_file}"
	find_and_write()
		{
		#string_to_find="modugno"
		string_to_find="$(cat "${dummy_file}" )"
		artist_title="$(echo "${string_to_find}" | tr -c '[[:alnum:]]' '?' | sed s\#'\?'#'\.\*'#g )"
		list="$(cat "${database}" | sed -n "\#${artist_title}#Ip" )"
		echo "${list}" 1> "${dir_Karaoke}/lista_karaoke.txt"
		}
find_file_2
	#
	#######################
	#

EOB
#
#
#
